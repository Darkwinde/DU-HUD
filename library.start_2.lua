-- Expugnator START: library.start()
function Atlas()
    return {
        [0] = {
            [1]={
                GM=6930729684,
                bodyId=1,
                center={x=17465536.000,y=22665536.000,z=-34464.000},
                name='Madis',
                planetarySystemId=0,
                radius=44300,
                surface=850,
                spaceEngine=4500
            },
            [2]={
                GM=157470826617,
                bodyId=2,
                center={x=-8.000,y=-8.000,z=-126303.000},
                name='Alioth',
                planetarySystemId=0,
                radius=126068,
                surface=0,
                spaceEngine=3500
            },
            [3]={
                GM=11776905000,
                bodyId=3,
                center={x=29165536.000,y=10865536.000,z=65536.000},
                name='Thades',
                planetarySystemId=0,
                radius=49000,
                surface=13600,
                spaceEngine=21600
            },
            [4]={
                GM=14893847582,
                bodyId=4,
                center={x=-13234464.000,y=55765536.000,z=465536.000},
                name='Talemai',
                planetarySystemId=0,
                radius=57450,
                surface=-1,
                spaceEngine=-1
            },
            [5]={
                GM=16951680000,
                bodyId=5,
                center={x=-43534464.000,y=22565536.000,z=-48934464.000},
                name='Feli',
                planetarySystemId=0,
                radius=60000,
                surface=-1,
                spaceEngine=-1
            },
            [6]={
                GM=10502547741,
                bodyId=6,
                center={x=52765536.000,y=27165538.000,z=52065535.000},
                name='Sicari',
                planetarySystemId=0,
                radius=51100,
                surface=0,
                spaceEngine=-1
            },
            [7]={
                GM=13033380591,
                bodyId=7,
                center={x=58665538.000,y=29665535.000,z=58165535.000},
                name='Sinnen',
                planetarySystemId=0,
                radius=54950,
                surface=400,
                spaceEngine=-1
            },
            [8]={
                GM=18477723600,
                bodyId=8,
                center={x=80865538.000,y=54665536.000,z=-934463.940},
                name='Teoma',
                planetarySystemId=0,
                radius=62000,
                surface=-1,
                spaceEngine=-1
            },
            [9]={
                GM=18606274330,
                bodyId=9,
                center={x=-94134462.000,y=12765534.000,z=-3634464.000},
                name='Jago',
                planetarySystemId=0,
                radius=61590,
                surface=-1,
                spaceEngine=-1
            },
            [10]={
                GM=78480000,
                bodyId=10,
                center={x=17448118.224,y=22966846.286,z=143078.820},
                name='Madis Moon 1',
                planetarySystemId=0,
                radius=10000,
                surface=-1,
                spaceEngine=-1
            },
            [11]={
                GM=237402000,
                bodyId=11,
                center={x=17194626.000,y=22243633.880,z=-214962.810},
                name='Madis Moon 2',
                planetarySystemId=0,
                radius=11000,
                surface=-1,
                spaceEngine=-1
            },
            [12]={
                GM=265046609,
                bodyId=12,
                center={x=17520614.000,y=22184730.000,z=-309989.990},
                name='Madis Moon 3',
                planetarySystemId=0,
                radius=15005,
                surface=-1,
                spaceEngine=-1
            },
            [21]={
                GM=2118960000,
                bodyId=21,
                center={x=457933.000,y=-1509011.000,z=115524.000},
                name='Alioth Moon 1',
                planetarySystemId=0,
                radius=30000,
                surface=0,
                spaceEngine=0
            },
            [22]={
                GM=2165833514,
                bodyId=22,
                center={x=-1692694.000,y=729681.000,z=-411464.000},
                name='Alioth Moon 4',
                planetarySystemId=0,
                radius=30330,
                surface=0,
                spaceEngine=0
            },
            [26]={
                GM=68234043600,
                bodyId=26,
                center={x=-1404835.000,y=562655.000,z=-285074.000},
                name='Sanctuary',
                planetarySystemId=0,
                radius=83400,
                surface=0,
                spaceEngine=4300
            },
            [30]={
                GM=211564034,
                bodyId=30,
                center={x=29214402.000,y=10907080.695,z=433858.200},
                name='Thades Moon 1',
                planetarySystemId=0,
                radius=14002,
                surface=-1,
                spaceEngine=-1
            },
            [31]={
                GM=264870000,
                bodyId=31,
                center={x=29404193.000,y=10432768.000,z=19554.131},
                name='Thades Moon 2',
                planetarySystemId=0,
                radius=15000,
                surface=-1,
                spaceEngine=-1
            },
            [40]={
                GM=141264000,
                bodyId=40,
                center={x=-13503090.000,y=55594325.000,z=769838.640},
                name='Talemai Moon 2',
                planetarySystemId=0,
                radius=12000,
                surface=-1,
                spaceEngine=-1
            },
            [41]={
                GM=106830900,
                bodyId=41,
                center={x=-12800515.000,y=55700259.000,z=325207.840},
                name='Talemai Moon 3',
                planetarySystemId=0,
                radius=11000,
                surface=-1,
                spaceEngine=-1
            },
            [42]={
                GM=264870000,
                bodyId=42,
                center={x=-13058408.000,y=55781856.000,z=740177.760},
                name='Talemai Moon 1',
                planetarySystemId=0,
                radius=15000,
                surface=-1,
                spaceEngine=-1
            },
            [50]={
                GM=499917600,
                bodyId=50,
                center={x=-43902841.780,y=22261034.700,z=-48862386.000},
                name='Feli Moon 1',
                planetarySystemId=0,
                radius=14000,
                surface=-1,
                spaceEngine=-1
            },
            [70]={
                GM=396912600,
                bodyId=70,
                center={x=58969616.000,y=29797945.000,z=57969449.000},
                name='Sinnen Moon 1',
                planetarySystemId=0,
                radius=17000,
                surface=-1,
                spaceEngine=-1
            },
            [100]={
                GM=13975172474,
                bodyId=100,
                center={x=98865536.000,y=-13534464.000,z=-934461.990},
                name='Lacobus',
                planetarySystemId=0,
                radius=55650,
                surface=-1,
                spaceEngine=-1
            },
            [101]={
                GM=264870000,
                bodyId=101,
                center={x=98905288.170,y=-13950921.100,z=-647589.530},
                name='Lacobus Moon 3',
                planetarySystemId=0,
                radius=15000,
                surface=-1,
                spaceEngine=-1
            },
            [102]={
                GM=444981600,
                bodyId=102,
                center={x=99180968.000,y=-13783862.000,z=-926156.400},
                name='Lacobus Moon 1',
                planetarySystemId=0,
                radius=18000,
                surface=-1,
                spaceEngine=-1
            },
            [103]={
                GM=211503600,
                bodyId=103,
                center={x=99250052.000,y=-13629215.000,z=-1059341.400},
                name='Lacobus Moon 2',
                planetarySystemId=0,
                radius=14000,
                surface=-1,
                spaceEngine=-1
            },
            [110]={
                GM=9204742375,
                bodyId=110,
                center={x=14165536.000,y=-85634465.000,z=-934464.300},
                name='Symeon',
                planetarySystemId=0,
                radius=49050,
                surface=-1,
                spaceEngine=-1
            },
            [120]={
                GM=7135606629,
                bodyId=120,
                center={x=2865536.700,y=-99034464.000,z=-934462.020},
                name='Ion',
                planetarySystemId=0,
                radius=44950,
                surface=-1,
                spaceEngine=-1
            },
            [121]={
                GM=106830900,
                bodyId=121,
                center={x=2472916.800,y=-99133747.000,z=-1133582.800},
                name='Ion Moon 1',
                planetarySystemId=0,
                radius=11000,
                surface=-1,
                spaceEngine=-1
            },
            [122]={
                GM=176580000,
                bodyId=122,
                center={x=2995424.500,y=-99275010.000,z=-1378480.700},
                name='Ion Moon 2',
                planetarySystemId=0,
                radius=15000,
                surface=-1,
                spaceEngine=-1
            }  
        }
    }
end

--[[ 
Provides methods for computing orbital information for an object

Usage:
Kepler = require('autoconf.custom.kepler')
alioth = Kepler({ GM=157470826617,
bodyId=2,
center={x=-8.000,y=-8.000,z=-126303.000},
name='Alioth',
planetarySystemId=0,
radius=126068
})
altitude = 6000
position = '::pos{0,2,0,0,6000}'

e, o     = alioth:escapeAndOrbitalSpeed(altitude)
orbit    = alioth:orbitalParameters(position, {0, o+1, 0})

print("Eccentricity " .. orbit.eccentricity)
print("Perihelion " .. orbit.periapsis.altitude)
print("Max. speed " .. orbit.periapsis.speed)
print("Circular orbit speed " .. orbit.periapsis.circularOrbitSpeed)
print("Aphelion "  .. orbit.apoapsis.altitude)
print("Min. speed " .. orbit.apoapsis.speed)
print("Orbital period " .. orbit.period)
--- output:
Eccentricity 0.0018324307017878
Perihelion 6000.0
Max. speed 1092.9462297033
Circular orbit speed 1091.9462297033
Aphelion 6484.8994605062
Min. speed 1088.9480596194
Orbital period 762.02818214049

Methods:
Kepler:escapeAndOrbitalSpeed - for a given celestial body and altitude.
Kepler:orbitalParameters - for a given massless object and a celestial body.

Description
The motion of an object in the vicinity of substantially larger mass is
in the domain of the "2-body problem". By assuming the object whose motion
is of interest is of negligable mass simplifies the calculations of:
the speed to escape the body, the speed of a circular orbit, and the
parameters defining the orbit of the object (or the lack of orbit as the
case may be).

Orbital Parameters:
periapsis - the closest approach to the planet
apoapsis - the furthest point from the planet if in orbit (otherwise nil)
eccentricity - 0 for circular orbits
<1 for elliptical orbits
1 for parabiolic trajectory
>1 for hyperbolic trajectory
period - time (in seconds) to complete an orbit

Also See: planetref.lua
]]--

function Keplers()
    local vec3       = require('cpml.vec3')
    local PlanetRef  = PlanetRef()

    local function isString(s) return type(s)   == 'string' end
    local function isTable(t)  return type(t)   == 'table'  end

    local function float_eq(a,b)
        if a == 0 then return math.abs(b) < 1e-09 end
        if b == 0 then return math.abs(a) < 1e-09 end
        return math.abs(a - b) < math.max(math.abs(a),math.abs(b))*epsilon
    end


    Kepler = {}
    Kepler.__index = Kepler

    --
    -- escapeAndOrbitalSpeed - speed required to escape and for a circular orbit
    -- altitude [in]: the height of the orbit in meters above "sea-level"
    -- return: the speed in m/s needed to escape the celestial body and to orbit it.
    --
    function Kepler:escapeAndOrbitalSpeed(altitude)
        assert(self.body)
        -- P = -GMm/r and KE = mv^2/2 (no lorentz factor used)
        -- mv^2/2 = GMm/r
        -- v^2 = 2GM/r
        -- v = sqrt(2GM/r1)
        local distance = altitude + self.body.radius

        if not float_eq(distance, 0) then
            local orbit = math.sqrt(self.body.GM/distance)
            return math.sqrt(2)*orbit, orbit
        end
        return nil, nil
    end

    --
    -- orbitalParameters: determine the orbital elements for a two-body system.
    -- overload [in]: the world coordinates or map coordinates of a massless object.
    -- velocity [in]: The velocity of the massless point object in m/s.
    -- return: the 6 orbital elements for the massless object.
    --
    function Kepler:orbitalParameters(overload, local_velocity)
        assert(self.body)
        assert(isTable(overload) or isString(overload))
        assert(isTable(local_velocity))
        local pos = (isString(overload) or PlanetRef.isMapPosition(overload)) and
        self.body:convertToWorldCoordinates(overload) or
        vec3(overload)
        local v   = vec3(local_velocity)
        local r   = pos - self.body.center
        local v2  = v:len2()
        local d   = r:len()
        local mu  = self.body.GM
        local e   = ((v2 - mu/d)*r - r:dot(v)*v)/mu
        local a   = mu/(2*mu/d - v2)

        local ecc = e:len()
        local dir = e:normalize()
        local pd  = a*(1-ecc)
        local ad  = a*(1+ecc)
        local per = pd*dir + self.body.center
        local apo = ecc <= 1 and -ad*dir + self.body.center or nil
        local trm = math.sqrt(a*mu*(1-ecc*ecc))
        local Period = apo and 2*math.pi*math.sqrt(a^3/mu)

        local trueAnomaly = math.acos((e:dot(r))/(ecc*d))

        if r:dot(v) < 0 then
            trueAnomaly = -(trueAnomaly - 2*math.pi)
        end 

        local EccentricAnomaly = math.acos((math.cos(trueAnomaly) + ecc)/(1 + ecc * math.cos(trueAnomaly)))

        local timeTau = EccentricAnomaly
        if timeTau < 0 then
            timeTau = timeTau + 2*math.pi
        end  

        local MeanAnomaly = timeTau - ecc * math.sin(timeTau)
        local TimeSincePeriapsis = 0
        local TimeToPeriapsis = 0
        local TimeToApoapsis = 0


        if Period ~= nil then
            TimeSincePeriapsis = MeanAnomaly/(2*math.pi/Period)

            TimeToPeriapsis = Period - TimeSincePeriapsis
            TimeToApoapsis = TimeToPeriapsis + Period/2
            if trueAnomaly - math.pi > 0 then -- TBH I think something's wrong in my formulas because I needed this.
                TimeToPeriapsis = TimeSincePeriapsis
                TimeToApoapsis = TimeToPeriapsis + Period/2
            end
            if TimeToApoapsis > Period then
                TimeToApoapsis = TimeToApoapsis - Period
            end
        end
        return { periapsis       = { position           = per,
                speed              = trm/pd,
                circularOrbitSpeed = math.sqrt(mu/pd),
                altitude           = pd - self.body.radius},
            apoapsis        = apo and
            { position           = apo,
                speed              = trm/ad,
                circularOrbitSpeed = math.sqrt(mu/ad),
                altitude           = ad - self.body.radius
            },
            currentVelocity = v,
            currentPosition = pos,
            eccentricity    = ecc,
            period          = Period,
            eccentricAnomaly = EccentricAnomaly,
            meanAnomaly = MeanAnomaly,
            timeToPeriapsis = TimeToPeriapsis,
            timeToApoapsis = TimeToApoapsis
        }
    end

    local function new(bodyParameters)
        local params = PlanetRef.BodyParameters(bodyParameters.planetarySystemId,
            bodyParameters.bodyId,
            bodyParameters.radius,
            bodyParameters.center,
            bodyParameters.GM)
        return setmetatable({body = params}, Kepler)
    end

    return setmetatable(Kepler, { __call = function(_,...) return new(...) end })

end

--[[ 
DualUniverse kinematic equations
Author: JayleBreak

Usage (unit.start):
Kinematics = require('autoconf.custom.kinematics')

Methods:
computeAccelerationTime - "relativistic" version of t = (vf - vi)/a
computeDistanceAndTime - Return distance & time needed to reach final speed.
computeTravelTime - "relativistic" version of t=(sqrt(2ad+v^2)-v)/a

Description
DualUniverse increases the effective mass of constructs as their absolute
speed increases by using the "lorentz" factor (from relativity) as the scale
factor.  This results in an upper bound on the absolute speed of constructs
(excluding "warp" drive) that is set to 30 000 KPH (8 333 MPS). This module
provides utilities for computing some physical quantities taking this
scaling into account.
]]--

function Kinematics()
    local Kinematic = {} -- just a namespace

    local C       = 30000000/3600
    local C2      = C*C
    local ITERATIONS = 100 -- iterations over engine "warm-up" period

    local function lorentz(v) return 1/math.sqrt(1 - v*v/C2) end

    --
    -- computeAccelerationTime - "relativistic" version of t = (vf - vi)/a
    -- initial      [in]: initial (positive) speed in meters per second.
    -- acceleration [in]: constant acceleration until 'finalSpeed' is reached.
    -- final        [in]: the speed at the end of the time interval.
    -- return: the time in seconds spent in traversing the distance
    --
    function Kinematic.computeAccelerationTime(initial, acceleration, final)
        -- The low speed limit of following is: t=(vf-vi)/a (from: vf=vi+at)
        local k1 = C*math.asin(initial/C)
        return (C * math.asin(final/C) - k1)/acceleration
    end

    --
    -- computeDistanceAndTime - Return distance & time needed to reach final speed.
    -- initial[in]:     Initial speed in meters per second.
    -- final[in]:       Final speed in meters per second.
    -- restMass[in]:    Mass of the construct at rest in Kg.
    -- thrust[in]:      Engine's maximum thrust in Newtons.
    -- t50[in]:         (default: 0) Time interval to reach 50% thrust in seconds.
    -- brakeThrust[in]: (default: 0) Constant thrust term when braking.
    -- return: Distance (in meters), time (in seconds) required for change.
    --
    function Kinematic.computeDistanceAndTime(initial,
            final,
            restMass,
            thrust,
            t50,
            brakeThrust)
        -- This function assumes that the applied thrust is colinear with the
        -- velocity. Furthermore, it does not take into account the influence
        -- of gravity, not just in terms of its impact on velocity, but also
        -- its impact on the orientation of thrust relative to velocity.
        -- These factors will introduce (usually) small errors which grow as
        -- the length of the trip increases.
        t50            = t50 or 0
        brakeThrust    = brakeThrust or 0 -- usually zero when accelerating

        local tau0     = lorentz(initial)
        local speedUp  = initial <= final
        local a0       = thrust * (speedUp and 1 or -1)/restMass
        local b0       = -brakeThrust/restMass
        local totA     = a0+b0

        if speedUp and totA <= 0 or not speedUp and totA >= 0 then
            return -1, -1 -- no solution
        end

        local distanceToMax, timeToMax = 0, 0

        -- If, the T50 time is set, then assume engine is at zero thrust and will
        -- reach full thrust in 2*T50 seconds. Thrust curve is given by:
        -- Thrust: F(z)=(a0*(1+sin(z))+2*b0)/2 where z=pi*(t/t50 - 1)/2
        -- Acceleration is given by F(z)/m(z) where m(z) = m/sqrt(1-v^2/c^2)
        -- or v(z)' = (a0*(1+sin(z))+2*b0)*sqrt(1-v(z)^2/c^2)/2

        if a0 ~= 0 and t50 > 0 then
            -- Closed form solution for velocity exists:
            -- v(t) = -c*tan(w)/sqrt(tan(w)^2+1) => w = -asin(v/c)
            -- w=(pi*t*(a0/2+b0)-a0*t50*sin(pi*t/2/t50)+*pi*c*k1)/pi/c
            -- @ t=0, v(0) = vi
            -- pi*c*k1/pi/c = -asin(vi/c)
            -- k1 = asin(vi/c)
            local k1  = math.asin(initial/C)

            local c1  = math.pi*(a0/2+b0)
            local c2  = a0*t50
            local c3  = C*math.pi

            local v = function(t)
                local w  = (c1*t - c2*math.sin(math.pi*t/2/t50) + c3*k1)/c3
                local tan = math.tan(w)
                return C*tan/math.sqrt(tan*tan+1)
            end

            local speedchk = speedUp and function(s) return s >= final end or
            function(s) return s <= final end
            timeToMax  = 2*t50

            if speedchk(v(timeToMax)) then
                local lasttime = 0

                while math.abs(timeToMax - lasttime) > 0.5 do
                    local t = (timeToMax + lasttime)/2
                    if speedchk(v(t)) then
                        timeToMax = t 
                    else
                        lasttime = t
                    end
                end
            end

            -- There is no closed form solution for distance in this case.
            -- Numerically integrate for time t=0 to t=2*T50 (or less)
            local lastv = initial
            local tinc  = timeToMax/ITERATIONS

            for step = 1, ITERATIONS do
                local speed = v(step*tinc)
                distanceToMax = distanceToMax + (speed+lastv)*tinc/2
                lastv = speed
            end

            if timeToMax < 2*t50 then
                return distanceToMax, timeToMax
            end
            initial = lastv
        end
        -- At full thrust, acceleration only depends on the Lorentz factor:
        -- v(t)' = (F/m(v)) = a*sqrt(1-v(t)^2/c^2) where a = a0+b0
        -- -> v = c*sin((at+k1)/c)
        -- @ t=0, v=vi: k1 = c*asin(vi/c)
        -- -> t = (c*asin(v/c) - k1)/a
        -- x(t)' = c*sin((at+k1)/c)
        -- x = k2 - c^2 cos((at+k1)/c)/a
        -- @ t=0, x=0: k2 = c^2 * cos(k1/c)/a
        local k1       = C*math.asin(initial/C)
        local time     = (C * math.asin(final/C) - k1)/totA

        local k2       = C2 *math.cos(k1/C)/totA
        local distance = k2 - C2 * math.cos((totA*time + k1)/C)/totA

        return distance+distanceToMax, time+timeToMax
    end

    --
    -- computeTravelTime - "relativistic" version of t=(sqrt(2ad+v^2)-v)/a
    -- initialSpeed [in]: initial (positive) speed in meters per second
    -- acceleration [in]: constant acceleration until 'distance' is traversed
    -- distance [in]: the distance traveled in meters
    -- return: the time in seconds spent in traversing the distance
    --
    function Kinematic.computeTravelTime(initial, acceleration, distance)
        -- The low speed limit of following is: t=(sqrt(2ad+v^2)-v)/a
        -- (from: d=vt+at^2/2)
        if distance == 0 then return 0 end

        if acceleration > 0 then
            local k1       = C*math.asin(initial/C)
            local k2       = C2*math.cos(k1/C)/acceleration
            return (C*math.acos(acceleration*(k2 - distance)/C2) - k1)/acceleration
        end
        assert(initial > 0, 'Acceleration and initial speed are both zero.')
        return distance/initial
    end

    function Kinematic.lorentz(v) return lorentz(v) end

    return Kinematic
end    


--[[ 
Provide coordinate transforms and access to kinematic related parameters
Author: JayleBreak

Usage (unit.start):
PlanetaryReference = require('planetref')
galaxyReference = PlanetaryReference(referenceTableSource)
helios = galaxyReference[0] -- PlanetaryReference.PlanetarySystem instance
alioth = helios[2]          -- PlanetaryReference.BodyParameters instance

Methods:
PlanetaryReference:getPlanetarySystem - based on planetary system ID.
PlanetaryReference.isMapPosition - 'true' if an instance of 'MapPosition'
PlanetaryReference.createBodyParameters - for entry into reference table
PlanetaryReference.BodyParameters - a class containing a body's information.
PlanetaryReference.MapPosition - a class for map coordinates
PlanetaryReference.PlanetarySystem - a container for planetary system info.

PlanetarySystem:castIntersections - from a position in a given direction.
PlanetarySystem:closestBody - to the specified coordinates.
PlanetarySystem:convertToBodyIdAndWorldCoordinates - from map coordinates.
PlanetarySystem:getBodyParameters - from reference table.
PlanetarySystem:getPlanetarySystemId - for the instance.

BodyParameters:convertToWorldCoordinates - from map coordinates
BodyParameters:convertToMapPosition - from world coordinates
BodyParameters:getAltitude - of world coordinates
BodyParameters:getDistance - from center to world coordinates
BodyParameters:getGravity - at a given position in world coordinates.

Description
An instance of the 'PlanetaryReference' "class" can contain transform and
kinematic reference information for all planetary systems in DualUniverse.
Each planetary system is identified by a numeric identifier. Currently,
the only planetary system, Helios, has the identifier: zero. This "class"
supports the indexing ('[]') operation which is equivalent to the
use of the 'getPlanetarySystem' method. It also supports the 'pairs()'
method for iterating over planetary systems.

An instance of the 'PlanetarySystem' "class" contains all reference
information for a specific system. It supports the indexing ('[]') and
'pairs()' functions which allows iteration over each "body" in the
system where the key is the numeric body ID. It also supports the
'tostring()' method.

An instance of the 'BodyParameters' "class" contains all reference
information for a single celestial "body" (a moon or planet). It supports
the 'tostring()' method, and contains the data members:
planetarySystemId - numeric planetary system ID
bodyId            - numeric body ID
radius            - radius of the body in meters (zero altitude)
center            - world coordinates of the body's center position
GM                - the gravitation parameter (g = GM/radius^2)
Note that the user is allowed to add custom fields (e.g. body name), but
should insure that complex table values have the '__tostring' metamethod
implemented.

Transform and Kinematics:
"World" coordinates is a cartesian coordinate system with an origin at an
arbitrary fixed point in a planetary system and with distances measured in
meters. The coordinates are expressible either as a simple table of 3 values
or an instance of the 'vec3' class.  In either case, the planetary system
identity is implicit.

"Map" coordinates is a geographic coordinate system with an origin at the
center of an identified (by a numeric value) celestial body which is a
member of an identified (also a numeric value) planetary system. Note that
the convention that latitude, longitude, and altitude values will be the
position's x, y, and z world coordinates in the special case of body ID 0.

The kinematic parameters in the reference data permit calculations of the
gravitational attraction of the celestial body on other objects.

Reference Data:
This is an example of reference data with a single entry assigned to
planetary system ID 0, and body ID 2 ('Alioth'):
referenceTable = {
[0] = { [2] = { planetarySystemId = 0,
bodyId = 2,
radius = 126068,
center = vec3({x=-8, y=-8, z=-126303}),
GM = 1.572199+11 } -- as in F=-GMm/r^2
}
}
ref=PlanetaryReference(referenceTable)

Collecting Reference Data:
A combination of information from the "Map" screen in the DU user interface,
and values reported by the DU Lua API can be the source of the reference
table's data (planetarySystemId, bodyId, and surfaceArea is from the user
interface):
referenceTable = {}
referenceTable[planetarySystemId][bodyId] =
PlanetaryReference.createBodyParameters(planetarySystemId,
bodyId,
surfaceArea,
core.getConstructWorldPos(),
core.getWorldVertical(),
core.getAltitude(),
core.g())


Adapting Data Sources:
Other sources of data can be adapted or converted. An example of adapting a
table, defined in the file: 'planets.lua', containing information on a single
planetary system and using celestial body name as the key follows (note that
a 'name' field is added to the BodyParameters instance transparently after
construction, and the '__pairs' meta function is required to support the
'closestBody' and '__tostring' methods):
ref=PlanetaryReference(
{[0] = setmetatable(require('planets'),
{ __index = function(bodies, bodyId)
for _,v in pairs(bodies) do
if v and v.bodyId == bodyId then return v end
end
return nil
end,
__pairs = function(bodies)
return function(t, k)
local nk, nv = next(t, k)
if nv then
local GM = nv.gravity * nv.radius^2
local bp = BodyParameters(0,
nv.id,
nv.radius,
nv.pos,
GM)
bp.name = nk
return nk, bp
end
return nk, nv
end, bodies, nil
end })
})

Converting Data Sources:
An instance of 'PlanetaryReference' that has been adapted to a data source
can be used to convert that source to simple table. For example,
using the adapted instance shown above:
load('convertedData=' .. tostring(ref))()
newRef=PlanetaryReference(convertedData)

Also See: kepler.lua
]]--

--[[                    START OF LOCAL IMPLEMENTATION DETAILS             ]]--

-- Type checks

function PlanetRef() 
    local function isNumber(n)  return type(n)           == 'number' end
    local function isSNumber(n) return type(tonumber(n)) == 'number' end
    local function isTable(t)   return type(t)           == 'table'  end
    local function isString(s)  return type(s)           == 'string' end
    local function isVector(v)  return isTable(v)
        and isNumber(v.x and v.y and v.z) end

    local function isMapPosition(m) return isTable(m) and isNumber(m.latitude  and
            m.longitude and
            m.altitude  and
            m.bodyId    and
            m.systemId) end

    -- Constants

    local deg2rad    = math.pi/180
    local rad2deg    = 180/math.pi
    local epsilon    = 1e-10
    local num        = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'
    local posPattern = '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' ..
    num ..  ',' .. num .. '}'

    -- Utilities

    local utils  = require('cpml.utils')
    local vec3   = require('cpml.vec3')
    local clamp  = utils.clamp

    local function float_eq(a,b)
        if a == 0 then return math.abs(b) < 1e-09 end
        if b == 0 then return math.abs(a) < 1e-09 end
        return math.abs(a - b) < math.max(math.abs(a),math.abs(b))*epsilon
    end

    local function formatNumber(n)
        local result = string.gsub(
            string.reverse(string.format('%.4f',n)),
            '^0*%.?','')
        return result == '' and '0' or string.reverse(result)
    end

    local function formatValue(obj)
        if isVector(obj) then
            return string.format('{x=%.3f,y=%.3f,z=%.3f}', obj.x, obj.y, obj.z)
        end

        if isTable(obj) and not getmetatable(obj) then
            local list = {}
            local nxt  = next(obj)

            if type(nxt) == 'nil' or nxt == 1 then -- assume this is an array
                list = obj
            else
                for k,v in pairs(obj) do
                    local value = formatValue(v)
                    if type(k) == 'number' then
                        table.insert(list, string.format('[%s]=%s', k, value))
                    else
                        table.insert(list, string.format('%s=%s',   k, value))
                    end
                end
            end
            return string.format('{%s}', table.concat(list, ','))
        end

        if isString(obj) then
            return string.format("'%s'", obj:gsub("'",[[\']]))
        end
        return tostring(obj)
    end


    -- CLASSES

    -- BodyParameters: Attributes of planetary bodies (planets and moons)

    local BodyParameters = {}
    BodyParameters.__index = BodyParameters
    BodyParameters.__tostring =
    function(obj, indent)
        local sep = indent or ''
        local keys = {}
        for k in pairs(obj) do table.insert(keys, k) end
        table.sort(keys)
        local list = {}
        for _, k in ipairs(keys) do
            local value = formatValue(obj[k])
            if type(k) == 'number' then
                table.insert(list, string.format('[%s]=%s', k, value))
            else
                table.insert(list, string.format('%s=%s', k, value))
            end
        end
        if indent then
            return string.format('%s%s',
                indent,
                table.concat(list, ',\n' .. indent))
        end
        return string.format('{%s}', table.concat(list, ','))
    end
    BodyParameters.__eq = function(lhs, rhs)
        return lhs.planetarySystemId == rhs.planetarySystemId and
        lhs.bodyId            == rhs.bodyId            and
        float_eq(lhs.radius, rhs.radius)               and
        float_eq(lhs.center.x, rhs.center.x)           and
        float_eq(lhs.center.y, rhs.center.y)           and
        float_eq(lhs.center.z, rhs.center.z)           and
        float_eq(lhs.GM, rhs.GM)
    end

    local function mkBodyParameters(systemId, bodyId, radius, worldCoordinates, GM)
        -- 'worldCoordinates' can be either table or vec3
        assert(isSNumber(systemId),
            'Argument 1 (planetarySystemId) must be a number:' .. type(systemId))
        assert(isSNumber(bodyId),
            'Argument 2 (bodyId) must be a number:' .. type(bodyId))
        assert(isSNumber(radius),
            'Argument 3 (radius) must be a number:' .. type(radius))
        assert(isTable(worldCoordinates),
            'Argument 4 (worldCoordinates) must be a array or vec3.' ..
            type(worldCoordinates))
        assert(isSNumber(GM),
            'Argument 5 (GM) must be a number:' .. type(GM))
        return setmetatable({planetarySystemId = tonumber(systemId),
                bodyId            = tonumber(bodyId),
                radius            = tonumber(radius),
                center            = vec3(worldCoordinates),
                GM                = tonumber(GM) }, BodyParameters)
    end

    -- MapPosition: Geographical coordinates of a point on a planetary body.

    local MapPosition = {}
    MapPosition.__index = MapPosition
    MapPosition.__tostring = function(p)
        return string.format('::pos{%d,%d,%s,%s,%s}',
            p.systemId,
            p.bodyId,
            formatNumber(p.latitude*rad2deg),
            formatNumber(p.longitude*rad2deg),
            formatNumber(p.altitude))
    end
    MapPosition.__eq       = function(lhs, rhs)
        return lhs.bodyId   == rhs.bodyId              and
        lhs.systemId == rhs.systemId            and
        float_eq(lhs.latitude,   rhs.latitude)  and
        float_eq(lhs.altitude,   rhs.altitude)  and
        (float_eq(lhs.longitude, rhs.longitude) or
            float_eq(lhs.latitude, math.pi/2)      or
            float_eq(lhs.latitude, -math.pi/2))
    end

    -- latitude and longitude are in degrees while altitude is in meters

    local function mkMapPosition(overload, bodyId, latitude, longitude, altitude)
        local systemId = overload -- Id or '::pos{...}' string

        if isString(overload) and not longitude and not altitude and
            not bodyId    and not latitude then
            systemId, bodyId, latitude, longitude, altitude =
            string.match(overload, posPattern)
            assert(systemId, 'Argument 1 (position string) is malformed.')
        else
            assert(isSNumber(systemId),
                'Argument 1 (systemId) must be a number:' .. type(systemId))
            assert(isSNumber(bodyId),
                'Argument 2 (bodyId) must be a number:' .. type(bodyId))
            assert(isSNumber(latitude),
                'Argument 3 (latitude) must be in degrees:' .. type(latitude))
            assert(isSNumber(longitude),
                'Argument 4 (longitude) must be in degrees:' .. type(longitude))
            assert(isSNumber(altitude),
                'Argument 5 (altitude) must be in meters:' .. type(altitude))
        end
        systemId  = tonumber(systemId)
        bodyId    = tonumber(bodyId)
        latitude  = tonumber(latitude)
        longitude = tonumber(longitude)
        altitude  = tonumber(altitude)

        if bodyId == 0 then -- this is a hack to represent points in space
            return setmetatable({latitude  = latitude,
                    longitude = longitude,
                    altitude  = altitude,
                    bodyId    = bodyId,
                    systemId  = systemId}, MapPosition)
        end
        return setmetatable({latitude  = deg2rad*clamp(latitude, -90, 90),
                longitude = deg2rad*(longitude % 360),
                altitude  = altitude,
                bodyId    = bodyId,
                systemId  = systemId}, MapPosition)
    end

    -- PlanetarySystem - map body IDs to BodyParameters

    local PlanetarySystem = {}
    PlanetarySystem.__index = PlanetarySystem

    PlanetarySystem.__tostring =
    function (obj, indent)
        local sep = indent and (indent .. '  ' )
        local bdylist = {}
        local keys = {}
        for k in pairs(obj) do table.insert(keys, k) end
        table.sort(keys)
        for _, bi in ipairs(keys) do
            bdy = obj[bi]
            local bdys = BodyParameters.__tostring(bdy, sep)
            if indent then
                table.insert(bdylist,
                    string.format('[%s]={\n%s\n%s}',
                        bi, bdys, indent))
            else
                table.insert(bdylist, string.format('  [%s]=%s', bi, bdys))
            end
        end
        if indent then
            return string.format('\n%s%s%s',
                indent,
                table.concat(bdylist, ',\n' .. indent),
                indent)
        end
        return string.format('{\n%s\n}', table.concat(bdylist, ',\n'))
    end

    local function mkPlanetarySystem(referenceTable)
        local atlas = {}
        local pid
        for _, v in pairs(referenceTable) do
            local id = v.planetarySystemId

            if type(id) ~= 'number' then
                error('Invalid planetary system ID: ' .. tostring(id))
            elseif pid and id ~= pid then
                error('Mismatch planetary system IDs: ' .. id .. ' and '
                    .. pid)
            end
            local bid = v.bodyId
            if type(bid) ~= 'number' then
                error('Invalid body ID: ' .. tostring(bid))
            elseif atlas[bid] then
                error('Duplicate body ID: ' .. tostring(bid))
            end
            setmetatable(v.center, getmetatable(vec3.unit_x))
            atlas[bid] = setmetatable(v, BodyParameters)
            pid = id
        end
        return setmetatable(atlas, PlanetarySystem)
    end

    -- PlanetaryReference - map planetary system ID to PlanetarySystem

    PlanetaryReference = {}

    local function mkPlanetaryReference(referenceTable)
        return setmetatable({ galaxyAtlas = referenceTable or {} },
            PlanetaryReference)
    end

    PlanetaryReference.__index        = 
    function(t,i)
        if type(i) == 'number' then
            local system = t.galaxyAtlas[i]
            return mkPlanetarySystem(system)
        end
        return rawget(PlanetaryReference, i)
    end
    PlanetaryReference.__pairs        =
    function(obj)
        return  function(t, k)
            local nk, nv = next(t, k)
            return nk, nv and mkPlanetarySystem(nv)
        end, obj.galaxyAtlas, nil
    end
    PlanetaryReference.__tostring     =
    function (obj)
        local pslist = {}
        for _,ps in pairs(obj or {}) do
            local psi = ps:getPlanetarySystemId()
            local pss = PlanetarySystem.__tostring(ps, '    ')
            table.insert(pslist,
                string.format('  [%s]={%s\n  }', psi, pss))
        end
        return string.format('{\n%s\n}\n', table.concat(pslist,',\n'))
    end


    --[[                       START OF PUBLIC INTERFACE                       ]]--


    -- PlanetaryReference CLASS METHODS:

    --
    -- BodyParameters - create an instance of BodyParameters class
    -- planetarySystemId  [in]: the body's planetary system ID.
    -- bodyId             [in]: the body's ID.
    -- radius             [in]: the radius in meters of the planetary body.
    -- bodyCenter         [in]: the world coordinates of the center (vec3 or table).
    -- GM                 [in]: the body's standard gravitational parameter.
    -- return: an instance of BodyParameters class.
    --
    PlanetaryReference.BodyParameters = mkBodyParameters

    --
    -- MapPosition - create an instance of the MapPosition class
    -- overload [in]: either a planetary system ID or a position string ('::pos...')
    -- bodyId [in]:   (ignored if overload is a position string) the body's ID.
    -- latitude [in]: (ignored if overload is a position string) the latitude.
    -- longitude [in]:(ignored if overload is a position string) the longitude.
    -- altitude [in]: (ignored if overload is a position string) the altitude.
    -- return: the class instance
    --
    PlanetaryReference.MapPosition    = mkMapPosition

    --
    -- PlanetarySystem - create an instance of PlanetarySystem class
    -- referenceData [in]: a table (indexed by bodyId) of body reference info.
    -- return: the class instance
    --
    PlanetaryReference.PlanetarySystem = mkPlanetarySystem

    --
    -- createBodyParameters - create an instance of BodyParameters class
    -- planetarySystemId  [in]: the body's planetary system ID.
    -- bodyId             [in]: the body's ID.
    -- surfaceArea        [in]: the body's surface area in square meters.
    -- aPosition          [in]: world coordinates of a position near the body.
    -- verticalAtPosition [in]: a vector pointing towards the body center.
    -- altitudeAtPosition [in]: the altitude in meters at the position.
    -- gravityAtPosition  [in]: the magnitude of the gravitational acceleration.
    -- return: an instance of BodyParameters class.
    --
    function PlanetaryReference.createBodyParameters(planetarySystemId,
            bodyId,
            surfaceArea,
            aPosition,
            verticalAtPosition,
            altitudeAtPosition,
            gravityAtPosition)
        assert(isSNumber(planetarySystemId),
            'Argument 1 (planetarySystemId) must be a number:' ..
            type(planetarySystemId))
        assert(isSNumber(bodyId),
            'Argument 2 (bodyId) must be a number:' .. type(bodyId))
        assert(isSNumber(surfaceArea),
            'Argument 3 (surfaceArea) must be a number:' .. type(surfaceArea))
        assert(isTable(aPosition),
            'Argument 4 (aPosition) must be an array or vec3:' ..
            type(aPosition))
        assert(isTable(verticalAtPosition),
            'Argument 5 (verticalAtPosition) must be an array or vec3:' ..
            type(verticalAtPosition))
        assert(isSNumber(altitudeAtPosition),
            'Argument 6 (altitude) must be in meters:' ..
            type(altitudeAtPosition))
        assert(isSNumber(gravityAtPosition),
            'Argument 7 (gravityAtPosition) must be number:' ..
            type(gravityAtPosition))
        local radius   = math.sqrt(surfaceArea/4/math.pi)
        local distance = radius + altitudeAtPosition
        local center   = vec3(aPosition) + distance*vec3(verticalAtPosition)
        local GM       = gravityAtPosition * distance * distance
        return mkBodyParameters(planetarySystemId, bodyId, radius, center, GM)
    end

    --
    -- isMapPosition - check for the presence of the 'MapPosition' fields
    -- valueToTest [in]: the value to be checked
    -- return: 'true' if all required fields are present in the input value
    --
    PlanetaryReference.isMapPosition  = isMapPosition

    -- PlanetaryReference INSTANCE METHODS:

    --
    -- getPlanetarySystem - get the planetary system using ID or MapPosition as key
    -- overload [in]: either the planetary system ID or a MapPosition that has it.
    -- return: instance of 'PlanetarySystem' class or nil on error
    --
    function PlanetaryReference:getPlanetarySystem(overload)
        if self.galaxyAtlas then
            local planetarySystemId = overload

            if isMapPosition(overload) then
                planetarySystemId = overload.systemId
            end

            if type(planetarySystemId) == 'number' then
                local system = self.galaxyAtlas[i]
                if system then
                    if getmetatable(nv) ~= PlanetarySystem then
                        system = mkPlanetarySystem(system)
                    end
                    return system
                end
            end
        end
        return nil
    end

    -- PlanetarySystem INSTANCE METHODS:

    --
    -- castIntersections - Find the closest body that intersects a "ray cast".
    -- origin [in]: the origin of the "ray cast" in world coordinates
    -- direction [in]: the direction of the "ray cast" as a 'vec3' instance.
    -- sizeCalculator [in]: (default: returns 1.05*radius) Returns size given body.
    -- bodyIds[in]: (default: all IDs in system) check only the given IDs.
    -- return: The closest body that blocks the cast or 'nil' if none.
    --
    function PlanetarySystem:castIntersections(origin,
            direction,
            sizeCalculator,
            bodyIds)
        local sizeCalculator = sizeCalculator or 
        function (body) return 1.05*body.radius end
        local candidates = {}

        if bodyIds then
            for _,i in ipairs(bodyIds) do candidates[i] = self[i] end
        else
            bodyIds = {}
            for k,body in pairs(self) do
                table.insert(bodyIds, k)
                candidates[k] = body
            end
        end
        local function compare(b1,b2)
            local v1 = candidates[b1].center - origin
            local v2 = candidates[b2].center - origin
            return v1:len() < v2:len()
        end
        table.sort(bodyIds, compare)
        local dir = direction:normalize()

        for i, id in ipairs(bodyIds) do
            local body   = candidates[id]
            local c_oV3  = body.center - origin
            local radius = sizeCalculator(body)
            local dot    = c_oV3:dot(dir)
            local desc   = dot^2 - (c_oV3:len2() - radius^2)

            if desc >= 0 then
                local root     = math.sqrt(desc)
                local farSide  = dot + root
                local nearSide = dot - root
                if nearSide > 0 then
                    return body, farSide, nearSide
                elseif farSide > 0 then
                    return body, farSide, nil
                end
            end
        end
        return nil, nil, nil
    end

    --
    -- closestBody - find the closest body to a given set of world coordinates
    -- coordinates       [in]: the world coordinates of position in space
    -- return: an instance of the BodyParameters object closest to 'coordinates'
    --
    function PlanetarySystem:closestBody(coordinates)
        assert(type(coordinates) == 'table', 'Invalid coordinates.')
        local minDistance2, body
        local coord = vec3(coordinates)

        for _,params in pairs(self) do
            local distance2 = (params.center - coord):len2()
            if not body or distance2 < minDistance2 then
                body         = params
                minDistance2 = distance2
            end
        end
        return body
    end

    --
    -- convertToBodyIdAndWorldCoordinates - map to body Id and world coordinates
    -- overload [in]: an instance of MapPosition or a position string ('::pos...)
    -- return: a vec3 instance containing the world coordinates or 'nil' on error.
    --
    function PlanetarySystem:convertToBodyIdAndWorldCoordinates(overload)
        local mapPosition = overload
        if isString(overload) then
            mapPosition = mkMapPosition(overload)
        end

        if mapPosition.bodyId == 0 then
            return 0, vec3(mapPosition.latitude,
                mapPosition.longitude,
                mapPosition.altitude)
        end
        local params = self:getBodyParameters(mapPosition)

        if params then
            return mapPosition.bodyId,
            params:convertToWorldCoordinates(mapPosition)
        end
    end

    --
    -- getBodyParameters - get or create an instance of BodyParameters class
    -- overload [in]: either an instance of MapPosition or a body's ID.
    -- return: a BodyParameters instance or 'nil' if body ID is not found.
    --
    function PlanetarySystem:getBodyParameters(overload)
        local bodyId = overload

        if isMapPosition(overload) then
            bodyId = overload.bodyId
        end
        assert(isSNumber(bodyId),
            'Argument 1 (bodyId) must be a number:' .. type(bodyId))

        return self[bodyId]
    end

    --
    -- getPlanetarySystemId - get the planetary system ID for this instance
    -- return: the planetary system ID or nil if no planets are in the system.
    --
    function PlanetarySystem:getPlanetarySystemId()
        local k, v = next(self)
        return v and v.planetarySystemId
    end

    -- BodyParameters INSTANCE METHODS:

    --
    -- convertToMapPosition - create an instance of MapPosition from coordinates
    -- worldCoordinates [in]: the world coordinates of the map position.
    -- return: an instance of MapPosition class
    --
    function BodyParameters:convertToMapPosition(worldCoordinates)
        assert(isTable(worldCoordinates),
            'Argument 1 (worldCoordinates) must be an array or vec3:' ..
            type(worldCoordinates))
        local worldVec  = vec3(worldCoordinates) 

        if self.bodyId == 0 then
            return setmetatable({latitude  = worldVec.x,
                    longitude = worldVec.y,
                    altitude  = worldVec.z,
                    bodyId    = 0,
                    systemId  = self.planetarySystemId}, MapPosition)
        end
        local coords    = worldVec - self.center
        local distance  = coords:len()
        local altitude  = distance - self.radius
        local latitude  = 0
        local longitude = 0

        if not float_eq(distance, 0) then
            local phi = math.atan(coords.y, coords.x)
            longitude = phi >= 0 and phi or (2*math.pi + phi)
            latitude  = math.pi/2 - math.acos(coords.z/distance)
        end
        return setmetatable({latitude  = latitude,
                longitude = longitude,
                altitude  = altitude,
                bodyId    = self.bodyId,
                systemId  = self.planetarySystemId}, MapPosition)
    end

    --
    -- convertToWorldCoordinates - convert a map position to world coordinates
    -- overload [in]: an instance of MapPosition or a position string ('::pos...')
    --
    function BodyParameters:convertToWorldCoordinates(overload)
        local mapPosition = isString(overload) and
        mkMapPosition(overload) or overload
        if mapPosition.bodyId == 0 then -- support deep space map position
            return vec3(mapPosition.latitude,
                mapPosition.longitude,
                mapPosition.altitude)
        end
        assert(isMapPosition(mapPosition),
            'Argument 1 (mapPosition) is not an instance of "MapPosition".')
        assert(mapPosition.systemId == self.planetarySystemId,
            'Argument 1 (mapPosition) has a different planetary system ID.')
        assert(mapPosition.bodyId == self.bodyId,
            'Argument 1 (mapPosition) has a different planetary body ID.')
        local xproj = math.cos(mapPosition.latitude)
        return self.center + (self.radius + mapPosition.altitude) *
        vec3(xproj*math.cos(mapPosition.longitude),
            xproj*math.sin(mapPosition.longitude),
            math.sin(mapPosition.latitude))
    end

    --
    -- getAltitude - calculate the altitude of a point given in world coordinates.
    -- worldCoordinates [in]: the world coordinates of the point.
    -- return: the altitude in meters
    --
    function BodyParameters:getAltitude(worldCoordinates)
        return (vec3(worldCoordinates) - self.center):len() - self.radius
    end

    --
    -- getDistance - calculate the distance to a point given in world coordinates.
    -- worldCoordinates [in]: the world coordinates of the point.
    -- return: the distance in meters
    --
    function BodyParameters:getDistance(worldCoordinates)
        return (vec3(worldCoordinates) - self.center):len()
    end

    --
    -- getGravity - calculate the gravity vector induced by the body.
    -- worldCoordinates [in]: the world coordinates of the point.
    -- return: the gravity vector in meter/seconds^2
    --
    function BodyParameters:getGravity(worldCoordinates)
        local radial = self.center - vec3(worldCoordinates) -- directed towards body
        local len2   = radial:len2()
        return (self.GM/len2) * radial/math.sqrt(len2)
    end

    -- end of module

    return setmetatable(PlanetaryReference,
        { __call = function(_,...)
                return mkPlanetaryReference(...)
            end })
end





MaxGameVelocity = 8333.05
function getSpeedDisplayString(speed) 
    return math.floor(round(speed*3.6,0)+0.5) .. " km/h" 
end

function getDistanceDisplayString(distance)
    local su = distance > 100000
    local result = ""
    if su then
        -- Convert to SU
        result = round(distance/1000/200,1) .. " SU"
    elseif distance < 1000 then
        result = round(distance,1) .. " M"
    else
        -- Convert to KM
        result = round(distance/1000,1) .. " KM"
    end
    return result
end

function FormatTimeString(seconds)
    local hours = math.floor(seconds/3600)
    local minutes = math.floor(seconds/60%60)
    local seconds = math.floor(seconds%60)
    if seconds < 0 or hours < 0 or minutes < 0 then
        return "0s"
    end
    if hours > 0 then 
        return hours .. "h " .. minutes .. "m " .. seconds .. "s"
    elseif minutes > 0 then
        return minutes .. "m " ..seconds.."s"
    else
        return seconds.."s"
    end
end

function orbitinterface()
    newContent = {}
    PlanetaryReference = PlanetRef()
    galaxyReference = PlanetaryReference(Atlas())
    Kinematic = Kinematics()
    Kep = Keplers()

    sys = galaxyReference[0]
    planet = sys:closestBody(core.getConstructWorldPos())
    kepPlanet = Kep(planet)
    orbit = kepPlanet:orbitalParameters(core.getConstructWorldPos(), velocity)

    if orbit ~= nil and unit.getAtmosphereDensity() < 0.2 and planet ~= nil and orbit.period ~= nil and
        (orbit.periapsis ~= nil or orbit.apoapsis ~= nil) then
        -- If orbits are up, let's try drawing a mockup
        local orbitMapX = 75
        local orbitMapY = 0
        local orbitMapSize = 250 -- Always square
        local pad = 4
        orbitMapY = orbitMapY + pad                        
        local orbitInfoYOffset = 15
        local x = orbitMapX + orbitMapSize + orbitMapX/2 + pad
        local y = orbitMapY + orbitMapSize/2 + 5 + pad
        local rx, ry, scale, xOffset
        rx = orbitMapSize/4
        xOffset = 0

        newContent[#newContent + 1] = [[<g class="pbright txtorb txtmid">]]
        -- Draw a darkened box around it to keep it visible
        newContent[#newContent + 1] = string.format('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />', orbitMapSize+orbitMapX*2, orbitMapSize+orbitMapY, pad, pad)
        if orbit.periapsis ~= nil and orbit.apoapsis ~= nil then
            scale = (orbit.apoapsis.altitude + orbit.periapsis.altitude + planet.radius*2)/(rx*2)
            ry = (planet.radius + orbit.periapsis.altitude + (orbit.apoapsis.altitude - orbit.periapsis.altitude)/2)/scale * (1-orbit.eccentricity)
            xOffset = rx - orbit.periapsis.altitude/scale - planet.radius/scale
            local ellipseColor = ""
            if orbit.periapsis.altitude <= 0 then
                ellipseColor = 'redout'
            end
            newContent[#newContent + 1] = string.format([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]], ellipseColor, orbitMapX + orbitMapSize/2 + xOffset + pad, orbitMapY + orbitMapSize/2 + pad, rx, ry)
            newContent[#newContent + 1] = string.format('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />', orbitMapX + orbitMapSize/2 + pad, orbitMapY + orbitMapSize/2 + pad, planet.radius/scale) 
        end
        if orbit.apoapsis ~= nil and orbit.apoapsis.speed < MaxGameVelocity and orbit.apoapsis.speed > 0 then
            newContent[#newContent + 1] = string.format([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],x - 35, y-5, orbitMapX + orbitMapSize/2 + rx + xOffset, y-5)
            newContent[#newContent + 1] = string.format([[<text x="%f" y="%f">Apoapsis</text>]], x, y)
            y  = y + orbitInfoYOffset
            newContent[#newContent + 1] = string.format([[<text x="%f" y="%f">%s</text>]], x, y,  getDistanceDisplayString(orbit.apoapsis.altitude))
            y  = y + orbitInfoYOffset          
            newContent[#newContent + 1] = string.format([[<text x="%f" y="%f">%s</text>]], x, y, FormatTimeString(orbit.timeToApoapsis))
            y  = y + orbitInfoYOffset
            newContent[#newContent + 1] = string.format([[<text x="%f" y="%f">%s</text>]], x, y, getSpeedDisplayString(orbit.apoapsis.speed))
        end
        y = orbitMapY + orbitMapSize/2 + 5 + pad
        x = orbitMapX - orbitMapX/2+10 + pad
        if orbit.periapsis ~= nil and orbit.periapsis.speed < MaxGameVelocity and orbit.periapsis.speed > 0 then
            newContent[#newContent + 1] = string.format([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]], x + 35, y-5, orbitMapX + orbitMapSize/2 - rx + xOffset, y-5)
            newContent[#newContent + 1] = string.format([[<text x="%f" y="%f">Periapsis</text>]], x, y)
            y  = y + orbitInfoYOffset
            newContent[#newContent + 1] = string.format([[<text x="%f" y="%f">%s</text>]], x, y,  getDistanceDisplayString(orbit.periapsis.altitude))
            y  = y + orbitInfoYOffset
            newContent[#newContent + 1] = string.format([[<text x="%f" y="%f">%s</text>]], x, y, FormatTimeString(orbit.timeToPeriapsis))
            y  = y + orbitInfoYOffset
            newContent[#newContent + 1] = string.format([[<text x="%f" y="%f">%s</text>]], x, y, getSpeedDisplayString(orbit.periapsis.speed))
        end
        -- Add a label for the planet
        newContent[#newContent + 1] = string.format([[<text class="txtorbbig" x="%f" y="%d">%s</text>]], orbitMapX + orbitMapSize/2 + pad, 20 + pad, planet.name)
        if orbit.period ~= nil and orbit.periapsis ~= nil and orbit.apoapsis ~= nil then
            local apsisRatio = (orbit.timeToApoapsis/orbit.period) * 2 * math.pi
            -- x = xr * cos(t)
            -- y = yr * sin(t)
            local shipX = rx * math.cos(apsisRatio)
            local shipY = ry * math.sin(apsisRatio)
            newContent[#newContent + 1] = string.format('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />', orbitMapX + orbitMapSize/2 + shipX + xOffset + pad, orbitMapY + orbitMapSize/2 + shipY + pad)
        end
        newContent[#newContent + 1] = [[</g></svg>]]
        -- Once we have all that, we should probably rotate the entire thing so that the ship is always at the bottom so you can see AP and PE move?
    end

    return table.concat(newContent, "")
end
-- Expugnator END: library.start()