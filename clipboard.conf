{"slots":{"0":{"name":"spacefueltank_1","type":{"events":[],"methods":[]}},"1":{"name":"atmofueltank_1","type":{"events":[],"methods":[]}},"2":{"name":"core","type":{"events":[],"methods":[]}},"3":{"name":"telemeter","type":{"events":[],"methods":[]}},"4":{"name":"btnDoor","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"10":{"name":"radar","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-2":{"name":"system","type":{"events":[],"methods":[]}},"-3":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"_autoconf.hideCategoryPanels()\nif antigrav ~= nil then antigrav.hide() end\nif warpdrive ~= nil then warpdrive.hide() end\nif gyro ~= nil then gyro.hide() end\ncore.hide()\nNav.control.switchOffHeadlights()\n","filter":{"args":[],"signature":"stop()","slotKey":"-1"},"key":"0"},{"code":"-- category panel display helpers\n_autoconf = {}\n_autoconf.panels = {}\n_autoconf.panels_size = 0\n_autoconf.displayCategoryPanel = function(elements, size, title, type, widgetPerData)\n    widgetPerData = widgetPerData or false -- default to one widget for all data\n    if size > 0 then\n        local panel = system.createWidgetPanel(title)\n        local widget\n        if not widgetPerData then\n            widget = system.createWidget(panel, type)\n        end\n        for i = 1, size do\n            if widgetPerData then\n                widget = system.createWidget(panel, type)\n            end\n            system.addDataToWidget(elements[i].getDataId(), widget)\n        end\n        _autoconf.panels_size = _autoconf.panels_size + 1\n        _autoconf.panels[_autoconf.panels_size] = panel\n    end\nend\n_autoconf.hideCategoryPanels = function()\n    for i=1,_autoconf.panels_size do\n        system.destroyWidgetPanel(_autoconf.panels[i])\n    end\nend\n-- Proxy array to access auto-plugged slots programmatically\nspacefueltank = {}\nspacefueltank[1] = spacefueltank_1\nspacefueltank_size = 1\n\natmofueltank = {}\natmofueltank[1] = atmofueltank_1\natmofueltank_size = 1\n\nrocketfueltank = {}\nrocketfueltank_size = 0\n\nweapon = {}\nweapon_size = 0\n\nradar = {}\nradar_size = 0\n-- End of auto-generated code\nNav = Navigator.new(system, core, unit)\nNav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})\nNav.axisCommandManager:setTargetGroundAltitude(4)\n\n-- element widgets\n-- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.\n_autoconf.displayCategoryPanel(weapon, weapon_size, \"Weapons\", \"weapon\", true)\ncore.show()\n_autoconf.displayCategoryPanel(radar, radar_size, \"Periscope\", \"periscope\")\nplaceRadar = true\nif atmofueltank_size > 0 then\n    _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, \"Atmo Fuel\", \"fuel_container\")\n    if placeRadar then\n        _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n        placeRadar = false\n    end\nend\nif spacefueltank_size > 0 then\n    _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, \"Space Fuel\", \"fuel_container\")\n    if placeRadar then\n        _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n        placeRadar = false\n    end\nend\n_autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, \"Rocket Fuel\", \"fuel_container\")\nif placeRadar then -- We either have only rockets or no fuel tanks at all, uncommon for usual vessels\n    _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n    placeRadar = false\nend\nif antigrav ~= nil then antigrav.show() end\nif warpdrive ~= nil then warpdrive.show() end\nif gyro ~= nil then gyro.show() end\n\n-- freeze the player in he is remote controlling the construct\nif Nav.control.isRemoteControlled() == 1 then\n    system.freeze(1)\nend\n\n-- landing gear\n-- make sure every gears are synchonized with the first\ngearExtended = (Nav.control.isAnyLandingGearExtended() == 1) -- make sure it's a lua boolean\nif gearExtended then\n    Nav.control.extendLandingGears()\nelse\n    Nav.control.retractLandingGears()\nend\n","filter":{"args":[],"signature":"start()","slotKey":"-1"},"key":"1"},{"code":"-- Darkwinde START: unit.tick(HUD)\n\n\n-- UPDATE GLOBALS START\nvelocity = vec3(core.getVelocity()):len()\nvelocity_kmh = round(velocity * 3.6)\nvelocity_vertical = round(core.getVelocity()[1])\nenvironment = getEnvironmentName()\nenvironmentID = getEnvironmentID()\n-- UPDATE GLOBALS END\n\n\n\nlocal hud_BrakeStatus = ternary(lockBrake, '<div class=\"on\">on</div>', '<div class=\"off\">off</div>')\nlocal hud_Environment = ''\nif environmentID == 3 then -- Spacedock\n    hud_Environment = '<div style=\"color:green; font-weight:bold;\">' .. environment .. '</div>'\n    \n    if not firstStart then\n        setHTMLMessage(hudHTMLMsg, \"You are docked!!!\", \"ok\")\n        firstStart = not firstStart\n    end\nelse -- Atmo & Space\n    hud_Environment = '<div>' .. environment .. '</div>'\n    \n    if firstStart then \n        firstStart = not firstStart\n    end\nend\nlocal hud_Altitude = round(core.getAltitude()) .. 'm'\nlocal hud_TelemeterDistance =  round(telemeter.getDistance()) .. 'm'\nlocal hud_LocalGravity = round(core.g()/gravity, 1) .. 'g'\n\n\n\nlocal brakeDistanceSpeed0 = getBrakeDistance(0) -- km/h\nlocal brakeDistanceSpeed2000 = getBrakeDistance(2000) -- km/h\n\nlocal hud_Speed0 = brakeDistanceSpeed0[\"min\"] .. \"m:\" .. brakeDistanceSpeed0[\"sec\"] .. \"s - \" .. brakeDistanceSpeed0[\"su\"] .. \"su (\" .. brakeDistanceSpeed0[\"km\"] .. \"km)\"\nlocal hud_Speed2000 = brakeDistanceSpeed2000[\"min\"] .. \"m:\" .. brakeDistanceSpeed2000[\"sec\"] .. \"s - \" .. brakeDistanceSpeed2000[\"su\"] .. \"su (\" .. brakeDistanceSpeed2000[\"km\"] .. \"km)\"\n\n\n\n\n\n\nlocal hudHTMLBody =\n[[\n\t<div class=\"zen\">\n          <div class=\"controls-hud\">\n               <div class=\"category\">Status...</div>\n\t\t\t<div class=\"primary control-container\">\n\t\t\t\t<p class=\"primary\">Handbrake:</p>\n\t\t\t\t]] .. hud_BrakeStatus .. [[\n\t\t\t</div>\n\t\t\t<div class=\"primary control-container\">\n\t\t\t\t<p class=\"primary\">Environment:</p>\n\t\t\t\t]] .. hud_Environment .. [[\n\t\t\t</div>\n\n\n\t\t\t<div class=\"spacer\"></div>\n               <div class=\"category\">Telemetric...</div>\n\t\t\t<div class=\"primary control-container\">\n\t\t\t\t<p class=\"primary\">Surface Distance: </p>\n\t\t\t\t]] .. hud_TelemeterDistance .. [[\n\t\t\t</div>\n]]\nif environmentID == 1 then -- Atmo\n    hudHTMLBody = hudHTMLBody .. \n[[\n\t\t\t<div class=\"primary control-container\">\n\t\t\t\t<p class=\"primary\">Sea Level: </p>\n\t\t\t\t]] .. hud_Altitude .. [[\n\t\t\t</div>\n]]\nend\nhudHTMLBody = hudHTMLBody ..\n[[\n\t\t\t<div class=\"primary control-container\">\n\t\t\t\t<p class=\"primary\">Locale Gravity: </p>\n\t\t\t\t]] .. hud_LocalGravity .. [[\n\t\t\t</div>\n\n\n\t\t\t<div class=\"spacer\"></div>\n               <div class=\"category\">Speed...</div>\n\t\t\t<div class=\"primary control-container\">\n\t\t\t\t<p class=\"primary\">Vertical Velocity: </p>\n\t\t\t\t]] .. velocity_vertical .. ' m/s²' .. [[\n\t\t\t</div>\n\t\t\t<div class=\"primary control-container\">\n\t\t\t\t<p class=\"primary\">Speed: </p>\n\t\t\t\t]] .. velocity_kmh .. ' km/h' .. [[\n\t\t\t</div>\n\n\t\t\t<div class=\"spacer\"></div>\n\t\t\t<div class=\"category\">Braking...</div>\n\t\t\t<div class=\"primary control-container\">\n\t\t\t\t<p class=\"primary\">To full stop: </p>\n\t\t\t\t]] .. hud_Speed0 .. [[\n\t\t\t</div>\n]]\n\nif brakeDistanceSpeed2000[\"time\"] > 0 then\n    hudHTMLBody = hudHTMLBody .. \n[[\n\t\t\t<div class=\"primary control-container\">\n\t\t\t\t<p class=\"primary\">To 2000 km/h: </p>\n\t\t\t\t]] .. hud_Speed2000 .. [[\n\t\t\t</div>\n]]\nend\n\nhudHTMLBody = hudHTMLBody .. \n[[  \n\t\t</div>\n\t</div>\n]]\n\n\n\nlocal content = getHTMLHeader() .. hudHTMLBody .. [[<div class=\"msg\">]] .. table.concat(hudHTMLMsg, \"\") .. [[</div>]] .. getHTMLFooter()\nsystem.setScreen(content)\nsystem.showScreen(1)\n\n\n-- Darkwinde END: unit.tick(HUD)","filter":{"args":[{"value":"HUD"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"2"},{"code":"-- Darkwinde START: unit.tick(HUDMsg)\n\nhudHTMLMsg = {}\nunit.stopTimer(\"HUDMsg\")\n\n-- Darkwinde END: unit.tick(HUDMsg)","filter":{"args":[{"value":"HUDMsg"}],"signature":"tick(timerId)","slotKey":"-1"},"key":"3"},{"code":"-- Darkwinde START: unit.start()\n\n\n-- Initiate Globals START\nversion = \"v0.1\"\ndescription = \" - Minimalistic HUD from Darkwinde & Expugnator\"\n\n\ngravity = 9.81 -- m/s²\nvelocity = 0 -- m/s²\nvelocity_kmh = 0 -- km/h\n\n\nhabitats = {'Atmosphere', 'Space', 'Spacedock'}\nsurfaceDistanceLow = {15, 5, 5}  -- m\nsurfaceDistanceLanding = {40, 20, 20} -- m\nsurfaceDistanceHigh = {80, 80, 80} -- m\nsurfaceSpeedLow = {1, 1, 1} -- m/s²\nenvironment = getEnvironmentName()\nenvironmentID = getEnvironmentID()\n\n\nfirstStart = true\nlockBrake = true\nsurfaceBrake = true\n\n\nhudMsgTimer = 5\nhudHTMLMsg = {}\n-- Initiate Globals END\n\n\n-- Initiate Elements START\nbtnDoor.deactivate()\n-- Initiate Elements END\n\n-- Initiate Timers START\nunit.setTimer('HUD', 0.5)\n-- Initiate Timers END\n\n\n-- Darkwinde END: unit.start()","filter":{"args":[],"signature":"start()","slotKey":"-1"},"key":"4"},{"code":"-- Darkwinde START: unit.stop()\n\n\n-- FEATURE START: closeDoor\n\nlocal environmentParameter = getEnvironmentParameter(environmentID)\n\nif velocity <= environmentParameter[\"surfaceSpeedLow\"] and \n   round(telemeter.getDistance()) <= environmentParameter[\"surfaceDistanceLow\"] then \n    btnDoor.activate()\nend\n\n\n\nunit.stopTimer('HUD')\n\n\n-- Darkwinde END: unit.start()","filter":{"args":[],"signature":"stop()","slotKey":"-1"},"key":"5"},{"code":"pitchInput = 0\nrollInput = 0\nyawInput = 0\nbrakeInput = 0\n","filter":{"args":[],"signature":"start()","slotKey":"-2"},"key":"6"},{"code":"Nav:update()","filter":{"args":[],"signature":"update()","slotKey":"-2"},"key":"7"},{"code":"-- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu\n\nlocal pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01\nlocal brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)\nlocal autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01\n\nlocal turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is\nlocal turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\n-- validate params\npitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)\nyawSpeedFactor = math.max(yawSpeedFactor, 0.01)\nrollSpeedFactor = math.max(rollSpeedFactor, 0.01)\ntorqueFactor = math.max(torqueFactor, 0.01)\nbrakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)\nbrakeFlatFactor = math.max(brakeFlatFactor, 0.01)\nautoRollFactor = math.max(autoRollFactor, 0.01)\nturnAssistFactor = math.max(turnAssistFactor, 0.01)\n\n-- final inputs\nlocal finalPitchInput = pitchInput + system.getControlDeviceForwardInput()\nlocal finalRollInput = rollInput + system.getControlDeviceYawInput()\nlocal finalYawInput = yawInput - system.getControlDeviceLeftRightInput()\nlocal finalBrakeInput = brakeInput\n\n-- Axis\nlocal worldVertical = vec3(core.getWorldVertical()) -- along gravity\nlocal constructUp = vec3(core.getConstructWorldOrientationUp())\nlocal constructForward = vec3(core.getConstructWorldOrientationForward())\nlocal constructRight = vec3(core.getConstructWorldOrientationRight())\nlocal constructVelocity = vec3(core.getWorldVelocity())\nlocal constructVelocityDir = vec3(core.getWorldVelocity()):normalize()\nlocal currentRollDeg = getRoll(worldVertical, constructForward, constructRight)\nlocal currentRollDegAbs = math.abs(currentRollDeg)\nlocal currentRollDegSign = utils.sign(currentRollDeg)\n\n-- Rotation\nlocal constructAngularVelocity = vec3(core.getWorldAngularVelocity())\nlocal targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight\n                                + finalRollInput * rollSpeedFactor * constructForward\n                                + finalYawInput * yawSpeedFactor * constructUp\n\n-- In atmosphere?\nif worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then\n    local autoRollRollThreshold = 1.0\n    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling\n    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then\n        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit\n        if (rollPID == nil) then\n            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range\n        end\n        rollPID:inject(targetRollDeg - currentRollDeg)\n        local autoRollInput = rollPID:get()\n\n        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward\n    end\n    local turnAssistRollThreshold = 20.0\n    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing\n    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then\n        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range\n        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range\n\n        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)\n        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180\n        local rollVerticalRatio = 0\n        if rescaleRollDegAbs < 90 then\n            rollVerticalRatio = rescaleRollDegAbs / 90\n        elseif rescaleRollDegAbs < 180 then\n            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90\n        end\n\n        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio\n\n        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)\n        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio\n\n        targetAngularVelocity = targetAngularVelocity\n                            + turnAssistPitchInput * constructRight\n                            + turnAssistYawInput * constructUp\n    end\nend\n\n-- Engine commands\nlocal keepCollinearity = 1 -- for easier reading\nlocal dontKeepCollinearity = 0 -- for easier reading\nlocal tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities\n\n-- Rotation\nlocal angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)\nlocal airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())\nangularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction\nNav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)\n\n-- Brakes\nlocal brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)\nNav:setEngineForceCommand('brake', brakeAcceleration)\n\n-- AutoNavigation regroups all the axis command by 'TargetSpeed'\nlocal autoNavigationEngineTags = ''\nlocal autoNavigationAcceleration = vec3()\nlocal autoNavigationUseBrake = false\n\n-- Longitudinal Translation\nlocal longitudinalEngineTags = 'thrust analog longitudinal'\nlocal longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byThrottle) then\n    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)\n    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)\nelseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration\n    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop\n        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking\n    then\n        autoNavigationUseBrake = true\n    end\n\nend\n\n-- Lateral Translation\nlocal lateralStrafeEngineTags = 'thrust analog lateral'\nlocal lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)\nif (lateralCommandType == axisCommandType.byThrottle) then\n    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)\n    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)\nelseif  (lateralCommandType == axisCommandType.byTargetSpeed) then\n    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration\nend\n\n-- Vertical Translation\nlocal verticalStrafeEngineTags = 'thrust analog vertical'\nlocal verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)\nif (verticalCommandType == axisCommandType.byThrottle) then\n    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)\n    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)\nelseif  (verticalCommandType == axisCommandType.byTargetSpeed) then\n    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration\nend\n\n-- Auto Navigation (Cruise Control)\nif (autoNavigationAcceleration:len() > constants.epsilon) then\n    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward\n    then\n        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'\n    end\n    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)\nend\n\n-- Rockets\nNav:setBoosterCommand('rocket_engine')\n","filter":{"args":[],"signature":"flush()","slotKey":"-2"},"key":"8"},{"code":"if Nav.control.isAnyHeadlightSwitchedOn() == 1 then\n    Nav.control.switchOffHeadlights()\nelse\n    Nav.control.switchOnHeadlights()\nend\n","filter":{"args":[{"value":"light"}],"signature":"actionStart(light)","slotKey":"-2"},"key":"9"},{"code":"gearExtended = not gearExtended\nif gearExtended then\n    Nav.control.extendLandingGears()\nelse\n    Nav.control.retractLandingGears()\nend\n","filter":{"args":[{"value":"gear"}],"signature":"actionStart(gear)","slotKey":"-2"},"key":"10"},{"code":"pitchInput = pitchInput - 1","filter":{"args":[{"value":"forward"}],"signature":"actionStart(forward)","slotKey":"-2"},"key":"11"},{"code":"pitchInput = pitchInput + 1","filter":{"args":[{"value":"forward"}],"signature":"actionStop(forward)","slotKey":"-2"},"key":"12"},{"code":"pitchInput = pitchInput + 1","filter":{"args":[{"value":"backward"}],"signature":"actionStart(backward)","slotKey":"-2"},"key":"13"},{"code":"pitchInput = pitchInput - 1","filter":{"args":[{"value":"backward"}],"signature":"actionStop(backward)","slotKey":"-2"},"key":"14"},{"code":"rollInput = rollInput - 1","filter":{"args":[{"value":"left"}],"signature":"actionStart(left)","slotKey":"-2"},"key":"15"},{"code":"rollInput = rollInput + 1","filter":{"args":[{"value":"right"}],"signature":"actionStart(right)","slotKey":"-2"},"key":"16"},{"code":"rollInput = rollInput - 1","filter":{"args":[{"value":"right"}],"signature":"actionStop(right)","slotKey":"-2"},"key":"17"},{"code":"rollInput = rollInput + 1","filter":{"args":[{"value":"left"}],"signature":"actionStop(left)","slotKey":"-2"},"key":"18"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)","filter":{"args":[{"value":"straferight"}],"signature":"actionStart(straferight)","slotKey":"-2"},"key":"19"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)","filter":{"args":[{"value":"straferight"}],"signature":"actionStop(straferight)","slotKey":"-2"},"key":"20"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)","filter":{"args":[{"value":"strafeleft"}],"signature":"actionStart(strafeleft)","slotKey":"-2"},"key":"21"},{"code":"Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\nNav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)\n","filter":{"args":[{"value":"up"}],"signature":"actionStart(up)","slotKey":"-2"},"key":"22"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)","filter":{"args":[{"value":"strafeleft"}],"signature":"actionStop(strafeleft)","slotKey":"-2"},"key":"23"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)\nNav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)\n","filter":{"args":[{"value":"up"}],"signature":"actionStop(up)","slotKey":"-2"},"key":"24"},{"code":"Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\nNav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)\n","filter":{"args":[{"value":"down"}],"signature":"actionStart(down)","slotKey":"-2"},"key":"25"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)\nNav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)\n","filter":{"args":[{"value":"down"}],"signature":"actionStop(down)","slotKey":"-2"},"key":"26"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)","filter":{"args":[{"value":"groundaltitudeup"}],"signature":"actionStart(groundaltitudeup)","slotKey":"-2"},"key":"27"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)","filter":{"args":[{"value":"groundaltitudeup"}],"signature":"actionLoop(groundaltitudeup)","slotKey":"-2"},"key":"28"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)","filter":{"args":[{"value":"groundaltitudedown"}],"signature":"actionStart(groundaltitudedown)","slotKey":"-2"},"key":"29"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)","filter":{"args":[{"value":"groundaltitudedown"}],"signature":"actionLoop(groundaltitudedown)","slotKey":"-2"},"key":"30"},{"code":"yawInput = yawInput - 1","filter":{"args":[{"value":"yawright"}],"signature":"actionStart(yawright)","slotKey":"-2"},"key":"31"},{"code":"yawInput = yawInput + 1","filter":{"args":[{"value":"yawright"}],"signature":"actionStop(yawright)","slotKey":"-2"},"key":"32"},{"code":"yawInput = yawInput - 1","filter":{"args":[{"value":"yawleft"}],"signature":"actionStop(yawleft)","slotKey":"-2"},"key":"33"},{"code":"brakeInput = brakeInput + 1\nlocal longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)\n    if (math.abs(targetSpeed) > constants.epsilon) then\n        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))\n    end\nend\n","filter":{"args":[{"value":"brake"}],"signature":"actionStart(brake)","slotKey":"-2"},"key":"34"},{"code":"yawInput = yawInput + 1","filter":{"args":[{"value":"yawleft"}],"signature":"actionStart(yawleft)","slotKey":"-2"},"key":"35"},{"code":"local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)\n    if (math.abs(targetSpeed) > constants.epsilon) then\n        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))\n    end\nend\n","filter":{"args":[{"value":"brake"}],"signature":"actionLoop(brake)","slotKey":"-2"},"key":"36"},{"code":"brakeInput = brakeInput - 1","filter":{"args":[{"value":"brake"}],"signature":"actionStop(brake)","slotKey":"-2"},"key":"37"},{"code":"Nav:toggleBoosters()","filter":{"args":[{"value":"booster"}],"signature":"actionStart(booster)","slotKey":"-2"},"key":"38"},{"code":"Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)","filter":{"args":[{"value":"speedup"}],"signature":"actionLoop(speedup)","slotKey":"-2"},"key":"39"},{"code":"Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)","filter":{"args":[{"value":"stopengines"}],"signature":"actionStart(stopengines)","slotKey":"-2"},"key":"40"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)","filter":{"args":[{"value":"speedup"}],"signature":"actionStart(speedup)","slotKey":"-2"},"key":"41"},{"code":"Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)","filter":{"args":[{"value":"speeddown"}],"signature":"actionLoop(speeddown)","slotKey":"-2"},"key":"42"},{"code":"if antigrav ~= nil then antigrav.toggle() end","filter":{"args":[{"value":"antigravity"}],"signature":"actionStart(antigravity)","slotKey":"-2"},"key":"43"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)","filter":{"args":[{"value":"speeddown"}],"signature":"actionStart(speeddown)","slotKey":"-2"},"key":"44"},{"code":"if warpdrive ~= nil then warpdrive.activateWarp() end","filter":{"args":[{"value":"warp"}],"signature":"actionStart(warp)","slotKey":"-2"},"key":"45"},{"code":"-- Darkwinde START: system.flush()\n-- Telemeter\n-- >> Distance can be between 1 and 100. \n-- >> Scripting Wiki for telemeter is wrong. For MaxDistance it is mentioned 20m\n-- >> !!! Telemeter even works (hidden) behind honeycomb\n-- system.print(telemeter.getDistance())\n\nlocal landing = true\nlocal surfaceLow = true\nlocal environmentParameter = getEnvironmentParameter(environmentID)\nlanding = telemeter.getDistance() > 0 and telemeter.getDistance() < environmentParameter[\"surfaceDistanceLanding\"]\nsurfaceLow = telemeter.getDistance() > 0 and telemeter.getDistance() <= environmentParameter[\"surfaceDistanceLow\"]\n\n \n\n-- Start and landing condition to park on surface\nif lockBrake then\n    brakeInput = 1\n    \n    if surfaceLow then\n        Nav.control.setEngineThrust(\"vertical, thrust\", 0) -- default tags are in lower case\n        Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\n        Nav.axisCommandManager:setTargetGroundAltitude(0)\n    end\nend\n\n\n\n-- Use brake to stabalize near ground level\nif surfaceBrake and surfaceLow then\n    brakeInput = 1\nelseif surfaceBrake and not surfaceLow then\n    surfaceBrake = false\n    brakeInput = 0\nelseif not surfaceBrake and surfaceLow then\n    surfaceBrake = true\n    brakeInput = 1\nend\n\n\n\n-- Extend and retract landing gear\nif landing then\n    Nav.control.extendLandingGears()\nelse\n    Nav.control.retractLandingGears()\nend\n\n\n\n\n\n-- Darkwinde END: system.flush()","filter":{"args":[],"signature":"flush()","slotKey":"-2"},"key":"46"},{"code":"-- Darkwinde START: system.actionStart(option 1)\n-- >> Option 1 is by default ALT+1\n\n-- Take off script by releasing brake and setting altitude level\nlockBrake = not lockBrake\n\n\nif not lockBrake then\n    local environmentParameter = getEnvironmentParameter(environmentID)\n    \n    \n    Nav.control.setEngineThrust(\"vertical, thrust\", 1) -- default tags are in lower case\n\n    Nav.axisCommandManager:setTargetGroundAltitude(environmentParameter[\"surfaceDistanceLow\"])\n    Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(environmentParameter[\"surfaceDistanceLow\"])\n\n    \n    brakeInput = 0\n \n    if firstStart then\n        setHTMLMessage(hudHTMLMsg, \"TAKE OFF \\n Have a nice flight!\")\n    end\nend\n\n\n\n\n-- Darkwinde END: system.actionStart(option 1)","filter":{"args":[{"value":"option1"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"47"},{"code":"-- Darkwinde START: system.actionStart(option 2)\n-- >> Option 1 is by default ALT+2\n\n\n\n--setHTMLMessage(hudHTMLMsg, \"Alles super\", \"info\")\n--setHTMLMessage(hudHTMLMsg, \"Alles super\", \"ok\")\n--setHTMLMessage(hudHTMLMsg, \"Alles super\", \"warning\")\n--setHTMLMessage(hudHTMLMsg, \"Alles super\", \"critical\")\n\n\n\n\n--brakeDistance = getBrakeDistance(2000)\n--brakeDistanceTime = brakeDistance[\"min\"] .. \"m:\" .. brakeDistance[\"sec\"] .. \"s\"\n--brakeDistanceSU = brakeDistance[\"su\"] .. \"su\"\n--brakeDistanceKM = brakeDistance[\"km\"] .. \"km\"\n\n\n--system.print(dump(unit.getData()))\n\n\nsystem.print(dump(  Nav:getTargetGroundAltitude()    ))\n\n\n\n--system.print(\"Braking ends after \" .. brakeDistanceTime .. \" and \" .. brakeDistanceSU)\n-- Darkwinde END: system.actionStart(option 2)","filter":{"args":[{"value":"option2"}],"signature":"actionStart(action)","slotKey":"-2"},"key":"48"},{"code":"-- Darkwinde START: library.start()\n\n-- Generic Functions START\n\n-- Return dumped information in a humal readable string\nfunction dump(o)\n\tif type(o) == 'table' then\n\t\tlocal s = '{ '\n\t\tfor k,v in pairs(o) do\n\t\t\tif type(k) ~= 'number' then \n\t\t\t\tk = '\"'..k..'\"' \n\t\t\tend\n\t\t\ts = s .. '['..k..'] = ' .. dump(v) .. ','\n\t\tend\n\t\treturn s .. '} '\n\telse\n\t\treturn tostring(o)\n\tend\nend\n\n\n-- If condition is TRUE return variable T else variable F\n-- >> Used at feature: system.update() -> hudShowBrakeStatus\nfunction ternary(cond, T, F)\n\tif cond then\n\t\treturn T\n\telse\n\t\treturn F\n\tend\nend\n\n\n\n-- Round float number to certain digits\nfunction round(num, numDecimalPlaces)\n    local mult = 10 ^ (numDecimalPlaces or 0)\n    if numDecimalPlaces ~= nil then\n        return math.floor(num * mult + 0.5) / mult\n    else\n        return math.floor((num * mult + 0.5) / mult)\n    end\nend\n\n\n-- Generic Functions END\n\n\n\n-- Getter & Setter START\n\n-- HTML header part for the HUD\nfunction getHTMLHeader()\n\treturn [[\n\t<head>\n\t<style>\n     body {margin: 0}\n     .primary \n\t{\n\t\tfont-size: 1rem;\n\t\tcolor: #B6DFED;\n\t}\n\t.zen \n\t{\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t}\n\t.controls-hud \n\t{\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\tjustify-content: space-around;\n\t\tbackground-color: #34495E80;\n\t\tborder-color: #333333;\n\t\tborder-radius: 12px;\n\t\twidth: 25%;\n\t\tpadding: 1% 1.5%;\n\t\toverflow: none;\n\t}\n\t.control-container \n\t{\n\t\tdisplay: flex;\n\t\tjustify-content: space-between;\n\t\tpadding: 0.5%;\n\t}\n\t.category \n\t{\n\t\tcolor: #ffffff;\n          font-size: 1rem;\n\t\ttext-align: center;\n\t}\n\t.spacer \n\t{\n\t\tmargin: 3px;\n\t\tborder-top: 1px solid #ffffff;\n\t}\n\t.on \n\t{\n\t\tbackground-color: red;\n\t\tmargin-left: 10px;\n\t\tborder-radius: 50%;\n\t\twidth: 28px;\n\t\theight: 28px;\n\t\tborder: 2px solid black;\n\t\ttext-align: center;\n\t}\n\t.off \n\t{\n\t\tbackground-color: green;\n\t\tmargin-left: 10px;\n\t\tborder-radius: 50%;\n\t\twidth: 28px;\n\t\theight: 28px;\n\t\tborder: 2px solid black;\n\t\ttext-align: center;\n\t}\n\t.msg \n\t{\n\t\tposition: absolute;\n\t\ttop: 50%;\n\t\tleft: 50%;\n\t\t-moz-transform: translateX(-50%) translateY(-50%);\n\t\t-webkit-transform: translateX(-50%) translateY(-50%);\n\t\ttransform: translateX(-50%) translateY(-50%);\n\t\ttext-align: center;\n\t}\n    .info {font-size: 1.8rem; color: #B6DFED;}\n    .ok {font-size: 2.5rem; color: green;}\n    .warning {font-size: 2.5rem; color: yellow;}\n    .critical {font-size: 3.5rem; color: red;}\n    .version\n    {\n\t\tposition: absolute;\n\t\tbottom: 0; \n          right: 0;\n\t\twidth: 100%;\n\t\theight: 0.5rem;\n\t\tfont-size: 0.55rem;\n\t\ttext-align: right;\n\t}\n\t</style>\n\t</head>\n\t<body>\n\t\n\t]]\nend\n\n\n-- HTML footer part for the HUD\nfunction getHTMLFooter()\n    return  string.format([[<div class=\"version\">%s %s</div></body>]], version, description)\nend\n\n\n-- HTML HUD message\nfunction setHTMLMessage(hudHTMLMsg, msg, msgtype)    \n    if msgtype == nil then\n        msgtype = \"info\"\n    end\n    \n    for str in string.gmatch(msg, \"([^\\n]+)\") do\n        hudHTMLMsg[#hudHTMLMsg + 1] = string.format([[<div class=\"%s\">%s</div>]], msgtype, str)\n    end\n    \n    unit.setTimer(\"HUDMsg\", hudMsgTimer)\nend  \n\n\n-- Get current environment information returned as ID or name\nfunction getEnvironmentID()\n    if unit.getAtmosphereDensity() > 0.0 then -- Atmo\n        return  1\n    elseif core.g() >= gravity then -- Spacedock\n        return 3\n    else -- Space\n        return 2\n    end\nend\nfunction getEnvironmentName(id)  \n    if id ~= nil then\n        return habitats[id]\n    end\n    \n    if unit.getAtmosphereDensity() > 0.0 then -- Atmo\n        return  habitats[1]\n    elseif core.g() >= gravity then -- Spacedock\n       return habitats[3]\n    else -- Space\n        return habitats[2]\n    end\nend\nfunction getEnvironmentParameter(id) \n    local returnvalue = {}\n    \n    if id ~= nil then -- ID based\n        returnvalue[\"habitat\"] = habitats[id]\n        returnvalue[\"surfaceDistanceLow\"] = surfaceDistanceLow[id]\n        returnvalue[\"surfaceDistanceLanding\"] = surfaceDistanceLanding[id]\n        returnvalue[\"surfaceDistanceHigh\"] = surfaceDistanceHigh[id]\n        returnvalue[\"surfaceSpeedLow\"] = surfaceSpeedLow[id]\n    else\n        if unit.getAtmosphereDensity() > 0.0 then -- Atmo\n            returnvalue[\"habitat\"] = habitats[1]\n            returnvalue[\"surfaceDistanceLow\"] = surfaceDistanceLow[1]\n            returnvalue[\"surfaceDistanceLanding\"] = surfaceDistanceLanding[1]\n            returnvalue[\"surfaceDistanceHigh\"] = surfaceDistanceHigh[1]\n            returnvalue[\"surfaceSpeedLow\"] = surfaceSpeedLow[1]\n        elseif core.g() >= gravity then -- Spacedock\n            returnvalue[\"habitat\"] = habitats[3] \n            returnvalue[\"surfaceDistanceLow\"] = surfaceDistanceLow[3]\n            returnvalue[\"surfaceDistanceLanding\"] = surfaceDistanceLanding[3]\n            returnvalue[\"surfaceDistanceHigh\"] = surfaceDistanceHigh[3]\n            returnvalue[\"surfaceSpeedLow\"] = surfaceSpeedLow[3]\n        else -- Space\n            returnvalue[\"habitat\"] = habitats[2]\n            returnvalue[\"surfaceDistanceLow\"] = surfaceDistanceLow[2]\n            returnvalue[\"surfaceDistanceLanding\"] = surfaceDistanceLanding[2]\n            returnvalue[\"surfaceDistanceHigh\"] = surfaceDistanceHigh[2]\n            returnvalue[\"surfaceSpeedLow\"] = surfaceSpeedLow[2]\n        end \n    end\n    \n    return returnvalue\nend\n\n\nfunction getBrakeDistance(endingSpeed)\n    local returnvalue = {}\n    local distance = 0;\n    local time = 0;\n    local c = 30000*1000/3600\n    local c2 = c*c\n\n    \n    local initialSpeed = vec3(core.getVelocity()):len() -- m/s\n    --local initialSpeed = 20000 / 3.6 -- m/s --> For Testing\n    endingSpeed = endingSpeed / 3.6 -- m/s\n    local restMass = round(core.getConstructMass()) -- kg\n    local spaceBrake = json.decode(unit.getData()).maxBrake -- N\n    local totA = -spaceBrake * (1-0)/restMass;\n\n    \n    if initialSpeed > endingSpeed then\n        local k1 = c * math.asin(initialSpeed / c)\n        local k2 = c2 * math.cos(k1 / c) / totA\n        time = (c * math.asin(endingSpeed / c) - k1) / totA\n        distance = k2 - c2 * math.cos((totA * time + k1) / c) / totA\n    end\n\n    \n    local min = math.floor(time / 60)   \n    local timeFrac = time - 60 * min\n    local sec = round(timeFrac)\n    local su = math.floor(distance / 200000)\n    local remainder = distance - 200000 * su;\n    local suFrac = round(100 * remainder / 200000) / 100;\n    local km = round(distance / 1000);\n\n\n    returnvalue[\"min\"] = min\n    returnvalue[\"sec\"] = sec\n    returnvalue[\"su\"] = su + suFrac\n    returnvalue[\"km\"] = km\n    returnvalue[\"time\"] = time\n    returnvalue[\"distance\"] = distance\n\n\n    return returnvalue\nend\n\n\n\n\n\n-- Getter & Setter END\n\n\n\n\n-- Darkwinde END: library.start()\n\n\n","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"49"}],"methods":[],"events":[]}