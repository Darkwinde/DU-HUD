{"slots":{"0":{"name":"core","type":{"events":[],"methods":[]}},"1":{"name":"slot2","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"10":{"name":"slot11","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-2":{"name":"system","type":{"events":[],"methods":[]}},"-3":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"-- category panel display helpers\n_autoconf = {}\n_autoconf.panels = {}\n_autoconf.panels_size = 0\n_autoconf.displayCategoryPanel = function(elements, size, title, type, widgetPerData)\n    widgetPerData = widgetPerData or false -- default to one widget for all data\n    if size > 0 then\n        local panel = system.createWidgetPanel(title)\n        local widget\n        if not widgetPerData then\n            widget = system.createWidget(panel, type)\n        end\n        for i = 1, size do\n            if widgetPerData then\n                widget = system.createWidget(panel, type)\n            end\n            system.addDataToWidget(elements[i].getDataId(), widget)\n        end\n        _autoconf.panels_size = _autoconf.panels_size + 1\n        _autoconf.panels[_autoconf.panels_size] = panel\n    end\nend\n_autoconf.hideCategoryPanels = function()\n    for i=1,_autoconf.panels_size do\n        system.destroyWidgetPanel(_autoconf.panels[i])\n    end\nend\n-- Proxy array to access auto-plugged slots programmatically\nweapon = {}\nweapon_size = 0\n\nradar = {}\nradar_size = 0\n\nspacefueltank = {}\nspacefueltank_size = 0\n\natmofueltank = {}\natmofueltank_size = 0\n\nrocketfueltank = {}\nrocketfueltank_size = 0\n-- End of auto-generated code\npitchInput = 0\nrollInput = 0\nyawInput = 0\nbrakeInput = 0\n\nNav = Navigator.new(system, core, unit)\nNav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})\nNav.axisCommandManager:setTargetGroundAltitude(4)\n\n-- element widgets\n-- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.\n_autoconf.displayCategoryPanel(weapon, weapon_size, \"Weapons\", \"weapon\", true)\ncore.show()\n_autoconf.displayCategoryPanel(radar, radar_size, \"Periscope\", \"periscope\")\nplaceRadar = true\nif atmofueltank_size > 0 then\n    _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, \"Atmo Fuel\", \"fuel_container\")\n    if placeRadar then\n        _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n        placeRadar = false\n    end\nend\nif spacefueltank_size > 0 then\n    _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, \"Space Fuel\", \"fuel_container\")\n    if placeRadar then\n        _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n        placeRadar = false\n    end\nend\n_autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, \"Rocket Fuel\", \"fuel_container\")\nif placeRadar then -- We either have only rockets or no fuel tanks at all, uncommon for usual vessels\n    _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n    placeRadar = false\nend\nif antigrav ~= nil then antigrav.show() end\nif warpdrive ~= nil then warpdrive.show() end\nif gyro ~= nil then gyro.show() end\n\n-- freeze the player in he is remote controlling the construct\nif Nav.control.isRemoteControlled() == 1 then\n    system.freeze(1)\nend\n\n-- landing gear\n-- make sure every gears are synchonized with the first\ngearExtended = (Nav.control.isAnyLandingGearExtended() == 1) -- make sure it's a lua boolean\nif gearExtended then\n    Nav.control.extendLandingGears()\nelse\n    Nav.control.retractLandingGears()\nend\n","filter":{"args":[],"signature":"start()","slotKey":"-1"},"key":"0"},{"code":"_autoconf.hideCategoryPanels()\nif antigrav ~= nil then antigrav.hide() end\nif warpdrive ~= nil then warpdrive.hide() end\nif gyro ~= nil then gyro.hide() end\ncore.hide()\nNav.control.switchOffHeadlights()\n","filter":{"args":[],"signature":"stop()","slotKey":"-1"},"key":"1"},{"code":"-- Darkwinde START: unit.tick(FUEL)\n\n-- Update fuel tank list\nfor typ, tanks in pairs(myFuelTanks) do\n    for i, parameter in ipairs(tanks) do\n        -- Get element information\n        local id = parameter[\"id\"]\n        local typ  = core.getElementTypeById(id):lower()\n        local name  = core.getElementNameById(id):lower()\n        local mass = core.getElementMassById(id)    \n        local hp = core.getElementMaxHitPointsById(id)\n        local emptyMass, curMass, maxVolume, curVolume, consVolume, consTime = 0, 0, 0, 0, 0, 0\n        local curTime = system.getTime()\n        -- Define fuel tank skills for later use by reference\n        local fuelTankSkills = {[\"atmospheric fuel-tank\"] = ftoAtmo, [\"space fuel-tank\"] = ftoSpace, [\"rocket fuel-tank\"] = ftoRocket}\n\n        \n        -- Get fuel tank parameter\n        local size = \"XS\" -- default size     \n        if hp >= fuelTanks[typ][\"L\"][\"hp\"] then \n            size = \"L\"\n        elseif hp >= fuelTanks[typ][\"M\"][\"hp\"] then \n            size = \"M\"\n        elseif hp >= fuelTanks[typ][\"S\"][\"hp\"] then \n            size = \"S\"\n        end\n\n        \n        -- Calculate tank mass\n        emptyMass = round(fuelTanks[typ][size][\"mass\"])\n        curMass = round(mass - emptyMass, 2)\n\n        -- Calculate fuel volume\n        maxVolume = round(fuelTanks[typ][size][\"volume\"])\n        curVolume = round(curMass / fuel[typ], 2)\n\n        -- Calculate consumed fuel and remaining time until empty\n        consVolume = parameter[\"curvolume\"] - curVolume\n\n        if consVolume > 0 then\n            consTime = curVolume / (consVolume / (curTime - parameter[\"time\"]))\n        end\n\n        \n        local h = math.floor(consTime / 3600)\n        local timeFrac1 = consTime - 3600 * h\n        local min = math.floor(timeFrac1 / 60)\n        local timeFrac2 = timeFrac1 - 60 * min\n        local sec = round(timeFrac2)\n        consTime = h .. \"h:\" ..min .. \"m:\" .. sec .. \"s\"\n\n\n        -- Check and apply for fuel tank skills\n        if fuelTankSkills[typ] ~= nil and fuelTankSkills[typ] > 0 then\n            maxVolume = maxVolume * (1 + fuelTankSkills[typ] * 0.2)\n        end\n\n        -- Update fuel tank information\n        parameter[\"curvolume\"] = curVolume\n        parameter[\"curmass\"] = curMass\n        parameter[\"consvolume\"] = consVolume\n        parameter[\"constime\"] = consTime\n        parameter[\"time\"] = curTime\n    end\nend\n\n\n\n\n\n-- Darkwinde END: unit.tick(FUEL)","filter":{"args":[{"value":"FUEL"}],"signature":"tick(timerId)","slotKey":"-1"},"key":47},{"code":"-- Darkwinde START: unit.tick(HUDMsg)\n\nhudHTMLMsg = {}\nunit.stopTimer(\"HUDMsg\")\n\n-- Darkwinde END: unit.tick(HUDMsg)","filter":{"args":[{"value":"HUDMsg"}],"signature":"tick(timerId)","slotKey":"-1"},"key":48},{"code":"-- Darkwinde START: unit.tick(HUD)\n\n\n-- UPDATE GLOBALS START\nup = vec3(core.getWorldVertical()) * -1\nvelocity = vec3(core.getWorldVelocity())\nvelocity_kmh = round(vec3(core.getVelocity()):len() * 3.6)\nvelocity_vertical =  round((velocity.x * up.x) + (velocity.y * up.y) + (velocity.z * up.z))\n\nenvironment = getEnvironmentName()\nenvironmentID = getEnvironmentID()\n\nsystemReference = PlanetRef()(Atlas())[0]\nplanet = systemReference:closestBody(core.getConstructWorldPos())\n-- UPDATE GLOBALS END\n\n\nlocal hudHTMLBody = {}\nlocal hud_BrakeStatus = ternary(lockBrake, '<div class=\"on\">on</div>', '<div class=\"off\">off</div>')\nlocal hud_Environment = ''\nif environmentID == 3 then -- Spacedock\n    hud_Environment = '<div style=\"color:#20b020; font-weight:bold;\">' .. environment .. '</div>'\n\n    if not firstStart then\n        setHTMLMessage(hudHTMLMsg, \"You are docked!!!\", \"ok\")\n        firstStart = not firstStart\n    end\nelse -- Atmo & Space\n    hud_Environment = '<div>' .. environment .. '</div>'\n\n    if firstStart then \n        firstStart = not firstStart\n    end\nend\n\n\n--local hud_MaxThrust = round(Nav:maxForceForward() / 1000) .. 'kN'\nlocal hud_Throttle = ternary(Nav.axisCommandManager:getAxisCommandType(0) == 1, math.floor(unit.getThrottle() / 100) .. ' km/h', math.floor(unit.getThrottle()) .. '%')\nlocal hud_FlightStyle = ternary(Nav.axisCommandManager:getAxisCommandType(0) == 1, 'cruise', 'travel')\n-- Space core gravity is slightly above 10m/s², display adjustment required\nlocal gravityAdjustment = ternary(environmentID == 3, 10, gravity) -- m/s²\nlocal hud_LocalGravity = round((core.g() / gravityAdjustment), 2) .. 'g'\nlocal hud_Altitude = round(core.getAltitude()) .. 'm'\nlocal hud_SurfaceEstimation = ternary(planet.surface ~= -1, round(core.getAltitude() - planet.surface) .. 'm', '<div style=\"color:red; font-weight:bold;\">Not In List</div>')\nlocal hud_AtmosphereDensity = round(unit.getAtmosphereDensity() * 100) .. '%'\nlocal hud_AirResistance = round(vec3(core.getWorldAirFrictionAcceleration()):len()) .. 'N'\nlocal constructMass = core.getConstructMass() * (1 + payloadOverhead / 100) -- kg\nlocal reqThrust = constructMass * core.g() -- N\nlocal maxThrust = ternary(vtolPlane, Nav:maxForceUp(), Nav:maxForceForward()) -- N\nlocal ratioThrust = round(maxThrust / reqThrust - 1, 2) -- >1: Space possible / =1: Flight possible / <1: Flight not possible\nlocal maxMass = maxThrust / core.g() -- kg\nlocal hud_RemainingPayloadLift = ternary(constructMass > maxMass, '<div style=\"color:red; font-weight:bold;\">', '<div>') .. round((maxMass - constructMass) / 1000, 3) .. 't</div>'\nlocal hud_TelemeterDistance = ternary(telemeter.getDistance() == 0, 'N/A', round(telemeter.getDistance()) .. 'm')\n\n\n--local hud_Acceleration = round((vec3(core.getWorldAcceleration()):len() / gravity), 1) .. 'g'\nlocal brakeDistanceSpeed0 = getBrakeDistance(0) -- km/h\nlocal brakeDistanceSpeed2000 = getBrakeDistance(2000) -- km/h\nlocal hud_Speed0 = brakeDistanceSpeed0[\"min\"] .. \"m:\" .. brakeDistanceSpeed0[\"sec\"] .. \"s - \" .. brakeDistanceSpeed0[\"su\"] .. \"su (\" .. ternary(brakeDistanceSpeed0[\"km\"] == 0, \"0\",  brakeDistanceSpeed0[\"km\"]) .. \"km)\"\nlocal hud_Speed2000 = brakeDistanceSpeed2000[\"min\"] .. \"m:\" .. brakeDistanceSpeed2000[\"sec\"] .. \"s - \" .. brakeDistanceSpeed2000[\"su\"] .. \"su (\" ..  ternary(brakeDistanceSpeed2000[\"km\"] == 0, \"0\", brakeDistanceSpeed2000[\"km\"]) .. \"km)\"\n\n\n\n\n\nhudHTMLBody[#hudHTMLBody + 1] = \n[[\n<div class=\"zen\">\n\t<div class=\"controls-hud\">\n\t\t<div class=\"category\">Status...</div>\n\t\t<div class=\"primary control-container\">\n\t\t\t<p class=\"primary\">Handbrake:</p>\n\t\t\t]] .. hud_BrakeStatus .. [[\n\t\t</div>\n\t\t<div class=\"primary control-container\">\n\t\t\t<p class=\"primary\">Environment:</p>\n\t\t\t]] .. hud_Environment .. [[\n\t\t</div>\n]]\n\n\nhudHTMLBody[#hudHTMLBody + 1] =\n[[\n\t\t<div class=\"spacer\"></div>\n\t\t<div class=\"category\">Speed...</div>\n\t\t<div class=\"primary control-container\">\n\t\t\t<p class=\"primary\">Speed: </p>\n\t\t\t]] .. velocity_kmh .. ' km/h' .. [[\n\t\t</div>\n]]\n\n\n-- Show only in atmosphere\nhudHTMLBody[#hudHTMLBody + 1] = ternary(environmentID == 1,\n[[\n\t\t<div class=\"primary control-container\">\n\t\t\t<p class=\"primary\">Vertical Velocity: </p>\n\t\t\t]] .. velocity_vertical .. ' m/s²' .. [[\n\t\t</div>\n]]\n, \"\")\n\n\nhudHTMLBody[#hudHTMLBody + 1] =\n[[\n\t\t<div class=\"spacer\"></div>\n\t\t<div class=\"category\">Braking...</div>\n\t\t<div class=\"primary control-container\">\n\t\t\t<p class=\"primary\">To full stop: </p>\n\t\t\t]] .. hud_Speed0 .. [[\n\t\t</div>\n]]\n\n\n-- Show only, if brake distance is higher\nhudHTMLBody[#hudHTMLBody + 1] = ternary(brakeDistanceSpeed2000[\"time\"] > 0, \n[[\n\t\t<div class=\"primary control-container\">\n\t\t\t<p class=\"primary\">To 2000 km/h: </p>\n\t\t\t]] .. hud_Speed2000 .. [[\n\t\t</div>\n]]\n, \"\")\n\n\n\nhudHTMLBody[#hudHTMLBody + 1] = \n[[\n\t\t<div class=\"spacer\"></div>\n\t\t<div class=\"category\">Telemetric...</div>\n          <div class=\"primary control-container\">\n\t\t\t<p class=\"primary\">Throttle:</p>\n\t\t\t]] .. hud_Throttle .. [[\n\t\t</div>\n          <div class=\"primary control-container\">\n\t\t\t<p class=\"primary\">Flight Style:</p>\n\t\t\t]] .. hud_FlightStyle .. [[\n\t\t</div>\n\t\t<div class=\"primary control-container\">\n\t\t\t<p class=\"primary\">Locale Gravity: </p>\n\t\t\t]] .. hud_LocalGravity .. [[\n\t\t</div>\n]]\n\n\n-- Show only in atmosphere\nhudHTMLBody[#hudHTMLBody + 1] = ternary(environmentID == 1, \n[[\n    \t<div class=\"primary control-container\">\n\t\t\t<p class=\"primary\">Sea Level: </p>\n\t\t\t]] .. hud_Altitude .. [[\n\t\t</div>\n          <div class=\"primary control-container\">\n\t\t\t<p class=\"primary\">Estm. to surface: </p>\n\t\t\t]] .. hud_SurfaceEstimation .. [[\n\t\t</div>\n    \t <div class=\"primary control-container\">\n\t\t\t<p class=\"primary\">Density: </p>\n\t\t\t]] .. hud_AtmosphereDensity .. [[\n\t\t</div>\n          <div class=\"primary control-container\">\n\t\t\t<p class=\"primary\">Air Resistance: </p>\n\t\t\t]] .. hud_AirResistance .. [[\n\t\t</div>\n    \t <div class=\"primary control-container\">\n\t\t\t<p class=\"primary\">Remaining Payload: </p>\n\t\t\t]] .. hud_RemainingPayloadLift .. [[\n\t\t</div>\n]]\n, \"\")\n\n\n-- Show only near ground\nhudHTMLBody[#hudHTMLBody + 1] = ternary(telemeter.getDistance() >= 0, \n[[\n\t\t<div class=\"primary control-container\">\n\t\t\t<p class=\"primary\">Obstacle Distance: </p>\n\t\t\t]] .. hud_TelemeterDistance .. [[\n\t\t</div>\n]]\n, \"\")\n\n\n\n-- Show \"complex\" fuel tank information\nif (myFuelTanks[\"atmospheric fuel tank\"] ~= nil or myFuelTanks[\"space fuel tank\"] ~= nil or myFuelTanks[\"rocket fuel tank\"] ~= nil) then\n\thudHTMLBody[#hudHTMLBody + 1] =\n\t[[\n\t\t<div class=\"spacer\"></div>\n\t\t<div class=\"category\">Fuel...</div>\n\t]]    \n   \n    local tmpHTMLFuelTanks = {[\"atmospheric fuel tank\"]={},[\"space fuel tank\"]={},[\"rocket fuel tank\"]={}}\n    for typ, tanks in pairs(myFuelTanks) do         \n        for i, parameter in ipairs(tanks) do        \n            local displayName = \"N/A\"\n            local displayVolume = round(parameter[\"curvolume\"] / parameter[\"maxvolume\"] * 100)\n            local displayVolumeLevel = round(parameter[\"curvolume\"]) .. \" / \" .. round(parameter[\"maxvolume\"]) .. \"l\"\n            \n            if typ == \"atmospheric fuel tank\" then\n            \tdisplayName = \"Atmo \" .. i\n            elseif typ == \"space fuel tank\" then\n            \tdisplayName = \"Space \" .. i\n            elseif typ == \"rocket fuel tank\" then\n            \tdisplayName = \"Rocket \" .. i\n            end\n    \t\t \n            tmpHTMLFuelTanks[typ][#tmpHTMLFuelTanks[typ] + 1] = \n            [[\n                <div class=\"primary control-container\">\n                    <p class=\"primary\">]] .. displayName .. [[ </p>\n                    ]] .. displayVolumeLevel .. \"&nbsp;&nbsp;(\" .. displayVolume .. \"%)\" .. [[  \n                </div>\n                <div class=\"primary2 control-container\">\n                    <p></p>\n                    ]] .. parameter[\"constime\"] .. [[\n                </div>\n            ]]\n        end\n    end\n    \n    -- Sort the unordered list: Atmo, Space, Rock\n    hudHTMLBody[#hudHTMLBody + 1] = table.concat(tmpHTMLFuelTanks[\"atmospheric fuel tank\"], \"\")\n    hudHTMLBody[#hudHTMLBody + 1] = table.concat(tmpHTMLFuelTanks[\"space fuel tank\"], \"\")\n    hudHTMLBody[#hudHTMLBody + 1] = table.concat(tmpHTMLFuelTanks[\"rocket fuel tank\"], \"\")\nend\n\n\n\n\nhudHTMLBody[#hudHTMLBody + 1] = \n[[  \n\t</div>\n</div>\n]]\n\n\nlocal content = getHTMLHeader() .. orbitinterface() .. table.concat(hudHTMLBody, \"\")  .. [[<div class=\"msg\">]] .. table.concat(hudHTMLMsg, \"\") .. [[</div>]] .. getHTMLFooter()\nsystem.setScreen(content)\nsystem.showScreen(1)\n\n\n\n\n\n\n-- Darkwinde END: unit.tick(HUD)","filter":{"args":[{"value":"HUD"}],"signature":"tick(timerId)","slotKey":"-1"},"key":49},{"code":"-- Darkwinde START: unit.stop()\n\nlocal environmentParameter = getEnvironmentParameter(environmentID)\nif doorSwitch ~= nil and velocity_kmh <= environmentParameter[\"surfaceSpeedLow\"] and \n    round(telemeter.getDistance()) <= environmentParameter[\"surfaceDistanceLow\"] then \n    doorSwitch.activate()\nend\n\nunit.stopTimer('HUD')\n-- Darkwinde END: unit.start()","filter":{"args":[],"signature":"stop()","slotKey":"-1"},"key":50},{"code":"-- Darkwinde START: unit.start()\n\n\n-- Initiate Globals START\nversion = \"v0.2\"\ndescription = \" - Minimalistic HUD from Darkwinde & Expugnator\"\n\n\ngravity = 9.81 -- m/s²\nvelocity = vec3(core.getWorldVelocity()) -- m/s²\nvelocity_kmh = round(vec3(core.getVelocity()):len() * 3.6) -- m/s²\n\n\nhabitats = {'Atmosphere', 'Space', 'Spacedock'} -- Default environments\nsurfaceDistanceLow = {15, 5, 5}  -- m\nsurfaceDistanceLanding = {40, 20, 20} -- m\nsurfaceDistanceHigh = {80, 80, 80} -- m\nsurfaceSpeedLow = {1, 1, 1} -- m/s²\nenvironment = getEnvironmentName() -- Initialize environment name\nenvironmentID = getEnvironmentID() -- Initialize environment ID\n\n\nftoAtmo = 3 --export: Level of Atmospheric Fuel Tank Otimization\nftoSpace = 3 --export: Level of Space Fuel Tank Otimization\nftoRocket = 0 --export: Level of Rocket Fuel Tank Otimization\nmyFuelTanks = getFuelTanks() -- initialize fuel tanks\n\n\npayloadOverhead = 10 --export: Percentage safe factor to keep enougth trust to get from planet\nvtolPlane = false --export: Is your ship a vertical take-off and landing plane without gyroscope\n\n\nbtcAtmo = 3 --export: Level of Atmospheric Brake Thrust Control\nbhAtmo = 0 --export: Level of Atmospheric Brake Handling\nfehAtmo = 3 --export: Level of Atmospheric Flight Element Handling\n\n\nfirstStart = true -- Indicator to show correct HUD messages\nlockBrake = true --export: Default handbrake active \nsurfaceBrake = true -- Default handbrake near surface active\nsurfaceLow = true -- Default to initialize distance check near surface\nlanding = true -- Default to initialize distance check if landing\n\n\nhudMsgTimer = 5 --export: Message display timer\nhudHTMLMsg = {} -- Message variable\n-- Initiate Globals END\n\n-- Hide Default Panels START\nunit.hide() -- Hide unit (commander seat) widget\ncore.hide() -- Hide core widget\n_autoconf.hideCategoryPanels() -- Hide fuel tanks widget\n-- Hide Default Panels END\n\n\n-- Initiate Elements START\n-- Check for element existence\nlocal telemeterExists = false\ndoorSwitchSlotName = \"btnDoor\" --export: Slot name of button door switch\nfor slotname, slot in pairs(unit) do\n    -- Mandatory: Telemeter\n    if type(slot) == \"table\" and slot.getElementClass then\n        if slot.getElementClass():lower():find(\"telemeter\") and slotname == \"telemeter\" then\n            telemeterExists = true\n        end\n    end\n    \n    -- Optional: Door Switch\n    if slotname == doorSwitchSlotName then\n        doorSwitch = slot\n        doorSwitch.deactivate()\n    end\nend\n\n\n-- Display HUD critical message and initialize telemeter object with distance method\nif not telemeterExists then\n    setHTMLMessage(hudHTMLMsg, \"Telemeter missing!<br>Attach one to your flight seat!\", \"critical\")\n\n    telemeter = {}\n    function telemeter.getDistance()\n        return 0\n    end\nend\n\n\n-- Check for high speed and unlock handbrake on sit down\nif lockBrake and velocity_kmh > 50 then\n    lockBrake = not lockBrake\nend\n\n\n-- Initiate Elements END\n\n-- Initiate Timers START\nunit.setTimer('HUD', 1.5)\nunit.setTimer('FUEL', 5)\n-- Initiate Timers END\n\n\n-- Darkwinde END: unit.start()","filter":{"args":[],"signature":"start()","slotKey":"-1"},"key":51},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)\nNav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)\n","filter":{"args":[{"value":"up"}],"signature":"actionStop(up)","slotKey":"-2"},"key":"2"},{"code":"Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\nNav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)\n","filter":{"args":[{"value":"down"}],"signature":"actionStart(down)","slotKey":"-2"},"key":"3"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)\nNav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)\n","filter":{"args":[{"value":"down"}],"signature":"actionStop(down)","slotKey":"-2"},"key":"4"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)","filter":{"args":[{"value":"groundaltitudeup"}],"signature":"actionStart(groundaltitudeup)","slotKey":"-2"},"key":"5"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)","filter":{"args":[{"value":"groundaltitudedown"}],"signature":"actionStart(groundaltitudedown)","slotKey":"-2"},"key":"6"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)","filter":{"args":[{"value":"groundaltitudeup"}],"signature":"actionLoop(groundaltitudeup)","slotKey":"-2"},"key":"7"},{"code":"yawInput = yawInput - 1","filter":{"args":[{"value":"yawright"}],"signature":"actionStart(yawright)","slotKey":"-2"},"key":"8"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)","filter":{"args":[{"value":"groundaltitudedown"}],"signature":"actionLoop(groundaltitudedown)","slotKey":"-2"},"key":"9"},{"code":"rollInput = rollInput + 1","filter":{"args":[{"value":"right"}],"signature":"actionStart(right)","slotKey":"-2"},"key":"10"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)","filter":{"args":[{"value":"straferight"}],"signature":"actionStart(straferight)","slotKey":"-2"},"key":"11"},{"code":"rollInput = rollInput - 1","filter":{"args":[{"value":"right"}],"signature":"actionStop(right)","slotKey":"-2"},"key":"12"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)","filter":{"args":[{"value":"strafeleft"}],"signature":"actionStart(strafeleft)","slotKey":"-2"},"key":"13"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)","filter":{"args":[{"value":"straferight"}],"signature":"actionStop(straferight)","slotKey":"-2"},"key":"14"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)","filter":{"args":[{"value":"strafeleft"}],"signature":"actionStop(strafeleft)","slotKey":"-2"},"key":"15"},{"code":"Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\nNav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)\n","filter":{"args":[{"value":"up"}],"signature":"actionStart(up)","slotKey":"-2"},"key":"16"},{"code":"Nav:update()","filter":{"args":[],"signature":"update()","slotKey":"-2"},"key":"17"},{"code":"-- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu\n\nlocal pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01\nlocal brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)\nlocal autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01\n\nlocal turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is\nlocal turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\n-- validate params\npitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)\nyawSpeedFactor = math.max(yawSpeedFactor, 0.01)\nrollSpeedFactor = math.max(rollSpeedFactor, 0.01)\ntorqueFactor = math.max(torqueFactor, 0.01)\nbrakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)\nbrakeFlatFactor = math.max(brakeFlatFactor, 0.01)\nautoRollFactor = math.max(autoRollFactor, 0.01)\nturnAssistFactor = math.max(turnAssistFactor, 0.01)\n\n-- final inputs\nlocal finalPitchInput = pitchInput + system.getControlDeviceForwardInput()\nlocal finalRollInput = rollInput + system.getControlDeviceYawInput()\nlocal finalYawInput = yawInput - system.getControlDeviceLeftRightInput()\nlocal finalBrakeInput = brakeInput\n\n-- Axis\nlocal worldVertical = vec3(core.getWorldVertical()) -- along gravity\nlocal constructUp = vec3(core.getConstructWorldOrientationUp())\nlocal constructForward = vec3(core.getConstructWorldOrientationForward())\nlocal constructRight = vec3(core.getConstructWorldOrientationRight())\nlocal constructVelocity = vec3(core.getWorldVelocity())\nlocal constructVelocityDir = vec3(core.getWorldVelocity()):normalize()\nlocal currentRollDeg = getRoll(worldVertical, constructForward, constructRight)\nlocal currentRollDegAbs = math.abs(currentRollDeg)\nlocal currentRollDegSign = utils.sign(currentRollDeg)\n\n-- Rotation\nlocal constructAngularVelocity = vec3(core.getWorldAngularVelocity())\nlocal targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight\n                                + finalRollInput * rollSpeedFactor * constructForward\n                                + finalYawInput * yawSpeedFactor * constructUp\n\n-- In atmosphere?\nif worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then\n    local autoRollRollThreshold = 1.0\n    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling\n    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then\n        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit\n        if (rollPID == nil) then\n            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range\n        end\n        rollPID:inject(targetRollDeg - currentRollDeg)\n        local autoRollInput = rollPID:get()\n\n        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward\n    end\n    local turnAssistRollThreshold = 20.0\n    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing\n    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then\n        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range\n        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range\n\n        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)\n        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180\n        local rollVerticalRatio = 0\n        if rescaleRollDegAbs < 90 then\n            rollVerticalRatio = rescaleRollDegAbs / 90\n        elseif rescaleRollDegAbs < 180 then\n            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90\n        end\n\n        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio\n\n        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)\n        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio\n\n        targetAngularVelocity = targetAngularVelocity\n                            + turnAssistPitchInput * constructRight\n                            + turnAssistYawInput * constructUp\n    end\nend\n\n-- Engine commands\nlocal keepCollinearity = 1 -- for easier reading\nlocal dontKeepCollinearity = 0 -- for easier reading\nlocal tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities\n\n-- Rotation\nlocal angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)\nlocal airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())\nangularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction\nNav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)\n\n-- Brakes\nlocal brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)\nNav:setEngineForceCommand('brake', brakeAcceleration)\n\n-- AutoNavigation regroups all the axis command by 'TargetSpeed'\nlocal autoNavigationEngineTags = ''\nlocal autoNavigationAcceleration = vec3()\nlocal autoNavigationUseBrake = false\n\n-- Longitudinal Translation\nlocal longitudinalEngineTags = 'thrust analog longitudinal'\nlocal longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byThrottle) then\n    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)\n    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)\nelseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration\n    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop\n        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking\n    then\n        autoNavigationUseBrake = true\n    end\n\nend\n\n-- Lateral Translation\nlocal lateralStrafeEngineTags = 'thrust analog lateral'\nlocal lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)\nif (lateralCommandType == axisCommandType.byThrottle) then\n    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)\n    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)\nelseif  (lateralCommandType == axisCommandType.byTargetSpeed) then\n    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration\nend\n\n-- Vertical Translation\nlocal verticalStrafeEngineTags = 'thrust analog vertical'\nlocal verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)\nif (verticalCommandType == axisCommandType.byThrottle) then\n    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)\n    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)\nelseif  (verticalCommandType == axisCommandType.byTargetSpeed) then\n    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration\nend\n\n-- Auto Navigation (Cruise Control)\nif (autoNavigationAcceleration:len() > constants.epsilon) then\n    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward\n    then\n        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'\n    end\n    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)\nend\n\n-- Rockets\nNav:setBoosterCommand('rocket_engine')\n","filter":{"args":[],"signature":"flush()","slotKey":"-2"},"key":"18"},{"code":"gearExtended = not gearExtended\nif gearExtended then\n    Nav.control.extendLandingGears()\nelse\n    Nav.control.retractLandingGears()\nend\n","filter":{"args":[{"value":"gear"}],"signature":"actionStart(gear)","slotKey":"-2"},"key":"19"},{"code":"if Nav.control.isAnyHeadlightSwitchedOn() == 1 then\n    Nav.control.switchOffHeadlights()\nelse\n    Nav.control.switchOnHeadlights()\nend\n","filter":{"args":[{"value":"light"}],"signature":"actionStart(light)","slotKey":"-2"},"key":"20"},{"code":"pitchInput = pitchInput + 1","filter":{"args":[{"value":"forward"}],"signature":"actionStop(forward)","slotKey":"-2"},"key":"21"},{"code":"pitchInput = pitchInput - 1","filter":{"args":[{"value":"forward"}],"signature":"actionStart(forward)","slotKey":"-2"},"key":"22"},{"code":"pitchInput = pitchInput + 1","filter":{"args":[{"value":"backward"}],"signature":"actionStart(backward)","slotKey":"-2"},"key":"23"},{"code":"pitchInput = pitchInput - 1","filter":{"args":[{"value":"backward"}],"signature":"actionStop(backward)","slotKey":"-2"},"key":"24"},{"code":"rollInput = rollInput - 1","filter":{"args":[{"value":"left"}],"signature":"actionStart(left)","slotKey":"-2"},"key":"25"},{"code":"rollInput = rollInput + 1","filter":{"args":[{"value":"left"}],"signature":"actionStop(left)","slotKey":"-2"},"key":"26"},{"code":"if warpdrive ~= nil then warpdrive.activateWarp() end","filter":{"args":[{"value":"warp"}],"signature":"actionStart(warp)","slotKey":"-2"},"key":"27"},{"code":"Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)","filter":{"args":[{"value":"stopengines"}],"signature":"actionStart(stopengines)","slotKey":"-2"},"key":"28"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)","filter":{"args":[{"value":"speedup"}],"signature":"actionStart(speedup)","slotKey":"-2"},"key":"29"},{"code":"Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)","filter":{"args":[{"value":"speedup"}],"signature":"actionLoop(speedup)","slotKey":"-2"},"key":"30"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)","filter":{"args":[{"value":"speeddown"}],"signature":"actionStart(speeddown)","slotKey":"-2"},"key":"31"},{"code":"Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)","filter":{"args":[{"value":"speeddown"}],"signature":"actionLoop(speeddown)","slotKey":"-2"},"key":"32"},{"code":"if antigrav ~= nil then antigrav.toggle() end","filter":{"args":[{"value":"antigravity"}],"signature":"actionStart(antigravity)","slotKey":"-2"},"key":"33"},{"code":"yawInput = yawInput + 1","filter":{"args":[{"value":"yawright"}],"signature":"actionStop(yawright)","slotKey":"-2"},"key":"34"},{"code":"yawInput = yawInput + 1","filter":{"args":[{"value":"yawleft"}],"signature":"actionStart(yawleft)","slotKey":"-2"},"key":"35"},{"code":"yawInput = yawInput - 1","filter":{"args":[{"value":"yawleft"}],"signature":"actionStop(yawleft)","slotKey":"-2"},"key":"36"},{"code":"local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)\n    if (math.abs(targetSpeed) > constants.epsilon) then\n        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))\n    end\nend\n","filter":{"args":[{"value":"brake"}],"signature":"actionLoop(brake)","slotKey":"-2"},"key":"37"},{"code":"brakeInput = brakeInput - 1","filter":{"args":[{"value":"brake"}],"signature":"actionStop(brake)","slotKey":"-2"},"key":"38"},{"code":"brakeInput = brakeInput + 1\nlocal longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)\n    if (math.abs(targetSpeed) > constants.epsilon) then\n        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))\n    end\nend\n","filter":{"args":[{"value":"brake"}],"signature":"actionStart(brake)","slotKey":"-2"},"key":"39"},{"code":"Nav:toggleBoosters()","filter":{"args":[{"value":"booster"}],"signature":"actionStart(booster)","slotKey":"-2"},"key":"40"},{"code":"-- Darkwinde START: system.update()\n-- LandingGear\n-- >> Not allowed to have them in flush() anymore\nif landing and unit.isAnyLandingGearExtended() == 0 then\n    unit.extendLandingGears()\nelseif not landing and unit.isAnyLandingGearExtended() == 1 then\n    unit.retractLandingGears()\nend\n-- Darkwinde END: system.update()","filter":{"args":[],"signature":"update()","slotKey":"-2"},"key":44},{"code":"-- Darkwinde START: system.flush()\n-- Telemeter\n-- >> Distance can be between 1 and 100. \n-- >> Scripting Wiki for telemeter is wrong. For MaxDistance it is mentioned 20m\n-- >> !!! Telemeter even works (hidden) behind honeycomb\n-- system.print(telemeter.getDistance())\nlocal environmentParameter = getEnvironmentParameter(environmentID)\n\n\n-- Check if telemeter unit exists\nif telemeter ~= nil then\n    landing = telemeter.getDistance() > 0 and telemeter.getDistance() < environmentParameter[\"surfaceDistanceLanding\"]\n    surfaceLow = telemeter.getDistance() > 0 and telemeter.getDistance() <= environmentParameter[\"surfaceDistanceLow\"]\nend\n\n\n-- Set general altitude stabilization according to the environment\nif surfaceLow and unit.getSurfaceEngineAltitudeStabilization() ~= 0 and\n       unit.getSurfaceEngineAltitudeStabilization() ~= environmentParameter[\"surfaceDistanceLow\"] then\n    unit.activateGroundEngineAltitudeStabilization(environmentParameter[\"surfaceDistanceLow\"])\nend\n    \n\n-- Start and landing condition to stay on surface\nif lockBrake then\n    brakeInput = 1\n    \n    if surfaceLow then\n        unit.setEngineThrust(\"vertical thrust\", 0) -- default tags are in lower case and space seperated\n        unit.deactivateGroundEngineAltitudeStabilization()\n    end\nend\n\n\n\n-- Use brake to stabalize near ground level\nif surfaceBrake and surfaceLow then\n    brakeInput = 1\nelseif surfaceBrake and not surfaceLow then\n    surfaceBrake = false\n    brakeInput = 0\nelseif not surfaceBrake and surfaceLow then\n    surfaceBrake = true\n    brakeInput = 1\nend\n\n\n\n\n-- In space it is not necessary to use engine stabilization / maneuver engine at high speed\nif environmentID == 2 and velocity_kmh > 2000 then\n    unit.setEngineThrust(\"vertical thrust\", 0)\n    unit.deactivateGroundEngineAltitudeStabilization()\nend\n\n-- Darkwinde END: system.flush()","filter":{"args":[],"signature":"flush()","slotKey":"-2"},"key":45},{"code":"-- Darkwinde START: system.actionStart(option 1)\n-- >> Option 1 is by default ALT+1\n\n-- Take off script by releasing brake and setting altitude level\nlockBrake = not lockBrake\n\n\nif not lockBrake then\n    brakeInput = 0\n    \n    local environmentParameter = getEnvironmentParameter(environmentID)        \n    unit.setEngineThrust(\"vertical thrust\", 1) -- default tags are in lower case    \n    unit.activateGroundEngineAltitudeStabilization(environmentParameter[\"surfaceDistanceLow\"])\n \n    if firstStart then\n        setHTMLMessage(hudHTMLMsg, \"TAKE OFF \\n Have a nice flight!\")\n    end\nend\n\n\n\n\n-- Darkwinde END: system.actionStart(option 1)","filter":{"args":[{"value":"option1"}],"signature":"actionStart(action)","slotKey":"-2"},"key":46},{"code":"-- Darkwinde START: library.start()\n\n-- Generic Functions START\n\n-- Return dumped information in a humal readable string\nfunction dump(o)\n    if type(o) == 'table' then\n        local s = '{ '\n        for k,v in pairs(o) do\n            if type(k) ~= 'number' then \n                k = '\"' .. k .. '\"' \n            end\n            s = s .. '[' .. k .. '] = ' .. dump(v) .. ','\n        end\n        return s .. '} '\n    else\n        return tostring(o)\n    end\nend\n\n\n-- If condition is TRUE return variable T else variable F\n-- >> Used at feature: system.update() -> hudShowBrakeStatus\nfunction ternary(cond, T, F)\n    if cond ~= nil and cond then\n        return T\n    else\n        return F\n    end\nend\n\n\n\n-- Round float number to certain digits\nfunction round(num, numDecimalPlaces)\n    local mult = 10 ^ (numDecimalPlaces or 0)\n    if numDecimalPlaces ~= nil then\n        return math.floor(num * mult + 0.5) / mult\n    else\n        return math.floor((num * mult + 0.5) / mult)\n    end\nend\n\n-- Generic Functions END\n\n\n\n-- Getter & Setter START\n\n-- HTML header part for the HUD\nfunction getHTMLHeader()\n    PrimaryR = 130\n    PrimaryG = 224\n    PrimaryB = 255\n    rgb = [[rgb(]] .. math.floor(PrimaryR+0.5) .. \",\" .. math.floor(PrimaryG+0.5) .. \",\" .. math.floor(PrimaryB+0.5) .. [[)]]\n    rgbdim = [[rgb(]] .. math.floor(PrimaryR *0.9 + 0.5) .. \",\" .. math.floor(PrimaryG * 0.9 + 0.5) .. \",\" .. math.floor(PrimaryB * 0.9 + 0.5) .. [[)]]\n\n    local bright = rgb\n    local dim = rgbdim\n    local brightOrig = rgb\n    local dimOrig = rgbdim\n\n    \nlocal header =\nstring.format([[\n<head>\n<style>\n        body {margin:0}\n        svg {position:absolute; top:0; left:0; font-family:Montserrat;} \n        .line {stroke-width:2px; fill:none}\n        .linethick {stroke-width:3px; fill:none}\n        .bright {fill:%s; stroke:%s}\n        .pbright {fill:%s; stroke:%s}\n        .dim {fill:%s; stroke:%s}\n        .pdim {fill:%s; stroke:%s}\n        .red {fill:red; stroke:red}\n        .redout {fill:none; stroke:red}\n        .op30 {opacity:0.3}\n        .op10 {opacity:0.1}     \n        .txtstart {text -anchor:start}\n        .txtmid {text-anchor:middle}\n        .txtend {text-anchor:end}\n        .txtorb {font-size:12px}\n        .txtorbbig {font-size:18px}\n\n        .primary {font-size:0.8rem; color:#B6DFED;}\n        .primary2 {font-size:0.65rem; color:#B6DFED;}\n        .zen {display:flex; flex-direction:column;}\n        .controls-hud {top:25%%; right:0.7%%; position:absolute; display:flex; flex-direction:column; \n                       width:16%%; padding:0.5%% 0.8%%; overflow:none; justify-content:space-around; \n                       background-color:#34495E80; border-color:#333333; border-radius:12px;}\n        .control-container {display:flex; justify-content:space-between; padding:0.5%%; }\n        .category {color:#ffffff; font-size:1rem; text-align:center; margin:0.4rem;}\n        .spacer {margin-top:1rem; border-top:1px solid #ffffff;}\n        .on {background-color:red; margin-left:10px; border-radius:50%%; width:22px; \n             height:22px; border:2px solid black; text-align:center;}\n        .off {background-color:none; margin-left:10px; border-radius:50%%; width:22px; \n             height:22px; border:2px solid transparent; text-align:center;}\n        .msg {position:absolute; top:50%%; left:50%%; \n              -moz-transform:translateX(-50%%) translateY(-50%%);\n              -webkit-transform:translateX(-50%%) translateY(-50%%);\n              transform:translateX(-50%%) translateY(-50%%); text-align:center;}\n        .info {font-size:1.8rem; color:#B6DFED;}\n        .ok {font-size:2.5rem; color:green;}\n        .warning {font-size:2.5rem; color:yellow;}\n        .critical {font-size:3.5rem; color:red;}\n        .version {position:absolute; bottom:0; right:0; width:100%%; height:0.5rem; \n                  font-size:0.55rem; text-align:right;}\n</style>\n</head>\n<body>\n<svg height=\"100%%\" width=\"100%%\" viewBox=\"0 0 1920 1080\">\n]], bright, bright, brightOrig, brightOrig, dim, dim, dimOrig, dimOrig)\n    \n    \nreturn header\nend\n\n\n-- HTML footer part for the HUD\nfunction getHTMLFooter()\n    return  string.format([[</svg><div class=\"version\">%s %s</div></body>]], version, description)\nend\n\n\n-- HTML HUD message\nfunction setHTMLMessage(hudHTMLMsg, msg, msgtype)    \n    if msgtype == nil then\n        msgtype = \"info\"\n    end\n    \n    for str in string.gmatch(msg, \"([^\\n]+)\") do\n        hudHTMLMsg[#hudHTMLMsg + 1] = string.format([[<div class=\"%s\">%s</div>]], msgtype, str)\n    end\n    \n    unit.setTimer(\"HUDMsg\", hudMsgTimer)\nend  \n\n\n-- Get current environment information returned as ID or name\nfunction getEnvironmentID()\n    if unit.getAtmosphereDensity() > 0.1 then -- Atmo\n        return  1\n    elseif core.g() >= gravity then -- Spacedock\n        return 3\n    else -- Space\n        return 2\n    end\nend\nfunction getEnvironmentName(id)  \n    if id ~= nil then\n        return habitats[id]\n    end\n    \n    if unit.getAtmosphereDensity() > 0.1 then -- Atmo\n        return  habitats[1]\n    elseif core.g() >= gravity then -- Spacedock\n       return habitats[3]\n    else -- Space\n        return habitats[2]\n    end\nend\nfunction getEnvironmentParameter(id) \n    local returnValue = {}\n    \n    if id ~= nil then -- ID based\n        returnValue[\"habitat\"] = habitats[id]\n        returnValue[\"surfaceDistanceLow\"] = surfaceDistanceLow[id]\n        returnValue[\"surfaceDistanceLanding\"] = surfaceDistanceLanding[id]\n        returnValue[\"surfaceDistanceHigh\"] = surfaceDistanceHigh[id]\n        returnValue[\"surfaceSpeedLow\"] = surfaceSpeedLow[id]\n    else\n        if unit.getAtmosphereDensity() > 0.0 then -- Atmo\n            returnValue[\"habitat\"] = habitats[1]\n            returnValue[\"surfaceDistanceLow\"] = surfaceDistanceLow[1]\n            returnValue[\"surfaceDistanceLanding\"] = surfaceDistanceLanding[1]\n            returnValue[\"surfaceDistanceHigh\"] = surfaceDistanceHigh[1]\n            returnValue[\"surfaceSpeedLow\"] = surfaceSpeedLow[1]\n        elseif core.g() >= gravity then -- Spacedock\n            returnValue[\"habitat\"] = habitats[3] \n            returnValue[\"surfaceDistanceLow\"] = surfaceDistanceLow[3]\n            returnValue[\"surfaceDistanceLanding\"] = surfaceDistanceLanding[3]\n            returnValue[\"surfaceDistanceHigh\"] = surfaceDistanceHigh[3]\n            returnValue[\"surfaceSpeedLow\"] = surfaceSpeedLow[3]\n        else -- Space\n            returnValue[\"habitat\"] = habitats[2]\n            returnValue[\"surfaceDistanceLow\"] = surfaceDistanceLow[2]\n            returnValue[\"surfaceDistanceLanding\"] = surfaceDistanceLanding[2]\n            returnValue[\"surfaceDistanceHigh\"] = surfaceDistanceHigh[2]\n            returnValue[\"surfaceSpeedLow\"] = surfaceSpeedLow[2]\n        end \n    end\n\n    return returnValue\nend\n\n\nfunction getBrakeDistance(endingSpeed)\n    local returnValue = {}\n    local distance = 0;\n    local time = 0;\n    local c = 30000*1000/3600\n    local c2 = c*c\n\n    \n    local initialSpeed = vec3(core.getVelocity()):len() -- m/s\n    --local initialSpeed = 20000 / 3.6 -- m/s --> For Testing\n    endingSpeed = endingSpeed / 3.6 -- m/s\n    local restMass = round(core.getConstructMass()) -- kg\n    local maxBrake = json.decode(unit.getData()).maxBrake -- N\n    if maxBrake == nil then -- check if in Atmo, as unit does not contain information. Bug?!?\n        local airFriction = round(vec3(core.getWorldAirFrictionAcceleration()):len(), 5)\n        maxBrake = airFriction + getMaxBrakeAtmo() -- N\n    end\n    local totA = -maxBrake * (1-0)/restMass;\n\n    \n    if initialSpeed > endingSpeed then\n        local k1 = c * math.asin(initialSpeed / c)\n        local k2 = c2 * math.cos(k1 / c) / totA\n        time = (c * math.asin(endingSpeed / c) - k1) / totA\n        distance = k2 - c2 * math.cos((totA * time + k1) / c) / totA\n    end\n\n    \n    local min = math.floor(time / 60)   \n    local timeFrac = time - 60 * min\n    local sec = round(timeFrac)\n    local su = math.floor(distance / 200000)\n    local remainder = distance - 200000 * su\n    local suFrac = round(100 * remainder / 200000) / 100\n    local km = ternary(distance < 1000, round(distance / 1000, 3), round(distance / 1000))\n\n\n    returnValue[\"min\"] = string.format(\"%02d\", min)\n    returnValue[\"sec\"] = string.format(\"%02d\", sec)\n    returnValue[\"su\"] = su + suFrac\n    returnValue[\"km\"] = km\n    returnValue[\"time\"] = time\n    returnValue[\"distance\"] = distance\n\n\n    return returnValue\nend\n\n\n\natmoBrakes = {[\"S\"] = {[\"thrust\"]= 50000, [\"mass\"]= 55.55, [\"hp\"]= 50}, [\"M\"] = {[\"thrust\"]= 500000, [\"mass\"]= 285.25, [\"hp\"]= 50}, [\"L\"] = {[\"thrust\"]= 5000000, [\"mass\"]= 1500, [\"hp\"]= 767}}\nfunction getMaxBrakeAtmo()\n    local returnValue = 0\n    \n    -- Not realy cool, but works good as possible\n    -- unit.getData() should be fixed by NQ\n    -- Get atmospheric brake list from core\n    for _, el in ipairs(core.getElementIdList()) do\n        -- Get element information\n        local typ  = core.getElementTypeById(el):lower()\n        local name  = core.getElementNameById(el):lower()\n        local mass = core.getElementMassById(el)    \n        local hp = core.getElementMaxHitPointsById(el)\n        \n        \n        if typ == \"atmospheric airbrake\" then\n            -- Get brake parameter\n            local size = \"S\" -- default size     \n            if mass >= atmoBrakes[\"L\"][\"mass\"] then \n                size = \"L\"\n            elseif mass >= atmoBrakes[\"M\"][\"mass\"] then \n                size = \"M\"\n            end\n            \n            -- Apply atmospheric brake skills\n            local atmosphericBrakeThrustControl = atmoBrakes[size][\"thrust\"] * btcAtmo * 0.1\n            local atmosphericBrakeHandling = atmoBrakes[size][\"thrust\"] * bhAtmo * 0.1\n            local atmosphericFlightElementhandling = 1 + fehAtmo * 0.02\n            \n            returnValue = returnValue + (atmoBrakes[size][\"thrust\"] + atmosphericBrakeThrustControl + atmosphericBrakeHandling) * atmosphericFlightElementhandling\n        end\n\tend\n    \n    return returnValue\nend\n\n\n\n\n\n\n\nfuel = {[\"atmospheric fuel tank\"] = 4, [\"space fuel tank\"] = 6, [\"rocket fuel tank\"] = 0.8}\nfuelTanks = {[\"atmospheric fuel tank\"] = {[\"XS\"] = {[\"volume\"]= 100, [\"mass\"]= 35.03, [\"hp\"]= 50}, [\"S\"] = {[\"volume\"]= 400, [\"mass\"]= 182.67, [\"hp\"]= 163}, [\"M\"] = {[\"volume\"]= 1600, [\"mass\"]= 988.67, [\"hp\"]= 1315}, [\"L\"] = {[\"volume\"]= 12800, [\"mass\"]= 5480, [\"hp\"]= 10461}}, [\"space fuel tank\"] = {[\"S\"] = {[\"volume\"]= 400, [\"mass\"]= 182.67, [\"hp\"]= 187}, [\"M\"] = {[\"volume\"]= 1600, [\"mass\"]= 988.67, [\"hp\"]= 1496}, [\"L\"] = {[\"volume\"]= 12800, [\"mass\"]= 5480, [\"hp\"]= 15933}}, [\"rocket fuel tank\"] = {[\"XS\"] = {[\"volume\"]= 400, [\"mass\"]= 173.42, [\"hp\"]= 366}, [\"S\"] = {[\"volume\"]= 800, [\"mass\"]= 886.72, [\"hp\"]= 736}, [\"M\"] = {[\"volume\"]= 6400, [\"mass\"]= 4720, [\"hp\"]= 6231}, [\"L\"] = {[\"volume\"]= 50000, [\"mass\"]= 25740, [\"hp\"]= 68824}}}\nfunction getFuelTanks()\n    local returnValue = {}\n    \n    -- Get fuel tank list from core\n    for _, el in ipairs(core.getElementIdList()) do\n        -- Get element information\n        local typ  = core.getElementTypeById(el):lower()\n        local name  = core.getElementNameById(el):lower()\n        local mass = core.getElementMassById(el)    \n        local hp = core.getElementMaxHitPointsById(el)\n        local emptyMass, curMass, maxVolume, curVolume, consVolume, consTime = 0, 0, 0, 0, 0, \"0h:0m:0s\"\n        local curTime = system.getTime()\n        -- Define fuel tank skills for later use by reference\n        local fuelTankSkills = {[\"atmospheric fuel tank\"] = ftoAtmo, [\"space fuel tank\"] = ftoSpace, [\"rocket fuel tank\"] = ftoRocket}\n\n        -- Check if element is the one we are searching for (defined in the array)\n        if fuelTanks[typ] ~= nil then\n            -- Initialize array for later use\n            if returnValue[typ] == nil then\n                returnValue[typ] = {}\n            end\n\n            -- Get fuel tank parameter\n            local size = \"XS\" -- default size     \n            if hp >= fuelTanks[typ][\"L\"][\"hp\"] then \n                size = \"L\"\n            elseif hp >= fuelTanks[typ][\"M\"][\"hp\"] then \n                size = \"M\"\n            elseif hp >= fuelTanks[typ][\"S\"][\"hp\"] then \n                size = \"S\"\n            end\n\n            emptyMass = round(fuelTanks[typ][size][\"mass\"])\n            curMass = round(mass - emptyMass, 2)\n            maxVolume = round(fuelTanks[typ][size][\"volume\"])\n            curVolume = round(curMass / fuel[typ], 2)\n\n            -- Check and apply for fuel tank skills\n            if fuelTankSkills[typ] > 0 and fuelTankSkills[typ] ~= nil then\n                maxVolume = maxVolume * (1 + fuelTankSkills[typ] * 0.2)\n            end\n\n            -- Add fuel tank information to my personal list\n            returnValue[typ][#returnValue[typ] + 1] = {[\"id\"]=el, [\"name\"]=name, [\"maxvolume\"]=maxVolume, [\"curvolume\"]=curVolume, [\"emptymass\"]=emptyMass, [\"curmass\"]=curMass, [\"consvolume\"]=consVolume, [\"constime\"]=consTime, [\"time\"]=curTime}\n        end\n    end\n    \n    return returnValue\nend\n-- Getter & Setter END\n\n\n\n-- Appending Functions START\nfunction Navigator.maxForceUp(self)\n    local axisCRefDirection = vec3(self.core.getConstructOrientationUp())\n    local verticalEngineTags = 'thrust analog vertical not_ground'\n    local maxKPAlongAxis = self.core.getMaxKinematicsParametersAlongAxis(verticalEngineTags, {axisCRefDirection:unpack()})\n    if self.control.getAtmosphereDensity() == 0 then -- we are in space\n        return maxKPAlongAxis[3]\n    else\n        return maxKPAlongAxis[1]\n    end\nend\n-- Appending Functions END\n-- Darkwinde END: library.start()","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":"41"},{"code":"-- Expugnator START: library.start()\nfunction Atlas()\n    return {\n        [0] = {\n            [1]={\n                GM=6930729684,\n                bodyId=1,\n                center={x=17465536.000,y=22665536.000,z=-34464.000},\n                name='Madis',\n                planetarySystemId=0,\n                radius=44300,\n                surface=-1        \n            },\n            [2]={\n                GM=157470826617,\n                bodyId=2,\n                center={x=-8.000,y=-8.000,z=-126303.000},\n                name='Alioth',\n                planetarySystemId=0,\n                radius=126068,\n                surface=0\n            },\n            [3]={\n                GM=11776905000,\n                bodyId=3,\n                center={x=29165536.000,y=10865536.000,z=65536.000},\n                name='Thades',\n                planetarySystemId=0,\n                radius=49000,\n                surface=13600\n            },\n            [4]={\n                GM=14893847582,\n                bodyId=4,\n                center={x=-13234464.000,y=55765536.000,z=465536.000},\n                name='Talemai',\n                planetarySystemId=0,\n                radius=57450,\n                surface=-1\n            },\n            [5]={\n                GM=16951680000,\n                bodyId=5,\n                center={x=-43534464.000,y=22565536.000,z=-48934464.000},\n                name='Feli',\n                planetarySystemId=0,\n                radius=60000,\n                surface=-1\n            },\n            [6]={\n                GM=10502547741,\n                bodyId=6,\n                center={x=52765536.000,y=27165538.000,z=52065535.000},\n                name='Sicari',\n                planetarySystemId=0,\n                radius=51100,\n                surface=0\n            },\n            [7]={\n                GM=13033380591,\n                bodyId=7,\n                center={x=58665538.000,y=29665535.000,z=58165535.000},\n                name='Sinnen',\n                planetarySystemId=0,\n                radius=54950,\n                surface=400\n            },\n            [8]={\n                GM=18477723600,\n                bodyId=8,\n                center={x=80865538.000,y=54665536.000,z=-934463.940},\n                name='Teoma',\n                planetarySystemId=0,\n                radius=62000,\n                surface=-1\n            },\n            [9]={\n                GM=18606274330,\n                bodyId=9,\n                center={x=-94134462.000,y=12765534.000,z=-3634464.000},\n                name='Jago',\n                planetarySystemId=0,\n                radius=61590,\n                surface=-1\n            },\n            [10]={\n                GM=78480000,\n                bodyId=10,\n                center={x=17448118.224,y=22966846.286,z=143078.820},\n                name='Madis Moon 1',\n                planetarySystemId=0,\n                radius=10000,\n                surface=-1\n            },\n            [11]={\n                GM=237402000,\n                bodyId=11,\n                center={x=17194626.000,y=22243633.880,z=-214962.810},\n                name='Madis Moon 2',\n                planetarySystemId=0,\n                radius=11000,\n                surface=-1\n            },\n            [12]={\n                GM=265046609,\n                bodyId=12,\n                center={x=17520614.000,y=22184730.000,z=-309989.990},\n                name='Madis Moon 3',\n                planetarySystemId=0,\n                radius=15005,\n                surface=-1\n            },\n            [21]={\n                GM=2118960000,\n                bodyId=21,\n                center={x=457933.000,y=-1509011.000,z=115524.000},\n                name='Alioth Moon 1',\n                planetarySystemId=0,\n                radius=30000,\n                surface=-1\n            },\n            [22]={\n                GM=2165833514,\n                bodyId=22,\n                center={x=-1692694.000,y=729681.000,z=-411464.000},\n                name='Alioth Moon 4',\n                planetarySystemId=0,\n                radius=30330,\n                surface=-1\n            },\n            [26]={\n                GM=68234043600,\n                bodyId=26,\n                center={x=-1404835.000,y=562655.000,z=-285074.000},\n                name='Sanctuary',\n                planetarySystemId=0,\n                radius=83400,\n                surface=0\n            },\n            [30]={\n                GM=211564034,\n                bodyId=30,\n                center={x=29214402.000,y=10907080.695,z=433858.200},\n                name='Thades Moon 1',\n                planetarySystemId=0,\n                radius=14002,\n                surface=-1\n            },\n            [31]={\n                GM=264870000,\n                bodyId=31,\n                center={x=29404193.000,y=10432768.000,z=19554.131},\n                name='Thades Moon 2',\n                planetarySystemId=0,\n                radius=15000,\n                surface=-1\n            },\n            [40]={\n                GM=141264000,\n                bodyId=40,\n                center={x=-13503090.000,y=55594325.000,z=769838.640},\n                name='Talemai Moon 2',\n                planetarySystemId=0,\n                radius=12000,\n                surface=-1\n            },\n            [41]={\n                GM=106830900,\n                bodyId=41,\n                center={x=-12800515.000,y=55700259.000,z=325207.840},\n                name='Talemai Moon 3',\n                planetarySystemId=0,\n                radius=11000,\n                surface=-1\n            },\n            [42]={\n                GM=264870000,\n                bodyId=42,\n                center={x=-13058408.000,y=55781856.000,z=740177.760},\n                name='Talemai Moon 1',\n                planetarySystemId=0,\n                radius=15000,\n                surface=-1\n            },\n            [50]={\n                GM=499917600,\n                bodyId=50,\n                center={x=-43902841.780,y=22261034.700,z=-48862386.000},\n                name='Feli Moon 1',\n                planetarySystemId=0,\n                radius=14000,\n                surface=-1\n            },\n            [70]={\n                GM=396912600,\n                bodyId=70,\n                center={x=58969616.000,y=29797945.000,z=57969449.000},\n                name='Sinnen Moon 1',\n                planetarySystemId=0,\n                radius=17000,\n                surface=-1\n            },\n            [100]={\n                GM=13975172474,\n                bodyId=100,\n                center={x=98865536.000,y=-13534464.000,z=-934461.990},\n                name='Lacobus',\n                planetarySystemId=0,\n                radius=55650,\n                surface=-1\n            },\n            [101]={\n                GM=264870000,\n                bodyId=101,\n                center={x=98905288.170,y=-13950921.100,z=-647589.530},\n                name='Lacobus Moon 3',\n                planetarySystemId=0,\n                radius=15000,\n                surface=-1\n            },\n            [102]={\n                GM=444981600,\n                bodyId=102,\n                center={x=99180968.000,y=-13783862.000,z=-926156.400},\n                name='Lacobus Moon 1',\n                planetarySystemId=0,\n                radius=18000,\n                surface=-1\n            },\n            [103]={\n                GM=211503600,\n                bodyId=103,\n                center={x=99250052.000,y=-13629215.000,z=-1059341.400},\n                name='Lacobus Moon 2',\n                planetarySystemId=0,\n                radius=14000,\n                surface=-1\n            },\n            [110]={\n                GM=9204742375,\n                bodyId=110,\n                center={x=14165536.000,y=-85634465.000,z=-934464.300},\n                name='Symeon',\n                planetarySystemId=0,\n                radius=49050,\n                surface=-1\n            },\n            [120]={\n                GM=7135606629,\n                bodyId=120,\n                center={x=2865536.700,y=-99034464.000,z=-934462.020},\n                name='Ion',\n                planetarySystemId=0,\n                radius=44950,\n                surface=-1\n            },\n            [121]={\n                GM=106830900,\n                bodyId=121,\n                center={x=2472916.800,y=-99133747.000,z=-1133582.800},\n                name='Ion Moon 1',\n                planetarySystemId=0,\n                radius=11000,\n                surface=-1\n            },\n            [122]={\n                GM=176580000,\n                bodyId=122,\n                center={x=2995424.500,y=-99275010.000,z=-1378480.700},\n                name='Ion Moon 2',\n                planetarySystemId=0,\n                radius=15000,\n                surface=-1\n            }  \n        }\n    }\nend\n\n--[[ \nProvides methods for computing orbital information for an object\n\nUsage:\nKepler = require('autoconf.custom.kepler')\nalioth = Kepler({ GM=157470826617,\nbodyId=2,\ncenter={x=-8.000,y=-8.000,z=-126303.000},\nname='Alioth',\nplanetarySystemId=0,\nradius=126068\n})\naltitude = 6000\nposition = '::pos{0,2,0,0,6000}'\n\ne, o     = alioth:escapeAndOrbitalSpeed(altitude)\norbit    = alioth:orbitalParameters(position, {0, o+1, 0})\n\nprint(\"Eccentricity \" .. orbit.eccentricity)\nprint(\"Perihelion \" .. orbit.periapsis.altitude)\nprint(\"Max. speed \" .. orbit.periapsis.speed)\nprint(\"Circular orbit speed \" .. orbit.periapsis.circularOrbitSpeed)\nprint(\"Aphelion \"  .. orbit.apoapsis.altitude)\nprint(\"Min. speed \" .. orbit.apoapsis.speed)\nprint(\"Orbital period \" .. orbit.period)\n--- output:\nEccentricity 0.0018324307017878\nPerihelion 6000.0\nMax. speed 1092.9462297033\nCircular orbit speed 1091.9462297033\nAphelion 6484.8994605062\nMin. speed 1088.9480596194\nOrbital period 762.02818214049\n\nMethods:\nKepler:escapeAndOrbitalSpeed - for a given celestial body and altitude.\nKepler:orbitalParameters - for a given massless object and a celestial body.\n\nDescription\nThe motion of an object in the vicinity of substantially larger mass is\nin the domain of the \"2-body problem\". By assuming the object whose motion\nis of interest is of negligable mass simplifies the calculations of:\nthe speed to escape the body, the speed of a circular orbit, and the\nparameters defining the orbit of the object (or the lack of orbit as the\ncase may be).\n\nOrbital Parameters:\nperiapsis - the closest approach to the planet\napoapsis - the furthest point from the planet if in orbit (otherwise nil)\neccentricity - 0 for circular orbits\n<1 for elliptical orbits\n1 for parabiolic trajectory\n>1 for hyperbolic trajectory\nperiod - time (in seconds) to complete an orbit\n\nAlso See: planetref.lua\n]]--\n\nfunction Keplers()\n    local vec3       = require('cpml.vec3')\n    local PlanetRef  = PlanetRef()\n\n    local function isString(s) return type(s)   == 'string' end\n    local function isTable(t)  return type(t)   == 'table'  end\n\n    local function float_eq(a,b)\n        if a == 0 then return math.abs(b) < 1e-09 end\n        if b == 0 then return math.abs(a) < 1e-09 end\n        return math.abs(a - b) < math.max(math.abs(a),math.abs(b))*epsilon\n    end\n\n\n    Kepler = {}\n    Kepler.__index = Kepler\n\n    --\n    -- escapeAndOrbitalSpeed - speed required to escape and for a circular orbit\n    -- altitude [in]: the height of the orbit in meters above \"sea-level\"\n    -- return: the speed in m/s needed to escape the celestial body and to orbit it.\n    --\n    function Kepler:escapeAndOrbitalSpeed(altitude)\n        assert(self.body)\n        -- P = -GMm/r and KE = mv^2/2 (no lorentz factor used)\n        -- mv^2/2 = GMm/r\n        -- v^2 = 2GM/r\n        -- v = sqrt(2GM/r1)\n        local distance = altitude + self.body.radius\n\n        if not float_eq(distance, 0) then\n            local orbit = math.sqrt(self.body.GM/distance)\n            return math.sqrt(2)*orbit, orbit\n        end\n        return nil, nil\n    end\n\n    --\n    -- orbitalParameters: determine the orbital elements for a two-body system.\n    -- overload [in]: the world coordinates or map coordinates of a massless object.\n    -- velocity [in]: The velocity of the massless point object in m/s.\n    -- return: the 6 orbital elements for the massless object.\n    --\n    function Kepler:orbitalParameters(overload, local_velocity)\n        assert(self.body)\n        assert(isTable(overload) or isString(overload))\n        assert(isTable(local_velocity))\n        local pos = (isString(overload) or PlanetRef.isMapPosition(overload)) and\n        self.body:convertToWorldCoordinates(overload) or\n        vec3(overload)\n        local v   = vec3(local_velocity)\n        local r   = pos - self.body.center\n        local v2  = v:len2()\n        local d   = r:len()\n        local mu  = self.body.GM\n        local e   = ((v2 - mu/d)*r - r:dot(v)*v)/mu\n        local a   = mu/(2*mu/d - v2)\n\n        local ecc = e:len()\n        local dir = e:normalize()\n        local pd  = a*(1-ecc)\n        local ad  = a*(1+ecc)\n        local per = pd*dir + self.body.center\n        local apo = ecc <= 1 and -ad*dir + self.body.center or nil\n        local trm = math.sqrt(a*mu*(1-ecc*ecc))\n        local Period = apo and 2*math.pi*math.sqrt(a^3/mu)\n\n        local trueAnomaly = math.acos((e:dot(r))/(ecc*d))\n\n        if r:dot(v) < 0 then\n            trueAnomaly = -(trueAnomaly - 2*math.pi)\n        end \n\n        local EccentricAnomaly = math.acos((math.cos(trueAnomaly) + ecc)/(1 + ecc * math.cos(trueAnomaly)))\n\n        local timeTau = EccentricAnomaly\n        if timeTau < 0 then\n            timeTau = timeTau + 2*math.pi\n        end  \n\n        local MeanAnomaly = timeTau - ecc * math.sin(timeTau)\n        local TimeSincePeriapsis = 0\n        local TimeToPeriapsis = 0\n        local TimeToApoapsis = 0\n\n\n        if Period ~= nil then\n            TimeSincePeriapsis = MeanAnomaly/(2*math.pi/Period)\n\n            TimeToPeriapsis = Period - TimeSincePeriapsis\n            TimeToApoapsis = TimeToPeriapsis + Period/2\n            if trueAnomaly - math.pi > 0 then -- TBH I think something's wrong in my formulas because I needed this.\n                TimeToPeriapsis = TimeSincePeriapsis\n                TimeToApoapsis = TimeToPeriapsis + Period/2\n            end\n            if TimeToApoapsis > Period then\n                TimeToApoapsis = TimeToApoapsis - Period\n            end\n        end\n        return { periapsis       = { position           = per,\n                speed              = trm/pd,\n                circularOrbitSpeed = math.sqrt(mu/pd),\n                altitude           = pd - self.body.radius},\n            apoapsis        = apo and\n            { position           = apo,\n                speed              = trm/ad,\n                circularOrbitSpeed = math.sqrt(mu/ad),\n                altitude           = ad - self.body.radius\n            },\n            currentVelocity = v,\n            currentPosition = pos,\n            eccentricity    = ecc,\n            period          = Period,\n            eccentricAnomaly = EccentricAnomaly,\n            meanAnomaly = MeanAnomaly,\n            timeToPeriapsis = TimeToPeriapsis,\n            timeToApoapsis = TimeToApoapsis\n        }\n    end\n\n    local function new(bodyParameters)\n        local params = PlanetRef.BodyParameters(bodyParameters.planetarySystemId,\n            bodyParameters.bodyId,\n            bodyParameters.radius,\n            bodyParameters.center,\n            bodyParameters.GM)\n        return setmetatable({body = params}, Kepler)\n    end\n\n    return setmetatable(Kepler, { __call = function(_,...) return new(...) end })\n\nend\n\n--[[ \nDualUniverse kinematic equations\nAuthor: JayleBreak\n\nUsage (unit.start):\nKinematics = require('autoconf.custom.kinematics')\n\nMethods:\ncomputeAccelerationTime - \"relativistic\" version of t = (vf - vi)/a\ncomputeDistanceAndTime - Return distance & time needed to reach final speed.\ncomputeTravelTime - \"relativistic\" version of t=(sqrt(2ad+v^2)-v)/a\n\nDescription\nDualUniverse increases the effective mass of constructs as their absolute\nspeed increases by using the \"lorentz\" factor (from relativity) as the scale\nfactor.  This results in an upper bound on the absolute speed of constructs\n(excluding \"warp\" drive) that is set to 30 000 KPH (8 333 MPS). This module\nprovides utilities for computing some physical quantities taking this\nscaling into account.\n]]--\n\nfunction Kinematics()\n    local Kinematic = {} -- just a namespace\n\n    local C       = 30000000/3600\n    local C2      = C*C\n    local ITERATIONS = 100 -- iterations over engine \"warm-up\" period\n\n    local function lorentz(v) return 1/math.sqrt(1 - v*v/C2) end\n\n    --\n    -- computeAccelerationTime - \"relativistic\" version of t = (vf - vi)/a\n    -- initial      [in]: initial (positive) speed in meters per second.\n    -- acceleration [in]: constant acceleration until 'finalSpeed' is reached.\n    -- final        [in]: the speed at the end of the time interval.\n    -- return: the time in seconds spent in traversing the distance\n    --\n    function Kinematic.computeAccelerationTime(initial, acceleration, final)\n        -- The low speed limit of following is: t=(vf-vi)/a (from: vf=vi+at)\n        local k1 = C*math.asin(initial/C)\n        return (C * math.asin(final/C) - k1)/acceleration\n    end\n\n    --\n    -- computeDistanceAndTime - Return distance & time needed to reach final speed.\n    -- initial[in]:     Initial speed in meters per second.\n    -- final[in]:       Final speed in meters per second.\n    -- restMass[in]:    Mass of the construct at rest in Kg.\n    -- thrust[in]:      Engine's maximum thrust in Newtons.\n    -- t50[in]:         (default: 0) Time interval to reach 50% thrust in seconds.\n    -- brakeThrust[in]: (default: 0) Constant thrust term when braking.\n    -- return: Distance (in meters), time (in seconds) required for change.\n    --\n    function Kinematic.computeDistanceAndTime(initial,\n            final,\n            restMass,\n            thrust,\n            t50,\n            brakeThrust)\n        -- This function assumes that the applied thrust is colinear with the\n        -- velocity. Furthermore, it does not take into account the influence\n        -- of gravity, not just in terms of its impact on velocity, but also\n        -- its impact on the orientation of thrust relative to velocity.\n        -- These factors will introduce (usually) small errors which grow as\n        -- the length of the trip increases.\n        t50            = t50 or 0\n        brakeThrust    = brakeThrust or 0 -- usually zero when accelerating\n\n        local tau0     = lorentz(initial)\n        local speedUp  = initial <= final\n        local a0       = thrust * (speedUp and 1 or -1)/restMass\n        local b0       = -brakeThrust/restMass\n        local totA     = a0+b0\n\n        if speedUp and totA <= 0 or not speedUp and totA >= 0 then\n            return -1, -1 -- no solution\n        end\n\n        local distanceToMax, timeToMax = 0, 0\n\n        -- If, the T50 time is set, then assume engine is at zero thrust and will\n        -- reach full thrust in 2*T50 seconds. Thrust curve is given by:\n        -- Thrust: F(z)=(a0*(1+sin(z))+2*b0)/2 where z=pi*(t/t50 - 1)/2\n        -- Acceleration is given by F(z)/m(z) where m(z) = m/sqrt(1-v^2/c^2)\n        -- or v(z)' = (a0*(1+sin(z))+2*b0)*sqrt(1-v(z)^2/c^2)/2\n\n        if a0 ~= 0 and t50 > 0 then\n            -- Closed form solution for velocity exists:\n            -- v(t) = -c*tan(w)/sqrt(tan(w)^2+1) => w = -asin(v/c)\n            -- w=(pi*t*(a0/2+b0)-a0*t50*sin(pi*t/2/t50)+*pi*c*k1)/pi/c\n            -- @ t=0, v(0) = vi\n            -- pi*c*k1/pi/c = -asin(vi/c)\n            -- k1 = asin(vi/c)\n            local k1  = math.asin(initial/C)\n\n            local c1  = math.pi*(a0/2+b0)\n            local c2  = a0*t50\n            local c3  = C*math.pi\n\n            local v = function(t)\n                local w  = (c1*t - c2*math.sin(math.pi*t/2/t50) + c3*k1)/c3\n                local tan = math.tan(w)\n                return C*tan/math.sqrt(tan*tan+1)\n            end\n\n            local speedchk = speedUp and function(s) return s >= final end or\n            function(s) return s <= final end\n            timeToMax  = 2*t50\n\n            if speedchk(v(timeToMax)) then\n                local lasttime = 0\n\n                while math.abs(timeToMax - lasttime) > 0.5 do\n                    local t = (timeToMax + lasttime)/2\n                    if speedchk(v(t)) then\n                        timeToMax = t \n                    else\n                        lasttime = t\n                    end\n                end\n            end\n\n            -- There is no closed form solution for distance in this case.\n            -- Numerically integrate for time t=0 to t=2*T50 (or less)\n            local lastv = initial\n            local tinc  = timeToMax/ITERATIONS\n\n            for step = 1, ITERATIONS do\n                local speed = v(step*tinc)\n                distanceToMax = distanceToMax + (speed+lastv)*tinc/2\n                lastv = speed\n            end\n\n            if timeToMax < 2*t50 then\n                return distanceToMax, timeToMax\n            end\n            initial = lastv\n        end\n        -- At full thrust, acceleration only depends on the Lorentz factor:\n        -- v(t)' = (F/m(v)) = a*sqrt(1-v(t)^2/c^2) where a = a0+b0\n        -- -> v = c*sin((at+k1)/c)\n        -- @ t=0, v=vi: k1 = c*asin(vi/c)\n        -- -> t = (c*asin(v/c) - k1)/a\n        -- x(t)' = c*sin((at+k1)/c)\n        -- x = k2 - c^2 cos((at+k1)/c)/a\n        -- @ t=0, x=0: k2 = c^2 * cos(k1/c)/a\n        local k1       = C*math.asin(initial/C)\n        local time     = (C * math.asin(final/C) - k1)/totA\n\n        local k2       = C2 *math.cos(k1/C)/totA\n        local distance = k2 - C2 * math.cos((totA*time + k1)/C)/totA\n\n        return distance+distanceToMax, time+timeToMax\n    end\n\n    --\n    -- computeTravelTime - \"relativistic\" version of t=(sqrt(2ad+v^2)-v)/a\n    -- initialSpeed [in]: initial (positive) speed in meters per second\n    -- acceleration [in]: constant acceleration until 'distance' is traversed\n    -- distance [in]: the distance traveled in meters\n    -- return: the time in seconds spent in traversing the distance\n    --\n    function Kinematic.computeTravelTime(initial, acceleration, distance)\n        -- The low speed limit of following is: t=(sqrt(2ad+v^2)-v)/a\n        -- (from: d=vt+at^2/2)\n        if distance == 0 then return 0 end\n\n        if acceleration > 0 then\n            local k1       = C*math.asin(initial/C)\n            local k2       = C2*math.cos(k1/C)/acceleration\n            return (C*math.acos(acceleration*(k2 - distance)/C2) - k1)/acceleration\n        end\n        assert(initial > 0, 'Acceleration and initial speed are both zero.')\n        return distance/initial\n    end\n\n    function Kinematic.lorentz(v) return lorentz(v) end\n\n    return Kinematic\nend    \n\n\n--[[ \nProvide coordinate transforms and access to kinematic related parameters\nAuthor: JayleBreak\n\nUsage (unit.start):\nPlanetaryReference = require('planetref')\ngalaxyReference = PlanetaryReference(referenceTableSource)\nhelios = galaxyReference[0] -- PlanetaryReference.PlanetarySystem instance\nalioth = helios[2]          -- PlanetaryReference.BodyParameters instance\n\nMethods:\nPlanetaryReference:getPlanetarySystem - based on planetary system ID.\nPlanetaryReference.isMapPosition - 'true' if an instance of 'MapPosition'\nPlanetaryReference.createBodyParameters - for entry into reference table\nPlanetaryReference.BodyParameters - a class containing a body's information.\nPlanetaryReference.MapPosition - a class for map coordinates\nPlanetaryReference.PlanetarySystem - a container for planetary system info.\n\nPlanetarySystem:castIntersections - from a position in a given direction.\nPlanetarySystem:closestBody - to the specified coordinates.\nPlanetarySystem:convertToBodyIdAndWorldCoordinates - from map coordinates.\nPlanetarySystem:getBodyParameters - from reference table.\nPlanetarySystem:getPlanetarySystemId - for the instance.\n\nBodyParameters:convertToWorldCoordinates - from map coordinates\nBodyParameters:convertToMapPosition - from world coordinates\nBodyParameters:getAltitude - of world coordinates\nBodyParameters:getDistance - from center to world coordinates\nBodyParameters:getGravity - at a given position in world coordinates.\n\nDescription\nAn instance of the 'PlanetaryReference' \"class\" can contain transform and\nkinematic reference information for all planetary systems in DualUniverse.\nEach planetary system is identified by a numeric identifier. Currently,\nthe only planetary system, Helios, has the identifier: zero. This \"class\"\nsupports the indexing ('[]') operation which is equivalent to the\nuse of the 'getPlanetarySystem' method. It also supports the 'pairs()'\nmethod for iterating over planetary systems.\n\nAn instance of the 'PlanetarySystem' \"class\" contains all reference\ninformation for a specific system. It supports the indexing ('[]') and\n'pairs()' functions which allows iteration over each \"body\" in the\nsystem where the key is the numeric body ID. It also supports the\n'tostring()' method.\n\nAn instance of the 'BodyParameters' \"class\" contains all reference\ninformation for a single celestial \"body\" (a moon or planet). It supports\nthe 'tostring()' method, and contains the data members:\nplanetarySystemId - numeric planetary system ID\nbodyId            - numeric body ID\nradius            - radius of the body in meters (zero altitude)\ncenter            - world coordinates of the body's center position\nGM                - the gravitation parameter (g = GM/radius^2)\nNote that the user is allowed to add custom fields (e.g. body name), but\nshould insure that complex table values have the '__tostring' metamethod\nimplemented.\n\nTransform and Kinematics:\n\"World\" coordinates is a cartesian coordinate system with an origin at an\narbitrary fixed point in a planetary system and with distances measured in\nmeters. The coordinates are expressible either as a simple table of 3 values\nor an instance of the 'vec3' class.  In either case, the planetary system\nidentity is implicit.\n\n\"Map\" coordinates is a geographic coordinate system with an origin at the\ncenter of an identified (by a numeric value) celestial body which is a\nmember of an identified (also a numeric value) planetary system. Note that\nthe convention that latitude, longitude, and altitude values will be the\nposition's x, y, and z world coordinates in the special case of body ID 0.\n\nThe kinematic parameters in the reference data permit calculations of the\ngravitational attraction of the celestial body on other objects.\n\nReference Data:\nThis is an example of reference data with a single entry assigned to\nplanetary system ID 0, and body ID 2 ('Alioth'):\nreferenceTable = {\n[0] = { [2] = { planetarySystemId = 0,\nbodyId = 2,\nradius = 126068,\ncenter = vec3({x=-8, y=-8, z=-126303}),\nGM = 1.572199+11 } -- as in F=-GMm/r^2\n}\n}\nref=PlanetaryReference(referenceTable)\n\nCollecting Reference Data:\nA combination of information from the \"Map\" screen in the DU user interface,\nand values reported by the DU Lua API can be the source of the reference\ntable's data (planetarySystemId, bodyId, and surfaceArea is from the user\ninterface):\nreferenceTable = {}\nreferenceTable[planetarySystemId][bodyId] =\nPlanetaryReference.createBodyParameters(planetarySystemId,\nbodyId,\nsurfaceArea,\ncore.getConstructWorldPos(),\ncore.getWorldVertical(),\ncore.getAltitude(),\ncore.g())\n\n\nAdapting Data Sources:\nOther sources of data can be adapted or converted. An example of adapting a\ntable, defined in the file: 'planets.lua', containing information on a single\nplanetary system and using celestial body name as the key follows (note that\na 'name' field is added to the BodyParameters instance transparently after\nconstruction, and the '__pairs' meta function is required to support the\n'closestBody' and '__tostring' methods):\nref=PlanetaryReference(\n{[0] = setmetatable(require('planets'),\n{ __index = function(bodies, bodyId)\nfor _,v in pairs(bodies) do\nif v and v.bodyId == bodyId then return v end\nend\nreturn nil\nend,\n__pairs = function(bodies)\nreturn function(t, k)\nlocal nk, nv = next(t, k)\nif nv then\nlocal GM = nv.gravity * nv.radius^2\nlocal bp = BodyParameters(0,\nnv.id,\nnv.radius,\nnv.pos,\nGM)\nbp.name = nk\nreturn nk, bp\nend\nreturn nk, nv\nend, bodies, nil\nend })\n})\n\nConverting Data Sources:\nAn instance of 'PlanetaryReference' that has been adapted to a data source\ncan be used to convert that source to simple table. For example,\nusing the adapted instance shown above:\nload('convertedData=' .. tostring(ref))()\nnewRef=PlanetaryReference(convertedData)\n\nAlso See: kepler.lua\n]]--\n\n--[[                    START OF LOCAL IMPLEMENTATION DETAILS             ]]--\n\n-- Type checks\n\nfunction PlanetRef() \n    local function isNumber(n)  return type(n)           == 'number' end\n    local function isSNumber(n) return type(tonumber(n)) == 'number' end\n    local function isTable(t)   return type(t)           == 'table'  end\n    local function isString(s)  return type(s)           == 'string' end\n    local function isVector(v)  return isTable(v)\n        and isNumber(v.x and v.y and v.z) end\n\n    local function isMapPosition(m) return isTable(m) and isNumber(m.latitude  and\n            m.longitude and\n            m.altitude  and\n            m.bodyId    and\n            m.systemId) end\n\n    -- Constants\n\n    local deg2rad    = math.pi/180\n    local rad2deg    = 180/math.pi\n    local epsilon    = 1e-10\n    local num        = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'\n    local posPattern = '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' ..\n    num ..  ',' .. num .. '}'\n\n    -- Utilities\n\n    local utils  = require('cpml.utils')\n    local vec3   = require('cpml.vec3')\n    local clamp  = utils.clamp\n\n    local function float_eq(a,b)\n        if a == 0 then return math.abs(b) < 1e-09 end\n        if b == 0 then return math.abs(a) < 1e-09 end\n        return math.abs(a - b) < math.max(math.abs(a),math.abs(b))*epsilon\n    end\n\n    local function formatNumber(n)\n        local result = string.gsub(\n            string.reverse(string.format('%.4f',n)),\n            '^0*%.?','')\n        return result == '' and '0' or string.reverse(result)\n    end\n\n    local function formatValue(obj)\n        if isVector(obj) then\n            return string.format('{x=%.3f,y=%.3f,z=%.3f}', obj.x, obj.y, obj.z)\n        end\n\n        if isTable(obj) and not getmetatable(obj) then\n            local list = {}\n            local nxt  = next(obj)\n\n            if type(nxt) == 'nil' or nxt == 1 then -- assume this is an array\n                list = obj\n            else\n                for k,v in pairs(obj) do\n                    local value = formatValue(v)\n                    if type(k) == 'number' then\n                        table.insert(list, string.format('[%s]=%s', k, value))\n                    else\n                        table.insert(list, string.format('%s=%s',   k, value))\n                    end\n                end\n            end\n            return string.format('{%s}', table.concat(list, ','))\n        end\n\n        if isString(obj) then\n            return string.format(\"'%s'\", obj:gsub(\"'\",[[\\']]))\n        end\n        return tostring(obj)\n    end\n\n\n    -- CLASSES\n\n    -- BodyParameters: Attributes of planetary bodies (planets and moons)\n\n    local BodyParameters = {}\n    BodyParameters.__index = BodyParameters\n    BodyParameters.__tostring =\n    function(obj, indent)\n        local sep = indent or ''\n        local keys = {}\n        for k in pairs(obj) do table.insert(keys, k) end\n        table.sort(keys)\n        local list = {}\n        for _, k in ipairs(keys) do\n            local value = formatValue(obj[k])\n            if type(k) == 'number' then\n                table.insert(list, string.format('[%s]=%s', k, value))\n            else\n                table.insert(list, string.format('%s=%s', k, value))\n            end\n        end\n        if indent then\n            return string.format('%s%s',\n                indent,\n                table.concat(list, ',\\n' .. indent))\n        end\n        return string.format('{%s}', table.concat(list, ','))\n    end\n    BodyParameters.__eq = function(lhs, rhs)\n        return lhs.planetarySystemId == rhs.planetarySystemId and\n        lhs.bodyId            == rhs.bodyId            and\n        float_eq(lhs.radius, rhs.radius)               and\n        float_eq(lhs.center.x, rhs.center.x)           and\n        float_eq(lhs.center.y, rhs.center.y)           and\n        float_eq(lhs.center.z, rhs.center.z)           and\n        float_eq(lhs.GM, rhs.GM)\n    end\n\n    local function mkBodyParameters(systemId, bodyId, radius, worldCoordinates, GM)\n        -- 'worldCoordinates' can be either table or vec3\n        assert(isSNumber(systemId),\n            'Argument 1 (planetarySystemId) must be a number:' .. type(systemId))\n        assert(isSNumber(bodyId),\n            'Argument 2 (bodyId) must be a number:' .. type(bodyId))\n        assert(isSNumber(radius),\n            'Argument 3 (radius) must be a number:' .. type(radius))\n        assert(isTable(worldCoordinates),\n            'Argument 4 (worldCoordinates) must be a array or vec3.' ..\n            type(worldCoordinates))\n        assert(isSNumber(GM),\n            'Argument 5 (GM) must be a number:' .. type(GM))\n        return setmetatable({planetarySystemId = tonumber(systemId),\n                bodyId            = tonumber(bodyId),\n                radius            = tonumber(radius),\n                center            = vec3(worldCoordinates),\n                GM                = tonumber(GM) }, BodyParameters)\n    end\n\n    -- MapPosition: Geographical coordinates of a point on a planetary body.\n\n    local MapPosition = {}\n    MapPosition.__index = MapPosition\n    MapPosition.__tostring = function(p)\n        return string.format('::pos{%d,%d,%s,%s,%s}',\n            p.systemId,\n            p.bodyId,\n            formatNumber(p.latitude*rad2deg),\n            formatNumber(p.longitude*rad2deg),\n            formatNumber(p.altitude))\n    end\n    MapPosition.__eq       = function(lhs, rhs)\n        return lhs.bodyId   == rhs.bodyId              and\n        lhs.systemId == rhs.systemId            and\n        float_eq(lhs.latitude,   rhs.latitude)  and\n        float_eq(lhs.altitude,   rhs.altitude)  and\n        (float_eq(lhs.longitude, rhs.longitude) or\n            float_eq(lhs.latitude, math.pi/2)      or\n            float_eq(lhs.latitude, -math.pi/2))\n    end\n\n    -- latitude and longitude are in degrees while altitude is in meters\n\n    local function mkMapPosition(overload, bodyId, latitude, longitude, altitude)\n        local systemId = overload -- Id or '::pos{...}' string\n\n        if isString(overload) and not longitude and not altitude and\n            not bodyId    and not latitude then\n            systemId, bodyId, latitude, longitude, altitude =\n            string.match(overload, posPattern)\n            assert(systemId, 'Argument 1 (position string) is malformed.')\n        else\n            assert(isSNumber(systemId),\n                'Argument 1 (systemId) must be a number:' .. type(systemId))\n            assert(isSNumber(bodyId),\n                'Argument 2 (bodyId) must be a number:' .. type(bodyId))\n            assert(isSNumber(latitude),\n                'Argument 3 (latitude) must be in degrees:' .. type(latitude))\n            assert(isSNumber(longitude),\n                'Argument 4 (longitude) must be in degrees:' .. type(longitude))\n            assert(isSNumber(altitude),\n                'Argument 5 (altitude) must be in meters:' .. type(altitude))\n        end\n        systemId  = tonumber(systemId)\n        bodyId    = tonumber(bodyId)\n        latitude  = tonumber(latitude)\n        longitude = tonumber(longitude)\n        altitude  = tonumber(altitude)\n\n        if bodyId == 0 then -- this is a hack to represent points in space\n            return setmetatable({latitude  = latitude,\n                    longitude = longitude,\n                    altitude  = altitude,\n                    bodyId    = bodyId,\n                    systemId  = systemId}, MapPosition)\n        end\n        return setmetatable({latitude  = deg2rad*clamp(latitude, -90, 90),\n                longitude = deg2rad*(longitude % 360),\n                altitude  = altitude,\n                bodyId    = bodyId,\n                systemId  = systemId}, MapPosition)\n    end\n\n    -- PlanetarySystem - map body IDs to BodyParameters\n\n    local PlanetarySystem = {}\n    PlanetarySystem.__index = PlanetarySystem\n\n    PlanetarySystem.__tostring =\n    function (obj, indent)\n        local sep = indent and (indent .. '  ' )\n        local bdylist = {}\n        local keys = {}\n        for k in pairs(obj) do table.insert(keys, k) end\n        table.sort(keys)\n        for _, bi in ipairs(keys) do\n            bdy = obj[bi]\n            local bdys = BodyParameters.__tostring(bdy, sep)\n            if indent then\n                table.insert(bdylist,\n                    string.format('[%s]={\\n%s\\n%s}',\n                        bi, bdys, indent))\n            else\n                table.insert(bdylist, string.format('  [%s]=%s', bi, bdys))\n            end\n        end\n        if indent then\n            return string.format('\\n%s%s%s',\n                indent,\n                table.concat(bdylist, ',\\n' .. indent),\n                indent)\n        end\n        return string.format('{\\n%s\\n}', table.concat(bdylist, ',\\n'))\n    end\n\n    local function mkPlanetarySystem(referenceTable)\n        local atlas = {}\n        local pid\n        for _, v in pairs(referenceTable) do\n            local id = v.planetarySystemId\n\n            if type(id) ~= 'number' then\n                error('Invalid planetary system ID: ' .. tostring(id))\n            elseif pid and id ~= pid then\n                error('Mismatch planetary system IDs: ' .. id .. ' and '\n                    .. pid)\n            end\n            local bid = v.bodyId\n            if type(bid) ~= 'number' then\n                error('Invalid body ID: ' .. tostring(bid))\n            elseif atlas[bid] then\n                error('Duplicate body ID: ' .. tostring(bid))\n            end\n            setmetatable(v.center, getmetatable(vec3.unit_x))\n            atlas[bid] = setmetatable(v, BodyParameters)\n            pid = id\n        end\n        return setmetatable(atlas, PlanetarySystem)\n    end\n\n    -- PlanetaryReference - map planetary system ID to PlanetarySystem\n\n    PlanetaryReference = {}\n\n    local function mkPlanetaryReference(referenceTable)\n        return setmetatable({ galaxyAtlas = referenceTable or {} },\n            PlanetaryReference)\n    end\n\n    PlanetaryReference.__index        = \n    function(t,i)\n        if type(i) == 'number' then\n            local system = t.galaxyAtlas[i]\n            return mkPlanetarySystem(system)\n        end\n        return rawget(PlanetaryReference, i)\n    end\n    PlanetaryReference.__pairs        =\n    function(obj)\n        return  function(t, k)\n            local nk, nv = next(t, k)\n            return nk, nv and mkPlanetarySystem(nv)\n        end, obj.galaxyAtlas, nil\n    end\n    PlanetaryReference.__tostring     =\n    function (obj)\n        local pslist = {}\n        for _,ps in pairs(obj or {}) do\n            local psi = ps:getPlanetarySystemId()\n            local pss = PlanetarySystem.__tostring(ps, '    ')\n            table.insert(pslist,\n                string.format('  [%s]={%s\\n  }', psi, pss))\n        end\n        return string.format('{\\n%s\\n}\\n', table.concat(pslist,',\\n'))\n    end\n\n\n    --[[                       START OF PUBLIC INTERFACE                       ]]--\n\n\n    -- PlanetaryReference CLASS METHODS:\n\n    --\n    -- BodyParameters - create an instance of BodyParameters class\n    -- planetarySystemId  [in]: the body's planetary system ID.\n    -- bodyId             [in]: the body's ID.\n    -- radius             [in]: the radius in meters of the planetary body.\n    -- bodyCenter         [in]: the world coordinates of the center (vec3 or table).\n    -- GM                 [in]: the body's standard gravitational parameter.\n    -- return: an instance of BodyParameters class.\n    --\n    PlanetaryReference.BodyParameters = mkBodyParameters\n\n    --\n    -- MapPosition - create an instance of the MapPosition class\n    -- overload [in]: either a planetary system ID or a position string ('::pos...')\n    -- bodyId [in]:   (ignored if overload is a position string) the body's ID.\n    -- latitude [in]: (ignored if overload is a position string) the latitude.\n    -- longitude [in]:(ignored if overload is a position string) the longitude.\n    -- altitude [in]: (ignored if overload is a position string) the altitude.\n    -- return: the class instance\n    --\n    PlanetaryReference.MapPosition    = mkMapPosition\n\n    --\n    -- PlanetarySystem - create an instance of PlanetarySystem class\n    -- referenceData [in]: a table (indexed by bodyId) of body reference info.\n    -- return: the class instance\n    --\n    PlanetaryReference.PlanetarySystem = mkPlanetarySystem\n\n    --\n    -- createBodyParameters - create an instance of BodyParameters class\n    -- planetarySystemId  [in]: the body's planetary system ID.\n    -- bodyId             [in]: the body's ID.\n    -- surfaceArea        [in]: the body's surface area in square meters.\n    -- aPosition          [in]: world coordinates of a position near the body.\n    -- verticalAtPosition [in]: a vector pointing towards the body center.\n    -- altitudeAtPosition [in]: the altitude in meters at the position.\n    -- gravityAtPosition  [in]: the magnitude of the gravitational acceleration.\n    -- return: an instance of BodyParameters class.\n    --\n    function PlanetaryReference.createBodyParameters(planetarySystemId,\n            bodyId,\n            surfaceArea,\n            aPosition,\n            verticalAtPosition,\n            altitudeAtPosition,\n            gravityAtPosition)\n        assert(isSNumber(planetarySystemId),\n            'Argument 1 (planetarySystemId) must be a number:' ..\n            type(planetarySystemId))\n        assert(isSNumber(bodyId),\n            'Argument 2 (bodyId) must be a number:' .. type(bodyId))\n        assert(isSNumber(surfaceArea),\n            'Argument 3 (surfaceArea) must be a number:' .. type(surfaceArea))\n        assert(isTable(aPosition),\n            'Argument 4 (aPosition) must be an array or vec3:' ..\n            type(aPosition))\n        assert(isTable(verticalAtPosition),\n            'Argument 5 (verticalAtPosition) must be an array or vec3:' ..\n            type(verticalAtPosition))\n        assert(isSNumber(altitudeAtPosition),\n            'Argument 6 (altitude) must be in meters:' ..\n            type(altitudeAtPosition))\n        assert(isSNumber(gravityAtPosition),\n            'Argument 7 (gravityAtPosition) must be number:' ..\n            type(gravityAtPosition))\n        local radius   = math.sqrt(surfaceArea/4/math.pi)\n        local distance = radius + altitudeAtPosition\n        local center   = vec3(aPosition) + distance*vec3(verticalAtPosition)\n        local GM       = gravityAtPosition * distance * distance\n        return mkBodyParameters(planetarySystemId, bodyId, radius, center, GM)\n    end\n\n    --\n    -- isMapPosition - check for the presence of the 'MapPosition' fields\n    -- valueToTest [in]: the value to be checked\n    -- return: 'true' if all required fields are present in the input value\n    --\n    PlanetaryReference.isMapPosition  = isMapPosition\n\n    -- PlanetaryReference INSTANCE METHODS:\n\n    --\n    -- getPlanetarySystem - get the planetary system using ID or MapPosition as key\n    -- overload [in]: either the planetary system ID or a MapPosition that has it.\n    -- return: instance of 'PlanetarySystem' class or nil on error\n    --\n    function PlanetaryReference:getPlanetarySystem(overload)\n        if self.galaxyAtlas then\n            local planetarySystemId = overload\n\n            if isMapPosition(overload) then\n                planetarySystemId = overload.systemId\n            end\n\n            if type(planetarySystemId) == 'number' then\n                local system = self.galaxyAtlas[i]\n                if system then\n                    if getmetatable(nv) ~= PlanetarySystem then\n                        system = mkPlanetarySystem(system)\n                    end\n                    return system\n                end\n            end\n        end\n        return nil\n    end\n\n    -- PlanetarySystem INSTANCE METHODS:\n\n    --\n    -- castIntersections - Find the closest body that intersects a \"ray cast\".\n    -- origin [in]: the origin of the \"ray cast\" in world coordinates\n    -- direction [in]: the direction of the \"ray cast\" as a 'vec3' instance.\n    -- sizeCalculator [in]: (default: returns 1.05*radius) Returns size given body.\n    -- bodyIds[in]: (default: all IDs in system) check only the given IDs.\n    -- return: The closest body that blocks the cast or 'nil' if none.\n    --\n    function PlanetarySystem:castIntersections(origin,\n            direction,\n            sizeCalculator,\n            bodyIds)\n        local sizeCalculator = sizeCalculator or \n        function (body) return 1.05*body.radius end\n        local candidates = {}\n\n        if bodyIds then\n            for _,i in ipairs(bodyIds) do candidates[i] = self[i] end\n        else\n            bodyIds = {}\n            for k,body in pairs(self) do\n                table.insert(bodyIds, k)\n                candidates[k] = body\n            end\n        end\n        local function compare(b1,b2)\n            local v1 = candidates[b1].center - origin\n            local v2 = candidates[b2].center - origin\n            return v1:len() < v2:len()\n        end\n        table.sort(bodyIds, compare)\n        local dir = direction:normalize()\n\n        for i, id in ipairs(bodyIds) do\n            local body   = candidates[id]\n            local c_oV3  = body.center - origin\n            local radius = sizeCalculator(body)\n            local dot    = c_oV3:dot(dir)\n            local desc   = dot^2 - (c_oV3:len2() - radius^2)\n\n            if desc >= 0 then\n                local root     = math.sqrt(desc)\n                local farSide  = dot + root\n                local nearSide = dot - root\n                if nearSide > 0 then\n                    return body, farSide, nearSide\n                elseif farSide > 0 then\n                    return body, farSide, nil\n                end\n            end\n        end\n        return nil, nil, nil\n    end\n\n    --\n    -- closestBody - find the closest body to a given set of world coordinates\n    -- coordinates       [in]: the world coordinates of position in space\n    -- return: an instance of the BodyParameters object closest to 'coordinates'\n    --\n    function PlanetarySystem:closestBody(coordinates)\n        assert(type(coordinates) == 'table', 'Invalid coordinates.')\n        local minDistance2, body\n        local coord = vec3(coordinates)\n\n        for _,params in pairs(self) do\n            local distance2 = (params.center - coord):len2()\n            if not body or distance2 < minDistance2 then\n                body         = params\n                minDistance2 = distance2\n            end\n        end\n        return body\n    end\n\n    --\n    -- convertToBodyIdAndWorldCoordinates - map to body Id and world coordinates\n    -- overload [in]: an instance of MapPosition or a position string ('::pos...)\n    -- return: a vec3 instance containing the world coordinates or 'nil' on error.\n    --\n    function PlanetarySystem:convertToBodyIdAndWorldCoordinates(overload)\n        local mapPosition = overload\n        if isString(overload) then\n            mapPosition = mkMapPosition(overload)\n        end\n\n        if mapPosition.bodyId == 0 then\n            return 0, vec3(mapPosition.latitude,\n                mapPosition.longitude,\n                mapPosition.altitude)\n        end\n        local params = self:getBodyParameters(mapPosition)\n\n        if params then\n            return mapPosition.bodyId,\n            params:convertToWorldCoordinates(mapPosition)\n        end\n    end\n\n    --\n    -- getBodyParameters - get or create an instance of BodyParameters class\n    -- overload [in]: either an instance of MapPosition or a body's ID.\n    -- return: a BodyParameters instance or 'nil' if body ID is not found.\n    --\n    function PlanetarySystem:getBodyParameters(overload)\n        local bodyId = overload\n\n        if isMapPosition(overload) then\n            bodyId = overload.bodyId\n        end\n        assert(isSNumber(bodyId),\n            'Argument 1 (bodyId) must be a number:' .. type(bodyId))\n\n        return self[bodyId]\n    end\n\n    --\n    -- getPlanetarySystemId - get the planetary system ID for this instance\n    -- return: the planetary system ID or nil if no planets are in the system.\n    --\n    function PlanetarySystem:getPlanetarySystemId()\n        local k, v = next(self)\n        return v and v.planetarySystemId\n    end\n\n    -- BodyParameters INSTANCE METHODS:\n\n    --\n    -- convertToMapPosition - create an instance of MapPosition from coordinates\n    -- worldCoordinates [in]: the world coordinates of the map position.\n    -- return: an instance of MapPosition class\n    --\n    function BodyParameters:convertToMapPosition(worldCoordinates)\n        assert(isTable(worldCoordinates),\n            'Argument 1 (worldCoordinates) must be an array or vec3:' ..\n            type(worldCoordinates))\n        local worldVec  = vec3(worldCoordinates) \n\n        if self.bodyId == 0 then\n            return setmetatable({latitude  = worldVec.x,\n                    longitude = worldVec.y,\n                    altitude  = worldVec.z,\n                    bodyId    = 0,\n                    systemId  = self.planetarySystemId}, MapPosition)\n        end\n        local coords    = worldVec - self.center\n        local distance  = coords:len()\n        local altitude  = distance - self.radius\n        local latitude  = 0\n        local longitude = 0\n\n        if not float_eq(distance, 0) then\n            local phi = math.atan(coords.y, coords.x)\n            longitude = phi >= 0 and phi or (2*math.pi + phi)\n            latitude  = math.pi/2 - math.acos(coords.z/distance)\n        end\n        return setmetatable({latitude  = latitude,\n                longitude = longitude,\n                altitude  = altitude,\n                bodyId    = self.bodyId,\n                systemId  = self.planetarySystemId}, MapPosition)\n    end\n\n    --\n    -- convertToWorldCoordinates - convert a map position to world coordinates\n    -- overload [in]: an instance of MapPosition or a position string ('::pos...')\n    --\n    function BodyParameters:convertToWorldCoordinates(overload)\n        local mapPosition = isString(overload) and\n        mkMapPosition(overload) or overload\n        if mapPosition.bodyId == 0 then -- support deep space map position\n            return vec3(mapPosition.latitude,\n                mapPosition.longitude,\n                mapPosition.altitude)\n        end\n        assert(isMapPosition(mapPosition),\n            'Argument 1 (mapPosition) is not an instance of \"MapPosition\".')\n        assert(mapPosition.systemId == self.planetarySystemId,\n            'Argument 1 (mapPosition) has a different planetary system ID.')\n        assert(mapPosition.bodyId == self.bodyId,\n            'Argument 1 (mapPosition) has a different planetary body ID.')\n        local xproj = math.cos(mapPosition.latitude)\n        return self.center + (self.radius + mapPosition.altitude) *\n        vec3(xproj*math.cos(mapPosition.longitude),\n            xproj*math.sin(mapPosition.longitude),\n            math.sin(mapPosition.latitude))\n    end\n\n    --\n    -- getAltitude - calculate the altitude of a point given in world coordinates.\n    -- worldCoordinates [in]: the world coordinates of the point.\n    -- return: the altitude in meters\n    --\n    function BodyParameters:getAltitude(worldCoordinates)\n        return (vec3(worldCoordinates) - self.center):len() - self.radius\n    end\n\n    --\n    -- getDistance - calculate the distance to a point given in world coordinates.\n    -- worldCoordinates [in]: the world coordinates of the point.\n    -- return: the distance in meters\n    --\n    function BodyParameters:getDistance(worldCoordinates)\n        return (vec3(worldCoordinates) - self.center):len()\n    end\n\n    --\n    -- getGravity - calculate the gravity vector induced by the body.\n    -- worldCoordinates [in]: the world coordinates of the point.\n    -- return: the gravity vector in meter/seconds^2\n    --\n    function BodyParameters:getGravity(worldCoordinates)\n        local radial = self.center - vec3(worldCoordinates) -- directed towards body\n        local len2   = radial:len2()\n        return (self.GM/len2) * radial/math.sqrt(len2)\n    end\n\n    -- end of module\n\n    return setmetatable(PlanetaryReference,\n        { __call = function(_,...)\n                return mkPlanetaryReference(...)\n            end })\nend\n\n\n\n\n\nMaxGameVelocity = 8333.05\nfunction getSpeedDisplayString(speed) \n    return math.floor(round(speed*3.6,0)+0.5) .. \" km/h\" \nend\n\nfunction getDistanceDisplayString(distance)\n    local su = distance > 100000\n    local result = \"\"\n    if su then\n        -- Convert to SU\n        result = round(distance/1000/200,1) .. \" SU\"\n    elseif distance < 1000 then\n        result = round(distance,1) .. \" M\"\n    else\n        -- Convert to KM\n        result = round(distance/1000,1) .. \" KM\"\n    end\n    return result\nend\n\nfunction FormatTimeString(seconds)\n    local hours = math.floor(seconds/3600)\n    local minutes = math.floor(seconds/60%60)\n    local seconds = math.floor(seconds%60)\n    if seconds < 0 or hours < 0 or minutes < 0 then\n        return \"0s\"\n    end\n    if hours > 0 then \n        return hours .. \"h \" .. minutes .. \"m \" .. seconds .. \"s\"\n    elseif minutes > 0 then\n        return minutes .. \"m \" ..seconds..\"s\"\n    else\n        return seconds..\"s\"\n    end\nend\n\nfunction orbitinterface()\n    newContent = {}\n    PlanetaryReference = PlanetRef()\n    galaxyReference = PlanetaryReference(Atlas())\n    Kinematic = Kinematics()\n    Kep = Keplers()\n\n    sys = galaxyReference[0]\n    planet = sys:closestBody(core.getConstructWorldPos())\n    kepPlanet = Kep(planet)\n    orbit = kepPlanet:orbitalParameters(core.getConstructWorldPos(), velocity)\n\n    if orbit ~= nil and unit.getAtmosphereDensity() < 0.2 and planet ~= nil and orbit.period ~= nil and\n        (orbit.periapsis ~= nil or orbit.apoapsis ~= nil) then\n        -- If orbits are up, let's try drawing a mockup\n        local orbitMapX = 75\n        local orbitMapY = 0\n        local orbitMapSize = 250 -- Always square\n        local pad = 4\n        orbitMapY = orbitMapY + pad                        \n        local orbitInfoYOffset = 15\n        local x = orbitMapX + orbitMapSize + orbitMapX/2 + pad\n        local y = orbitMapY + orbitMapSize/2 + 5 + pad\n        local rx, ry, scale, xOffset\n        rx = orbitMapSize/4\n        xOffset = 0\n\n        newContent[#newContent + 1] = [[<g class=\"pbright txtorb txtmid\">]]\n        -- Draw a darkened box around it to keep it visible\n        newContent[#newContent + 1] = string.format('<rect width=\"%f\" height=\"%d\" rx=\"10\" ry=\"10\" x=\"%d\" y=\"%d\" style=\"fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;\" />', orbitMapSize+orbitMapX*2, orbitMapSize+orbitMapY, pad, pad)\n        if orbit.periapsis ~= nil and orbit.apoapsis ~= nil then\n            scale = (orbit.apoapsis.altitude + orbit.periapsis.altitude + planet.radius*2)/(rx*2)\n            ry = (planet.radius + orbit.periapsis.altitude + (orbit.apoapsis.altitude - orbit.periapsis.altitude)/2)/scale * (1-orbit.eccentricity)\n            xOffset = rx - orbit.periapsis.altitude/scale - planet.radius/scale\n            local ellipseColor = \"\"\n            if orbit.periapsis.altitude <= 0 then\n                ellipseColor = 'redout'\n            end\n            newContent[#newContent + 1] = string.format([[<ellipse class=\"%s line\" cx=\"%f\" cy=\"%f\" rx=\"%f\" ry=\"%f\"/>]], ellipseColor, orbitMapX + orbitMapSize/2 + xOffset + pad, orbitMapY + orbitMapSize/2 + pad, rx, ry)\n            newContent[#newContent + 1] = string.format('<circle cx=\"%f\" cy=\"%f\" r=\"%f\" stroke=\"white\" stroke-width=\"3\" fill=\"blue\" />', orbitMapX + orbitMapSize/2 + pad, orbitMapY + orbitMapSize/2 + pad, planet.radius/scale) \n        end\n        if orbit.apoapsis ~= nil and orbit.apoapsis.speed < MaxGameVelocity and orbit.apoapsis.speed > 0 then\n            newContent[#newContent + 1] = string.format([[<line class=\"pdim op30 linethick\" x1=\"%f\" y1=\"%f\" x2=\"%f\" y2=\"%f\"/>]],x - 35, y-5, orbitMapX + orbitMapSize/2 + rx + xOffset, y-5)\n            newContent[#newContent + 1] = string.format([[<text x=\"%f\" y=\"%f\">Apoapsis</text>]], x, y)\n            y  = y + orbitInfoYOffset\n            newContent[#newContent + 1] = string.format([[<text x=\"%f\" y=\"%f\">%s</text>]], x, y,  getDistanceDisplayString(orbit.apoapsis.altitude))\n            y  = y + orbitInfoYOffset          \n            newContent[#newContent + 1] = string.format([[<text x=\"%f\" y=\"%f\">%s</text>]], x, y, FormatTimeString(orbit.timeToApoapsis))\n            y  = y + orbitInfoYOffset\n            newContent[#newContent + 1] = string.format([[<text x=\"%f\" y=\"%f\">%s</text>]], x, y, getSpeedDisplayString(orbit.apoapsis.speed))\n        end\n        y = orbitMapY + orbitMapSize/2 + 5 + pad\n        x = orbitMapX - orbitMapX/2+10 + pad\n        if orbit.periapsis ~= nil and orbit.periapsis.speed < MaxGameVelocity and orbit.periapsis.speed > 0 then\n            newContent[#newContent + 1] = string.format([[<line class=\"pdim op30 linethick\" x1=\"%f\" y1=\"%f\" x2=\"%f\" y2=\"%f\"/>]], x + 35, y-5, orbitMapX + orbitMapSize/2 - rx + xOffset, y-5)\n            newContent[#newContent + 1] = string.format([[<text x=\"%f\" y=\"%f\">Periapsis</text>]], x, y)\n            y  = y + orbitInfoYOffset\n            newContent[#newContent + 1] = string.format([[<text x=\"%f\" y=\"%f\">%s</text>]], x, y,  getDistanceDisplayString(orbit.periapsis.altitude))\n            y  = y + orbitInfoYOffset\n            newContent[#newContent + 1] = string.format([[<text x=\"%f\" y=\"%f\">%s</text>]], x, y, FormatTimeString(orbit.timeToPeriapsis))\n            y  = y + orbitInfoYOffset\n            newContent[#newContent + 1] = string.format([[<text x=\"%f\" y=\"%f\">%s</text>]], x, y, getSpeedDisplayString(orbit.periapsis.speed))\n        end\n        -- Add a label for the planet\n        newContent[#newContent + 1] = string.format([[<text class=\"txtorbbig\" x=\"%f\" y=\"%d\">%s</text>]], orbitMapX + orbitMapSize/2 + pad, 20 + pad, planet.name)\n        if orbit.period ~= nil and orbit.periapsis ~= nil and orbit.apoapsis ~= nil then\n            local apsisRatio = (orbit.timeToApoapsis/orbit.period) * 2 * math.pi\n            -- x = xr * cos(t)\n            -- y = yr * sin(t)\n            local shipX = rx * math.cos(apsisRatio)\n            local shipY = ry * math.sin(apsisRatio)\n            newContent[#newContent + 1] = string.format('<circle cx=\"%f\" cy=\"%f\" r=\"5\" stroke=\"white\" stroke-width=\"3\" fill=\"white\" />', orbitMapX + orbitMapSize/2 + shipX + xOffset + pad, orbitMapY + orbitMapSize/2 + shipY + pad)\n        end\n        newContent[#newContent + 1] = [[</g></svg>]]\n        -- Once we have all that, we should probably rotate the entire thing so that the ship is always at the bottom so you can see AP and PE move?\n    end\n\n    return table.concat(newContent, \"\")\nend\n-- Expugnator END: library.start()","filter":{"args":[],"signature":"start()","slotKey":"-3"},"key":43}],"methods":[],"events":[]}