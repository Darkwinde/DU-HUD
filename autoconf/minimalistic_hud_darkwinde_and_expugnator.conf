# Dual Universe Minimalistic HUD from Darkwinde & Expugnator
# Source: https://github.com/Darkwinde/DU-HUD


name: HUD from Darkwinde & Expugnator (v0.3.1)

slots:
    core:
        class: CoreUnit
    antigrav:
        class: AntiGravityGeneratorUnit
    warpdrive:
        class: WarpDriveUnit
    telemeter:
        class: TelemeterUnit

handlers:
    unit:
        start:
            lua: |
                -- category panel display helpers
                _autoconf = {}
                _autoconf.panels = {}
                _autoconf.panels_size = 0
                _autoconf.displayCategoryPanel = function(elements, size, title, type, widgetPerData)
                    widgetPerData = widgetPerData or false -- default to one widget for all data
                    if size > 0 then
                        local panel = system.createWidgetPanel(title)
                        local widget
                        if not widgetPerData then
                            widget = system.createWidget(panel, type)
                        end
                        for i = 1, size do
                            if widgetPerData then
                                widget = system.createWidget(panel, type)
                            end
                            system.addDataToWidget(elements[i].getDataId(), widget)
                        end
                        _autoconf.panels_size = _autoconf.panels_size + 1
                        _autoconf.panels[_autoconf.panels_size] = panel
                    end
                end
                _autoconf.hideCategoryPanels = function()
                    for i=1,_autoconf.panels_size do
                        system.destroyWidgetPanel(_autoconf.panels[i])
                    end
                end
                -- Proxy array to access auto-plugged slots programmatically

                atmofueltank = {}
                atmofueltank_size = 0

                spacefueltank = {}
                spacefueltank_size = 0

                rocketfueltank = {}
                rocketfueltank_size = 0

                weapon = {}
                weapon_size = 0

                radar = {}
                radar_size = 0
                -- End of auto-generated code
                pitchInput = 0
                rollInput = 0
                yawInput = 0
                brakeInput = 0

                Nav = Navigator.new(system, core, unit)
                Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})
                Nav.axisCommandManager:setTargetGroundAltitude(4)
                
                -- element widgets
                -- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.
                _autoconf.displayCategoryPanel(weapon, weapon_size, L_TEXT("ui_lua_widget_weapon", "Weapons"), "weapon", true)
                core.show()
                _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_periscope", "Periscope"), "periscope")
                placeRadar = true
                if atmofueltank_size > 0 then
                    _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"), "fuel_container")
                    if placeRadar then
                        _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                        placeRadar = false
                    end
                end
                if spacefueltank_size > 0 then
                    _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"), "fuel_container")
                    if placeRadar then
                        _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                        placeRadar = false
                    end
                end
                _autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"), "fuel_container")
                if placeRadar then -- We either have only rockets or no fuel tanks at all, uncommon for usual vessels
                    _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                    placeRadar = false
                end
                if antigrav ~= nil then antigrav.show() end
                if warpdrive ~= nil then warpdrive.show() end
                if gyro ~= nil then gyro.show() end

                -- freeze the player in he is remote controlling the construct
                if Nav.control.isRemoteControlled() == 1 then
                    system.freeze(1)
                end

                -- landing gear
                -- make sure every gears are synchonized with the first
                gearExtended = (Nav.control.isAnyLandingGearExtended() == 1) -- make sure it's a lua boolean
                if gearExtended then
                    Nav.control.extendLandingGears()
                else
                    Nav.control.retractLandingGears()
                end
        stop:
            lua: |
                _autoconf.hideCategoryPanels()
                if antigrav ~= nil then antigrav.hide() end
                if warpdrive ~= nil then warpdrive.hide() end
                if gyro ~= nil then gyro.hide() end
                core.hide()
                Nav.control.switchOffHeadlights()

    unit:
        start:
            lua: |
                -- Darkwinde START: unit.start()
                -- Initiate Globals START
                init()
                -- Initiate Globals END



                -- Initiate Personal Parameter START
                coo = 4 --export: Level of Container Optimization (Mining & Inventory) - 5% mass put down reduction per level
                fto = 3 --export: Level of Fuel Tank Optimization (Mining & Inventory) - 5% mass put down reduction per level
                fthAtmo = 3 --export: Level of Atmospheric Fuel Tank Handling (Piloting) - 20% more volume put down increase per level 
                fthSpace = 3 --export: Level of Space Fuel Tank Tank Handling (Piloting) - 20% more volume put down increase per level 
                fthRocket = 0 --export: Level of Rocket Fuel Tank Tank Handling (Piloting) - 20% more volume put down increase per level

                payloadOverhead = 25 --export: Percentage safe factor to keep enougth trust to get from planet
                vtolPlane = false --export: Is your ship a vertical take-off and landing plane without gyroscope

                btcAtmo = 3 --export: Level of Atmospheric Brake Thrust Control
                bhAtmo = 0 --export: Level of Atmospheric Brake Handling
                fehAtmo = 3 --export: Level of Atmospheric Flight Element Handling

                aggAltitudeChange = 100 --export: AGG altitude increase / decrease level in meter

                hudMsgTimer = 5 --export: Message display timer

                doorSwitchSlotName = "btnDoor" --export: Slot name of button door switch
                -- Initiate Personal Parameter END



                -- Initiate Personal Setup START
                setup()
                -- Initiate Personal Setup END
                -- Darkwinde END: unit.start()

    unit:
        stop:
            lua: |
                -- Darkwinde START: unit.stop()

                local environmentParameter = getEnvironmentParameter(environmentID)
                if doorSwitch ~= nil and velocity_kmh <= environmentParameter["surfaceSpeedLow"] and telemeterExists and
                    round(telemeter.getDistance()) <= environmentParameter["surfaceDistanceLow"] then 
                    doorSwitch.activate()
                end

                unit.stopTimer('HUD')
                -- Darkwinde END: unit.start()

    unit:
        tick:
            args: [HUD]
            lua: |
                -- Darkwinde START: unit.tick(HUD)

                -- UPDATE GLOBALS START
                up = vec3(core.getWorldVertical()) * -1
                velocity = vec3(core.getWorldVelocity())
                velocity_kmh = round(vec3(core.getVelocity()):len() * 3.6)
                velocity_vertical =  round((velocity.x * up.x) + (velocity.y * up.y) + (velocity.z * up.z))

                environment = getEnvironmentName()
                environmentID = getEnvironmentID()

                systemReference = PlanetRef()(Atlas())[0]
                planet = systemReference:closestBody(core.getConstructWorldPos())
                
                if telemeterExists then obstacleDistance = telemeter.getDistance() else obstacleDistance = 0 end
                -- UPDATE GLOBALS END


                local hudHTMLBody = {}
                local hud_BrakeStatus = ternary(lockBrake, '<div class="on_r">on</div>', '<div class="off">off</div>')
                local hud_Environment = ''
                if environmentID == 3 then -- Spacedock
                    hud_Environment = '<div style="color:#20b020; font-weight:bold;">' .. environment .. '</div>'

                    if not firstStart then
                        -- Change to travel mode, as cruise will prevent final docking
                        if Nav.control.getControlMasterModeId() == 1 then
                            Nav.control.cancelCurrentControlMasterMode()
                        end
                        
                        setHTMLMessage(hudHTMLMsg, "You are docked!!!", "ok")
                        lockBrake = true
                        docked = true
                        firstStart = not firstStart
                    end
                else -- Atmo & Space
                    hud_Environment = '<div>' .. environment .. '</div>'

                    if firstStart then 
                        firstStart = not firstStart
                    end
                end



                --local hud_MaxThrust = round(Nav:maxForceForward() / 1000) .. 'kN'
                local hud_Throttle = ternary(Nav.control.getControlMasterModeId() == 1, round(unit.getThrottle() / 100) .. ' km/h', round(unit.getThrottle()) .. '%')
                local hud_FlightStyle = ternary(Nav.control.getControlMasterModeId() == 1, 'cruise', 'travel')
                hud_FlightStyle = hud_FlightStyle .. ternary(verticalEngines, ' (v)', '')
                -- Space core gravity is slightly above 10m/s², display adjustment required
                local gravityAdjustment = ternary(environmentID == 3, 10, gravity) -- m/s²
                local hud_LocalGravity = round((core.g() / gravityAdjustment), 2) .. 'g'
                local hud_Altitude = format_number(round(core.getAltitude())) .. 'm'
                local hud_SurfaceEstimation = ternary(planet.surface ~= -1, format_number(round(core.getAltitude() - planet.surface)) .. 'm', '<div style="color:red; font-weight:bold;">Not In List</div>')
                local hud_AtmosphereDensity = round(unit.getAtmosphereDensity() * 100) .. '%'
                local hud_AirResistance = round(vec3(core.getWorldAirFrictionAcceleration()):len()) .. 'N'
                local constructMass = core.getConstructMass() * (1 + payloadOverhead / 100) -- kg
                local reqThrust = constructMass * core.g() -- N
                local maxThrust = ternary(vtolPlane, Nav:maxForceUp(), Nav:maxForceForward()) -- N
                local ratioThrust = round(maxThrust / reqThrust - 1, 2) -- >1: Space possible / =1: Flight possible / <1: Flight not possible
                local maxMass = maxThrust / core.g() -- kg
                local hud_RemainingPayloadLift = ternary(constructMass > maxMass, '<div style="color:red; font-weight:bold;">', '<div>') .. format_number(round((maxMass - constructMass) / 1000)) .. 't</div>'
                local hud_ObstacleDistance = ternary(obstacleDistance == 0, 'N/A', round(obstacleDistance) .. 'm')


                --local hud_Acceleration = round((vec3(core.getWorldAcceleration()):len() / gravity), 1) .. 'g'
                local brakeDistanceSpeed0 = getBrakeDistance(0) -- km/h
                local brakeDistanceSpeed2000 = getBrakeDistance(2000) -- km/h
                local hud_Speed0 = brakeDistanceSpeed0["min"] .. "m:" .. brakeDistanceSpeed0["sec"] .. "s - " .. brakeDistanceSpeed0["su"] .. "su (" .. ternary(brakeDistanceSpeed0["km"] == 0, "0",  brakeDistanceSpeed0["km"]) .. "km)"
                local hud_Speed2000 = brakeDistanceSpeed2000["min"] .. "m:" .. brakeDistanceSpeed2000["sec"] .. "s - " .. brakeDistanceSpeed2000["su"] .. "su (" ..  ternary(brakeDistanceSpeed2000["km"] == 0, "0", brakeDistanceSpeed2000["km"]) .. "km)"





                hudHTMLBody[#hudHTMLBody + 1] = 
                [[
                <div class="zen">
                    <div class="controls-hud">
                        <div class="category">Status...</div>
                        <div class="primary control-container">
                            <p class="primary">Handbrake:</p>
                            ]] .. hud_BrakeStatus .. [[
                        </div>
                        <div class="primary control-container">
                            <p class="primary">Environment:</p>
                            ]] .. hud_Environment .. [[
                        </div>
                ]]


                -- Get AGG data and display them
                if antigrav ~= nil then 
                    local hud_AGGStatus = ternary(antigrav.getState() == 1, '<div class="on_g">on</div>', '<div class="off">off</div>')
                    local aggData = json.decode(antigrav.getData())
                    local hud_AGGPower = round(aggData.antiGPower * 100) .. '%'
                    --local hud_AGGField = math.floor(aggData.antiGravityField * 100) .. '%'
                    local hud_AGGAltitude = round(aggData.baseAltitude)
                    if db_extension_agg ~= nil then aggAltitudeTarget = db_extension_agg.getIntValue("agg_target_altitude") end

                    hudHTMLBody[#hudHTMLBody + 1] =
                    [[
                        <div class="primary control-container">
                            <p class="primary">&nbsp;</p>&nbsp;
                        </div>
                        <div class="primary control-container">
                            <p class="primary">AGG:</p>
                            ]] .. hud_AGGStatus .. [[
                        </div>
                        <div class="primary control-container">
                            <p class="primary">&nbsp;&nbsp;&gt;&nbsp;Power:</p>
                            ]] .. hud_AGGPower .. [[
                        </div>
                        <div class="primary control-container">
                            <p class="primary">&nbsp;&nbsp;&gt;&nbsp;Altitude:</p>
                            ]] .. format_number(hud_AGGAltitude) .. ' (' .. format_number(math.floor(aggAltitudeTarget)) .. ') m' .. [[
                        </div>
                    ]]
                end


                -- Show speed information
                hudHTMLBody[#hudHTMLBody + 1] =
                [[
                        <div class="spacer"></div>
                        <div class="category">Speed...</div>
                        <div class="primary control-container">
                            <p class="primary">Speed:</p>
                            ]] .. velocity_kmh .. ' km/h' .. [[
                        </div>
                ]]


                -- Show only in atmosphere
                hudHTMLBody[#hudHTMLBody + 1] = ternary(environmentID == 1,
                [[
                        <div class="primary control-container">
                            <p class="primary">Vertical Velocity:</p>
                            ]] .. velocity_vertical .. ' m/s²' .. [[
                        </div>
                ]]
                , "")


                hudHTMLBody[#hudHTMLBody + 1] =
                [[
                        <div class="spacer"></div>
                        <div class="category">Braking...</div>
                        <div class="primary control-container">
                            <p class="primary">To full stop:</p>
                            ]] .. hud_Speed0 .. [[
                        </div>
                ]]


                -- Show only, if brake distance is higher
                hudHTMLBody[#hudHTMLBody + 1] = ternary(brakeDistanceSpeed2000["time"] > 0, 
                [[
                        <div class="primary control-container">
                            <p class="primary">To 2000 km/h:</p>
                            ]] .. hud_Speed2000 .. [[
                        </div>
                ]]
                , "")



                hudHTMLBody[#hudHTMLBody + 1] = 
                [[
                        <div class="spacer"></div>
                        <div class="category">Telemetric...</div>
                        <div class="primary control-container">
                            <p class="primary">Throttle:</p>
                            ]] .. hud_Throttle .. [[
                        </div>
                        <div class="primary control-container">
                            <p class="primary">Flight Style:</p>
                            ]] .. hud_FlightStyle .. [[
                        </div>
                        <div class="primary control-container">
                            <p class="primary">Locale Gravity:</p>
                            ]] .. hud_LocalGravity .. [[
                        </div>
                ]]


                -- Show only in atmosphere
                hudHTMLBody[#hudHTMLBody + 1] = ternary(environmentID == 1, 
                [[
                        <div class="primary control-container">
                            <p class="primary">Sea Level:</p>
                            ]] .. hud_Altitude .. [[
                        </div>
                        <div class="primary control-container">
                            <p class="primary">Estm. to surface:</p>
                            ]] .. hud_SurfaceEstimation .. [[
                        </div>
                        <div class="primary control-container">
                            <p class="primary">Density:</p>
                            ]] .. hud_AtmosphereDensity .. [[
                        </div>
                        <div class="primary control-container">
                            <p class="primary">Air Resistance:</p>
                            ]] .. hud_AirResistance .. [[
                        </div>
                ]]
                , "")


                -- Show only on surface
                hudHTMLBody[#hudHTMLBody + 1] = ternary(surfaceLow, 
                [[
                        <div class="primary control-container">
                            <p class="primary">Remaining Payload:</p>
                            ]] .. hud_RemainingPayloadLift .. [[
                        </div>
                ]]
                , "")


                -- Show only near ground
                hudHTMLBody[#hudHTMLBody + 1] = ternary(obstacleDistance >= 0, 
                [[
                        <div class="primary control-container">
                            <p class="primary">Obstacle Distance:</p>
                            ]] .. hud_ObstacleDistance .. [[
                        </div>
                ]]
                , "")



                -- Show "complex" fuel tank information
                if (myFuelTanks["atmospheric fuel tank"] ~= nil or myFuelTanks["space fuel tank"] ~= nil or myFuelTanks["rocket fuel tank"] ~= nil) then
                    hudHTMLBody[#hudHTMLBody + 1] =
                    [[
                        <div class="spacer"></div>
                        <div class="category">Fuel...</div>
                    ]]    
                
                    local tmpHTMLFuelTanks = {["atmospheric fuel tank"]={},["space fuel tank"]={},["rocket fuel tank"]={}}
                    for typ, tanks in pairs(myFuelTanks) do         
                        for i, parameter in ipairs(tanks) do        
                            local displayName = "N/A"
                            local displayVolume = format_number(round(parameter["curvolume"] / parameter["maxvolume"] * 100))
                            local displayVolumeLevel = format_number(round(parameter["curvolume"])) .. " / " .. format_number(round(parameter["maxvolume"])) .. "l"
                            
                            if typ == "atmospheric fuel tank" then
                                displayName = "Atmo " .. i
                            elseif typ == "space fuel tank" then
                                displayName = "Space " .. i
                            elseif typ == "rocket fuel tank" then
                                displayName = "Rocket " .. i
                            end
                            
                            tmpHTMLFuelTanks[typ][#tmpHTMLFuelTanks[typ] + 1] = 
                            [[
                                <div class="primary control-container">
                                    <p class="primary">]] .. displayName .. [[ </p>
                                    ]] .. displayVolumeLevel .. "&nbsp;&nbsp;(" .. displayVolume .. "%)" .. [[  
                                </div>
                                <div class="primary2 control-container">
                                    <p></p>
                                    ]] .. parameter["constime"] .. [[
                                </div>
                            ]]
                        end
                    end
                    
                    -- Sort the unordered list: Atmo, Space, Rock
                    hudHTMLBody[#hudHTMLBody + 1] = table.concat(tmpHTMLFuelTanks["atmospheric fuel tank"], "")
                    hudHTMLBody[#hudHTMLBody + 1] = table.concat(tmpHTMLFuelTanks["space fuel tank"], "")
                    hudHTMLBody[#hudHTMLBody + 1] = table.concat(tmpHTMLFuelTanks["rocket fuel tank"], "")
                end




                hudHTMLBody[#hudHTMLBody + 1] = 
                [[  
                    </div>
                </div>
                ]]


                local content = getHTMLHeader() .. orbitinterface() .. table.concat(hudHTMLBody, "")  .. [[<div class="msg">]] .. table.concat(hudHTMLMsg, "") .. [[</div>]] .. getHTMLFooter()
                system.setScreen(content)
                system.showScreen(1)

                -- Darkwinde END: unit.tick(HUD)

    unit:
        tick:
            args: [HUDMsg]
            lua: |
                -- Darkwinde START: unit.tick(HUDMsg)

                hudHTMLMsg = {}
                unit.stopTimer("HUDMsg")

                -- Darkwinde END: unit.tick(HUDMsg)

    unit:
        tick:
            args: [FUEL]
            lua: |
                -- Darkwinde START: unit.tick(FUEL)

                -- Update fuel tank list
                for typ, tanks in pairs(myFuelTanks) do
                    for i, parameter in ipairs(tanks) do
                        -- Get element information
                        local id = parameter["id"]
                        local typ  = core.getElementTypeById(id):lower()
                        local name  = core.getElementNameById(id):lower()
                        local mass = core.getElementMassById(id)    
                        local hp = core.getElementMaxHitPointsById(id)
                        local emptyMass, curMass, maxVolume, curVolume, consVolume, consTime = 0, 0, 0, 0, 0, 0
                        local curTime = system.getTime()
                        -- Define fuel tank skills for later use by reference
                        local fuelTankSkills = {["atmospheric fuel-tank"] = fthAtmo, ["space fuel-tank"] = fthSpace, ["rocket fuel-tank"] = fthRocket}

                        
                        -- Get fuel tank parameter
                        local size = "XS" -- default size     
                        if hp >= fuelTanks[typ]["L"]["hp"] then 
                            size = "L"
                        elseif hp >= fuelTanks[typ]["M"]["hp"] then 
                            size = "M"
                        elseif hp >= fuelTanks[typ]["S"]["hp"] then 
                            size = "S"
                        end

                        
                        -- Calculate tank mass
                        emptyMass = round(fuelTanks[typ][size]["mass"])
                        curMass = round(mass - emptyMass, 2)

                        
                        -- looks like a bug on fuel tanks mass reduction as container optimization also is impacting 
                        ftoVolume = (1 - fto * (0.05)) * (1 - coo * (0.05))
                        maxVolume = fuelTanks[typ][size]["volume"]
                        curVolume = round(curMass / (fuel[typ] * ftoVolume), 2) 
                        

                        -- Calculate consumed fuel and remaining time until empty
                        consVolume = parameter["curvolume"] - curVolume
                        if consVolume > 0 then
                            consTime = curVolume / (consVolume / (curTime - parameter["time"]))
                        end

                        
                        local h = round(consTime / 3600)
                        local timeFrac1 = consTime - 3600 * h
                        local min = round(timeFrac1 / 60)
                        local timeFrac2 = timeFrac1 - 60 * min
                        local sec = round(timeFrac2)
                        consTime = h .. "h:" ..min .. "m:" .. sec .. "s"


                        -- Check and apply for fuel tank handling skills (Piloting)
                        if fuelTankSkills[typ] ~= nil and fuelTankSkills[typ] > 0 then
                            maxVolume = maxVolume * (1 + fuelTankSkills[typ] * 0.2)
                        end

                        -- Update fuel tank information
                        parameter["curvolume"] = curVolume
                        parameter["curmass"] = curMass
                        parameter["consvolume"] = consVolume
                        parameter["constime"] = consTime
                        parameter["time"] = curTime
                    end
                end

                -- Darkwinde END: unit.tick(FUEL)

    system:
        flush:
            lua: |
                -- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu

                local pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
                local brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)
                local autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01

                local turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is
                local turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                -- validate params
                pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
                yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
                rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
                torqueFactor = math.max(torqueFactor, 0.01)
                brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
                brakeFlatFactor = math.max(brakeFlatFactor, 0.01)
                autoRollFactor = math.max(autoRollFactor, 0.01)
                turnAssistFactor = math.max(turnAssistFactor, 0.01)

                -- final inputs
                local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()
                local finalRollInput = rollInput + system.getControlDeviceYawInput()
                local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
                local finalBrakeInput = brakeInput

                -- Axis
                local worldVertical = vec3(core.getWorldVertical()) -- along gravity
                local constructUp = vec3(core.getConstructWorldOrientationUp())
                local constructForward = vec3(core.getConstructWorldOrientationForward())
                local constructRight = vec3(core.getConstructWorldOrientationRight())
                local constructVelocity = vec3(core.getWorldVelocity())
                local constructVelocityDir = vec3(core.getWorldVelocity()):normalize()
                local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                local currentRollDegAbs = math.abs(currentRollDeg)
                local currentRollDegSign = utils.sign(currentRollDeg)

                -- Rotation
                local constructAngularVelocity = vec3(core.getWorldAngularVelocity())
                local targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight
                                                + finalRollInput * rollSpeedFactor * constructForward
                                                + finalYawInput * yawSpeedFactor * constructUp

                -- In atmosphere?
                if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then
                    local autoRollRollThreshold = 1.0
                    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling
                    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then
                        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit
                        if (rollPID == nil) then
                            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                        end
                        rollPID:inject(targetRollDeg - currentRollDeg)
                        local autoRollInput = rollPID:get()

                        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward
                    end
                    local turnAssistRollThreshold = 20.0
                    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing
                    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then
                        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range
                        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range

                        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)
                        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180
                        local rollVerticalRatio = 0
                        if rescaleRollDegAbs < 90 then
                            rollVerticalRatio = rescaleRollDegAbs / 90
                        elseif rescaleRollDegAbs < 180 then
                            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90
                        end

                        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio

                        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)
                        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio

                        targetAngularVelocity = targetAngularVelocity
                                            + turnAssistPitchInput * constructRight
                                            + turnAssistYawInput * constructUp
                    end
                end

                -- Engine commands
                local keepCollinearity = 1 -- for easier reading
                local dontKeepCollinearity = 0 -- for easier reading
                local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities

                -- Rotation
                local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
                local airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())
                angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction
                Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)

                -- Brakes
                local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
                Nav:setEngineForceCommand('brake', brakeAcceleration)

                -- AutoNavigation regroups all the axis command by 'TargetSpeed'
                local autoNavigationEngineTags = ''
                local autoNavigationAcceleration = vec3()
                local autoNavigationUseBrake = false

                -- Longitudinal Translation
                local longitudinalEngineTags = 'thrust analog longitudinal'
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byThrottle) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)
                    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
                elseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration
                    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop
                        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking
                    then
                        autoNavigationUseBrake = true
                    end

                end

                -- Lateral Translation
                local lateralStrafeEngineTags = 'thrust analog lateral'
                local lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
                if (lateralCommandType == axisCommandType.byThrottle) then
                    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)
                    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)
                elseif  (lateralCommandType == axisCommandType.byTargetSpeed) then
                    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration
                end

                -- Vertical Translation
                local verticalStrafeEngineTags = 'thrust analog vertical'
                local verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
                if (verticalCommandType == axisCommandType.byThrottle) then
                    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)
                    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)
                elseif  (verticalCommandType == axisCommandType.byTargetSpeed) then
                    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration
                end

                -- Auto Navigation (Cruise Control)
                if (autoNavigationAcceleration:len() > constants.epsilon) then
                    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward
                    then
                        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'
                    end
                    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)
                end

                -- Rockets
                Nav:setBoosterCommand('rocket_engine')

        update:
            lua: Nav:update()

        actionStart:
            args: [gear]
            lua: |
                gearExtended = not gearExtended
                if gearExtended then
                    Nav.control.extendLandingGears()
                else
                    Nav.control.retractLandingGears()
                end

        actionStart:
            args: [light]
            lua: |
                if Nav.control.isAnyHeadlightSwitchedOn() == 1 then
                    Nav.control.switchOffHeadlights()
                else
                    Nav.control.switchOnHeadlights()
                end

        actionStart:
            args: [forward]
            lua: pitchInput = pitchInput - 1
        actionStop:
            args: [forward]
            lua: pitchInput = pitchInput + 1
        actionStart:
            args: [backward]
            lua: pitchInput = pitchInput + 1
        actionStop:
            args: [backward]
            lua: pitchInput = pitchInput - 1
        actionStart:
            args: [left]
            lua: rollInput = rollInput - 1
        actionStop:
            args: [left]
            lua: rollInput = rollInput + 1
        actionStart:
            args: [right]
            lua: rollInput = rollInput + 1
        actionStop:
            args: [right]
            lua: rollInput = rollInput - 1

        actionStart:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)
        actionStop:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)

        actionStart:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)
        actionStop:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)

        actionStart:
            args: [up]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)
        actionStop:
            args: [up]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
        actionStart:
            args: [down]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)
        actionStop:
            args: [down]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)

        actionStart:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)

        actionLoop:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)


        actionStart:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)

        actionLoop:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)

        actionStart:
            args: [yawright]
            lua: yawInput = yawInput - 1
        actionStop:
            args: [yawright]
            lua: yawInput = yawInput + 1
        actionStart:
            args: [yawleft]
            lua: yawInput = yawInput + 1
        actionStop:
            args: [yawleft]
            lua: yawInput = yawInput - 1
        actionStart:
            args: [brake]
            lua: |
                brakeInput = brakeInput + 1
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        actionStop:
            args: [brake]
            lua: brakeInput = brakeInput - 1

        actionLoop:
            args: [brake]
            lua: |
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        actionStart:
            args: [booster]
            lua: Nav:toggleBoosters()
        actionStart:
            args: [stopengines]
            lua: Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
        actionStart:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)
        actionLoop:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)
        actionStart:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)
        actionLoop:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)
        actionStart:
            args: [antigravity]
            lua: if antigrav ~= nil then antigrav.toggle() end

    system:
        update:
            lua: |
                -- Darkwinde START: system.update()
                -- LandingGear
                -- >> Not allowed to have them in flush() anymore
                if landing and unit.isAnyLandingGearExtended() == 0 then
                    unit.extendLandingGears()
                elseif not landing and unit.isAnyLandingGearExtended() == 1 then
                    unit.retractLandingGears()
                end
                -- Darkwinde END: system.update()

    system:
        flush:
            lua: |
                -- Darkwinde START: system.flush()
                -- Telemeter
                -- >> Distance can be between 1 and 100. 
                -- >> Scripting Wiki for telemeter is wrong. For MaxDistance it is mentioned 20m
                -- >> !!! Telemeter even works (hidden) behind honeycomb
                -- system.print(telemeter.getDistance())
                local environmentParameter = getEnvironmentParameter(environmentID)


                -- Check if telemeter unit exists
                if telemeterExists then
                    landing = telemeter.getDistance() > 0 and telemeter.getDistance() < environmentParameter["surfaceDistanceLanding"]
                    surfaceLow = telemeter.getDistance() > 0 and telemeter.getDistance() <= environmentParameter["surfaceDistanceLow"]
                else
                    landing, surfaceLow, surfaceBrake = false , false, false
                end


                -- Set general altitude stabilization according to the environment
                if surfaceLow and unit.getSurfaceEngineAltitudeStabilization() ~= 0 and
                    unit.getSurfaceEngineAltitudeStabilization() ~= environmentParameter["surfaceDistanceLow"] then
                    unit.activateGroundEngineAltitudeStabilization(environmentParameter["surfaceDistanceLow"])
                end
                    

                -- Start and landing condition to stay on surface
                if lockBrake then
                    brakeInput = 1
                    
                    if surfaceLow or docked then
                        unit.setEngineThrust("vertical thrust", 0) -- default tags are in lower case and space seperated
                        unit.deactivateGroundEngineAltitudeStabilization()
                    end
                end



                -- Use brake to stabalize near ground level
                if surfaceBrake and surfaceLow then
                    brakeInput = 1
                elseif surfaceBrake and not surfaceLow then
                    surfaceBrake = false
                    brakeInput = 0
                elseif not surfaceBrake and surfaceLow then
                    surfaceBrake = true
                    brakeInput = 1
                end



                -- In space it is not necessary to use engine stabilization / maneuver engine at high speed
                if (environmentID == 2 and velocity_kmh > 5000) or not verticalEngines then
                    --unit.setEngineThrust("vertical thrust", 0)
                    Nav:setEngineCommand("vertical thrust", vec3.zero, vec3.zero)
                    --unit.deactivateGroundEngineAltitudeStabilization()
                end



                -- As we want the AGG to stabalize our altitude, we need to deactivate vertical engines
                if antigrav ~= nil then
                    local aggData = json.decode(antigrav.getData())
                    -- But only in case we are within AGG field, outside happy maneuver
                    if aggData.antiGPower > 0 then 
                        unit.setEngineThrust("vertical thrust", 0)
                        unit.deactivateGroundEngineAltitudeStabilization()
                        
                        -- Stop oscillate effect around target altitude
                        if aggAltitudeTarget == aggData.baseAltitude and core.g() < 0.1 and velocity_kmh >= 1 then
                            brakeInput = 1
                        else
                            
                            -- Stop oscillate effect by short braking on high amplitude level
                            -- Atmo brakes are not direcly at full force, therefor oscillate effect takes longer
                            if aggAltitudeTarget ~= aggData.baseAltitude and core.g() < 0.1 and velocity_kmh > 16 then
                                brakeInput = 1
                            else
                                brakeInput = 0
                            end
                        end  
                    end
                end
                -- Darkwinde END: system.flush()

    system:
        actionStart:
            args: [option1]
            lua: |
                -- Darkwinde START: system.actionStart(option 1)
                -- >> Option 1 is by default ALT+1


                -- Take off script by releasing brake and setting altitude level
                lockBrake = not lockBrake


                if not lockBrake then
                    brakeInput = 0
                    docked = false

                    local environmentParameter = getEnvironmentParameter(environmentID)        
                    unit.setEngineThrust("vertical thrust", 1) -- default tags are in lower case    
                    unit.activateGroundEngineAltitudeStabilization(environmentParameter["surfaceDistanceLow"])

                    if firstStart then
                        setHTMLMessage(hudHTMLMsg, "TAKE OFF \n Have a nice flight!")
                    end
                end


                -- Darkwinde END: system.actionStart(option 1)

    system:
        actionStart:
            args: [option2]
            lua: |
                -- Darkwinde START: system.actionStart(option 2)
                -- >> Option 2 is by default ALT+2


                -- Deactivate vertical stabilization on user request
                verticalEngines = not verticalEngines
                
                -- Change to travel mode, as cruise will prevent AGG to take ship down / up
                if Nav.control.getControlMasterModeId() == 1 then
                    Nav.control.cancelCurrentControlMasterMode()
                end

                -- Darkwinde END: system.actionStart(option 2)

    system:
        actionStart:
            args: [option8]
            lua: |
                -- Darkwinde START: system.actionStart(option 8)
                -- >> Option 8 is by default ALT+8


                if antigrav ~= nil and aggAltitudeTarget < 100000 then
                    aggAltitudeTarget =  math.floor(aggAltitudeTarget / 100) * aggAltitudeChange + aggAltitudeChange
                    antigrav.setBaseAltitude(math.floor(aggAltitudeTarget))
                    
                    if db_extension_agg ~= nil then 
                        db_extension_agg.setIntValue("agg_target_altitude", aggAltitudeTarget) 
                    end
                end


                -- Darkwinde END: system.actionStart(option 8)

    system:
        actionStart:
            args: [option9]
            lua: |
                -- Darkwinde START: system.actionStart(option 9)
                -- >> Option 9 is by default ALT+9


                if antigrav ~= nil and aggAltitudeTarget > 1000 then
                    aggAltitudeTarget =  math.floor(aggAltitudeTarget / 100) * aggAltitudeChange - aggAltitudeChange
                    antigrav.setBaseAltitude(math.floor(aggAltitudeTarget))
                    
                    if db_extension_agg ~= nil then 
                        db_extension_agg.setIntValue("agg_target_altitude", aggAltitudeTarget) 
                    end
                end


                -- Darkwinde END: system.actionStart(option 9)

    library:
        start:
            lua: |
                -- Darkwinde START: library.start()

                -- Generic Initialization & Setup START

                -- Default parameter initialization
                function init()
                    version = "v0.3.1"
                    description = " - Minimalistic HUD from Darkwinde & Expugnator"
                    gravity = 9.81 -- m/s²
                    velocity = vec3(core.getWorldVelocity()) -- m/s²
                    velocity_kmh = round(vec3(core.getVelocity()):len() * 3.6) -- m/s²

                    
                    habitats = {'Atmosphere', 'Space', 'Spacedock'} -- Default environments
                    surfaceDistanceLow = {15, 1, 1}  -- m
                    surfaceDistanceLanding = {40, 20, 20} -- m
                    surfaceDistanceHigh = {80, 80, 80} -- m
                    surfaceSpeedLow = {1, 1, 1} -- m/s²
                    environment = getEnvironmentName() -- Initialize environment name
                    environmentID = getEnvironmentID() -- Initialize environment ID

                    
                    firstStart = true -- Indicator to show correct HUD messages
                    lockBrake = true -- Default handbrake active 
                    surfaceBrake = true -- Default handbrake near surface active
                    surfaceLow = true -- Default to initialize distance check near surface
                    landing = true -- Default to initialize distance check if landing
                    docked = true -- Default docked mode
                    verticalEngines = true -- Default vertical engines are deactivated on AGG use
                    
                    
                    hudHTMLMsg = {} -- Message variable
                end


                -- On initiated parameter perform setup
                function setup()
                    -- Get fuel tanks
                    myFuelTanks = getFuelTanks()

                    
                    
                    -- Check for element existence
                    telemeterExists = false
                    for slotname, slot in pairs(unit) do
                        
                        if type(slot) == "table" and slot.getElementClass then
                            -- Mandatory: Telemeter
                            if slot.getElementClass():lower():find("telemeter") and slotname == "telemeter" then
                                telemeterExists = true
                            end

                            -- Optional: DataBank
                            if slot.getElementClass():lower():find("databank") and db_extension_agg == nil then
                                -- Check for extension - AGG Screen
                                if slot.hasKey("agg_target_altitude") == 1 then
                                    db_extension_agg = slot
                                end
                            end
                        end

                        -- Optional: Door Switch
                        if slotname == doorSwitchSlotName then
                            doorSwitch = slot
                            doorSwitch.deactivate()
                        end 
                    end

                    -- Display HUD critical message and initialize telemeter object with distance method
                    if not telemeterExists then
                        setHTMLMessage(hudHTMLMsg, "Telemeter missing!<br>Attach one to your flight seat!", "critical")
                    end


                    -- Check for high speed and unlock handbrake on sit down
                    if lockBrake and velocity_kmh > 50 then
                        lockBrake = not lockBrake
                    end
                    
                    -- Hide Default Panels START
                    unit.hide() -- Hide unit (commander seat) widget
                    core.hide() -- Hide core widget
                    if _autoconf ~= nil then _autoconf.hideCategoryPanels() end -- Hide auto DU widget
                    if antigrav ~= nil then -- Hide AGG widget and get target altitude
                        if db_extension_agg ~= nil then
                            aggAltitudeTarget = db_extension_agg.getIntValue("agg_target_altitude") 
                        else
                            aggAltitudeTarget = antigrav.getBaseAltitude()
                        end
                        antigrav.setBaseAltitude(aggAltitudeTarget)
                        antigrav.hide()
                    end   


                    -- Start timer
                    unit.setTimer('HUD', 0.5)
                    unit.setTimer('FUEL', 5)
                end

                -- Generic Initialization & Setup END


                -- Generic Functions START

                -- Return dumped information in a human readable string
                function dump(o)
                    if type(o) == 'table' then
                        local s = '{ '
                        for k,v in pairs(o) do
                            if type(k) ~= 'number' then 
                                k = '"' .. k .. '"' 
                            end
                            s = s .. '[' .. k .. '] = ' .. dump(v) .. ','
                        end
                        return s .. '} '
                    else
                        return tostring(o)
                    end
                end


                -- If condition is TRUE return variable T else variable F
                -- >> Used at feature: system.update() -> hudShowBrakeStatus
                function ternary(cond, T, F)
                    if cond ~= nil and cond then
                        return T
                    else
                        return F
                    end
                end



                -- Round float number to certain digits
                function round(num, numDecimalPlaces)
                    local mult = 10 ^ (numDecimalPlaces or 0)
                    if numDecimalPlaces ~= nil then
                        return math.floor(num * mult + 0.5) / mult
                    else
                        return math.floor((num * mult + 0.5) / mult)
                    end
                end


                -- Format numbers to look nice
                -- credit http://richard.warburton.it
                function format_number(n) 
                    local left,num,right = string.match(n,'^([^%d]*%d)(%d*)(,-)$')
                    return left..(num:reverse():gsub('(%d%d%d)','%1 '):reverse()) .. right
                end

                -- Generic Functions END



                -- Getter & Setter START

                -- HTML header part for the HUD
                function getHTMLHeader()
                    PrimaryR = 130
                    PrimaryG = 224
                    PrimaryB = 255
                    rgb = [[rgb(]] .. math.floor(PrimaryR+0.5) .. "," .. math.floor(PrimaryG+0.5) .. "," .. math.floor(PrimaryB+0.5) .. [[)]]
                    rgbdim = [[rgb(]] .. math.floor(PrimaryR *0.9 + 0.5) .. "," .. math.floor(PrimaryG * 0.9 + 0.5) .. "," .. math.floor(PrimaryB * 0.9 + 0.5) .. [[)]]

                    local bright = rgb
                    local dim = rgbdim
                    local brightOrig = rgb
                    local dimOrig = rgbdim

                    
                local header =
                string.format([[
                <head>
                <style>
                        body {margin:0}
                        svg {position:absolute; top:0; left:0; font-family:Montserrat;} 
                        .line {stroke-width:2px; fill:none}
                        .linethick {stroke-width:3px; fill:none}
                        .bright {fill:%s; stroke:%s}
                        .pbright {fill:%s; stroke:%s}
                        .dim {fill:%s; stroke:%s}
                        .pdim {fill:%s; stroke:%s}
                        .red {fill:red; stroke:red}
                        .redout {fill:none; stroke:red}
                        .op30 {opacity:0.3}
                        .op10 {opacity:0.1}     
                        .txtstart {text -anchor:start}
                        .txtmid {text-anchor:middle}
                        .txtend {text-anchor:end}
                        .txtorb {font-size:12px}
                        .txtorbbig {font-size:18px}

                        .primary {font-size:0.8rem; color:#B6DFED;}
                        .primary2 {font-size:0.65rem; color:#B6DFED;}
                        .zen {display:flex; flex-direction:column;}
                        .controls-hud {top:25%%; right:0.7%%; position:absolute; display:flex; flex-direction:column; 
                                    width:16%%; padding:0.5%% 0.8%%; overflow:none; justify-content:space-around; 
                                    background-color:#34495E80; border-color:#333333; border-radius:12px;}
                        .control-container {display:flex; justify-content:space-between; padding:0.5%%; }
                        .category {color:#ffffff; font-size:1rem; text-align:center; margin:0.4rem;}
                        .spacer {margin-top:1rem; border-top:1px solid #ffffff;}
                        .on_g {background-color:green; margin-left:10px; border-radius:50%%; width:22px; 
                            height:22px; border:2px solid black; text-align:center;}
                        .on_r {background-color:red; margin-left:10px; border-radius:50%%; width:22px; 
                            height:22px; border:2px solid black; text-align:center;}
                        .off {background-color:none; margin-left:10px; border-radius:50%%; width:22px; 
                            height:22px; border:2px solid transparent; text-align:center;}
                        .msg {position:absolute; top:50%%; left:50%%; 
                            -moz-transform:translateX(-50%%) translateY(-50%%);
                            -webkit-transform:translateX(-50%%) translateY(-50%%);
                            transform:translateX(-50%%) translateY(-50%%); text-align:center;}
                        .info {font-size:1.8rem; color:#B6DFED;}
                        .ok {font-size:2.5rem; color:green;}
                        .warning {font-size:2.5rem; color:yellow;}
                        .critical {font-size:3.5rem; color:red;}
                        .version {position:absolute; bottom:0; right:0; width:100%%; height:0.5rem; 
                                font-size:0.55rem; text-align:right;}
                </style>
                </head>
                <body>
                <svg height="100%%" width="100%%" viewBox="0 0 1920 1080">
                ]], bright, bright, brightOrig, brightOrig, dim, dim, dimOrig, dimOrig)
                    
                    
                return header
                end


                -- HTML footer part for the HUD
                function getHTMLFooter()
                    return  string.format([[</svg><div class="version">%s %s</div></body>]], version, description)
                end


                -- HTML HUD message
                function setHTMLMessage(hudHTMLMsg, msg, msgtype)    
                    if msgtype == nil then
                        msgtype = "info"
                    end
                    
                    for str in string.gmatch(msg, "([^\n]+)") do
                        hudHTMLMsg[#hudHTMLMsg + 1] = string.format([[<div class="%s">%s</div>]], msgtype, str)
                    end
                    
                    unit.setTimer("HUDMsg", hudMsgTimer)
                end  


                -- Get current environment information returned as ID or name
                function getEnvironmentID()
                    if unit.getAtmosphereDensity() > 0.0 then -- Atmo
                        return  1
                    elseif core.g() >= gravity then -- Spacedock
                        return 3
                    else -- Space
                        return 2
                    end
                end
                function getEnvironmentName(id)  
                    if id ~= nil then
                        return habitats[id]
                    end
                    
                    if unit.getAtmosphereDensity() > 0.0 then -- Atmo
                        return  habitats[1]
                    elseif core.g() >= gravity then -- Spacedock
                    return habitats[3]
                    else -- Space
                        return habitats[2]
                    end
                end
                function getEnvironmentParameter(id) 
                    local returnValue = {}
                    
                    if id ~= nil then -- ID based
                        returnValue["habitat"] = habitats[id]
                        returnValue["surfaceDistanceLow"] = surfaceDistanceLow[id]
                        returnValue["surfaceDistanceLanding"] = surfaceDistanceLanding[id]
                        returnValue["surfaceDistanceHigh"] = surfaceDistanceHigh[id]
                        returnValue["surfaceSpeedLow"] = surfaceSpeedLow[id]
                    else
                        if unit.getAtmosphereDensity() > 0.0 then -- Atmo
                            returnValue["habitat"] = habitats[1]
                            returnValue["surfaceDistanceLow"] = surfaceDistanceLow[1]
                            returnValue["surfaceDistanceLanding"] = surfaceDistanceLanding[1]
                            returnValue["surfaceDistanceHigh"] = surfaceDistanceHigh[1]
                            returnValue["surfaceSpeedLow"] = surfaceSpeedLow[1]
                        elseif core.g() >= gravity then -- Spacedock
                            returnValue["habitat"] = habitats[3] 
                            returnValue["surfaceDistanceLow"] = surfaceDistanceLow[3]
                            returnValue["surfaceDistanceLanding"] = surfaceDistanceLanding[3]
                            returnValue["surfaceDistanceHigh"] = surfaceDistanceHigh[3]
                            returnValue["surfaceSpeedLow"] = surfaceSpeedLow[3]
                        else -- Space
                            returnValue["habitat"] = habitats[2]
                            returnValue["surfaceDistanceLow"] = surfaceDistanceLow[2]
                            returnValue["surfaceDistanceLanding"] = surfaceDistanceLanding[2]
                            returnValue["surfaceDistanceHigh"] = surfaceDistanceHigh[2]
                            returnValue["surfaceSpeedLow"] = surfaceSpeedLow[2]
                        end 
                    end

                    return returnValue
                end


                function getBrakeDistance(endingSpeed)
                    local returnValue = {}
                    local distance = 0;
                    local time = 0;
                    local c = 30000*1000/3600
                    local c2 = c*c

                    
                    local initialSpeed = vec3(core.getVelocity()):len() -- m/s
                    --local initialSpeed = 20000 / 3.6 -- m/s --> For Testing
                    endingSpeed = endingSpeed / 3.6 -- m/s
                    local restMass = round(core.getConstructMass()) -- kg
                    local maxBrake = json.decode(unit.getData()).maxBrake -- N
                    if maxBrake == nil then -- check if in Atmo, as unit does not contain information. Bug?!?
                        local airFriction = round(vec3(core.getWorldAirFrictionAcceleration()):len(), 5)
                        maxBrake = airFriction + getMaxBrakeAtmo() -- N
                    end
                    local totA = -maxBrake * (1-0)/restMass;

                    
                    if initialSpeed > endingSpeed then
                        local k1 = c * math.asin(initialSpeed / c)
                        local k2 = c2 * math.cos(k1 / c) / totA
                        time = (c * math.asin(endingSpeed / c) - k1) / totA
                        distance = k2 - c2 * math.cos((totA * time + k1) / c) / totA
                    end

                    
                    local min = math.floor(time / 60)   
                    local timeFrac = time - 60 * min
                    local sec = round(timeFrac)
                    local su = math.floor(distance / 200000)
                    local remainder = distance - 200000 * su
                    local suFrac = round(100 * remainder / 200000) / 100
                    local km = ternary(distance < 1000, round(distance / 1000, 3), round(distance / 1000))


                    returnValue["min"] = string.format("%02d", min)
                    returnValue["sec"] = string.format("%02d", sec)
                    returnValue["su"] = su + suFrac
                    returnValue["km"] = km
                    returnValue["time"] = time
                    returnValue["distance"] = distance


                    return returnValue
                end



                atmoBrakes = {["S"] = {["thrust"]= 50000, ["mass"]= 55.55, ["hp"]= 50}, ["M"] = {["thrust"]= 500000, ["mass"]= 285.25, ["hp"]= 50}, ["L"] = {["thrust"]= 5000000, ["mass"]= 1500, ["hp"]= 767}}
                function getMaxBrakeAtmo()
                    local returnValue = 0
                    
                    -- Not realy cool, but works good as possible
                    -- unit.getData() should be fixed by NQ
                    -- Get atmospheric brake list from core
                    for _, el in ipairs(core.getElementIdList()) do
                        -- Get element information
                        local typ  = core.getElementTypeById(el):lower()
                        local name  = core.getElementNameById(el):lower()
                        local mass = core.getElementMassById(el)    
                        local hp = core.getElementMaxHitPointsById(el)
                        
                        
                        if typ == "atmospheric airbrake" then
                            -- Get brake parameter
                            local size = "S" -- default size     
                            if mass >= atmoBrakes["L"]["mass"] then 
                                size = "L"
                            elseif mass >= atmoBrakes["M"]["mass"] then 
                                size = "M"
                            end
                            
                            -- Apply atmospheric brake skills
                            local atmosphericBrakeThrustControl = atmoBrakes[size]["thrust"] * btcAtmo * 0.1
                            local atmosphericBrakeHandling = atmoBrakes[size]["thrust"] * bhAtmo * 0.1
                            local atmosphericFlightElementhandling = 1 + fehAtmo * 0.02
                            
                            returnValue = returnValue + (atmoBrakes[size]["thrust"] + atmosphericBrakeThrustControl + atmosphericBrakeHandling) * atmosphericFlightElementhandling
                        end
                    end
                    
                    return returnValue
                end







                fuel = {["atmospheric fuel tank"] = 4, ["space fuel tank"] = 6, ["rocket fuel tank"] = 0.8}
                fuelTanks = {["atmospheric fuel tank"] = {["XS"] = {["volume"]= 100, ["mass"]= 35.03, ["hp"]= 50}, ["S"] = {["volume"]= 400, ["mass"]= 182.67, ["hp"]= 163}, ["M"] = {["volume"]= 1600, ["mass"]= 988.67, ["hp"]= 1315}, ["L"] = {["volume"]= 12800, ["mass"]= 5480, ["hp"]= 10461}}, ["space fuel tank"] = {["S"] = {["volume"]= 400, ["mass"]= 182.67, ["hp"]= 187}, ["M"] = {["volume"]= 1600, ["mass"]= 988.67, ["hp"]= 1496}, ["L"] = {["volume"]= 12800, ["mass"]= 5480, ["hp"]= 15933}}, ["rocket fuel tank"] = {["XS"] = {["volume"]= 400, ["mass"]= 173.42, ["hp"]= 366}, ["S"] = {["volume"]= 800, ["mass"]= 886.72, ["hp"]= 736}, ["M"] = {["volume"]= 6400, ["mass"]= 4720, ["hp"]= 6231}, ["L"] = {["volume"]= 50000, ["mass"]= 25740, ["hp"]= 68824}}}
                function getFuelTanks()
                    local returnValue = {}
                    
                    -- Get fuel tank list from core
                    for _, el in ipairs(core.getElementIdList()) do
                        -- Get element information
                        local typ  = core.getElementTypeById(el):lower()
                        local name  = core.getElementNameById(el):lower()
                        local mass = core.getElementMassById(el)    
                        local hp = core.getElementMaxHitPointsById(el)
                        local emptyMass, curMass, maxVolume, curVolume, consVolume, consTime = 0, 0, 0, 0, 0, "0h:0m:0s"
                        local curTime = system.getTime()
                        -- Define fuel tank handling skills for later use by reference
                        local fuelTankSkills = {["atmospheric fuel tank"] = fthAtmo, ["space fuel tank"] = fthSpace, ["rocket fuel tank"] = fthRocket}

                        -- Check if element is the one we are searching for (defined in the array)
                        if fuelTanks[typ] ~= nil then
                            -- Initialize array for later use
                            if returnValue[typ] == nil then
                                returnValue[typ] = {}
                            end

                            -- Get fuel tank parameter
                            local size = "XS" -- default size     
                            if hp >= fuelTanks[typ]["L"]["hp"] then
                                size = "L"
                            elseif hp >= fuelTanks[typ]["M"]["hp"] then
                                size = "M"
                            elseif hp >= fuelTanks[typ]["S"]["hp"] then
                                size = "S"
                            end

                            
                            -- Calculate tank mass
                            emptyMass = fuelTanks[typ][size]["mass"]
                            curMass = mass - emptyMass
                            
                            
                            -- looks like a bug on fuel tanks mass reduction as container optimization also is impacting 
                            ftoVolume = (1 - fto * (0.05)) * (1 - coo * (0.05))
                            maxVolume = fuelTanks[typ][size]["volume"]
                            curVolume = round(curMass / (fuel[typ] * ftoVolume), 2) 
                            
                            
                            -- Check and apply for fuel tank handling skills (Piloting)
                            if fuelTankSkills[typ] > 0 and fuelTankSkills[typ] ~= nil then
                                maxVolume = fuelTanks[typ][size]["volume"] * (1 + fuelTankSkills[typ] * 0.2)
                            end
                                    

                            -- Add fuel tank information to my personal list
                            returnValue[typ][#returnValue[typ] + 1] = {["id"]=el, ["name"]=name, ["maxvolume"]=maxVolume, ["curvolume"]=curVolume, ["emptymass"]=emptyMass, ["curmass"]=curMass, ["consvolume"]=consVolume, ["constime"]=consTime, ["time"]=curTime}
                        end
                    end
                    
                    return returnValue
                end
                -- Getter & Setter END



                -- Appending Functions START
                function Navigator.maxForceUp(self)
                    local axisCRefDirection = vec3(self.core.getConstructOrientationUp())
                    local verticalEngineTags = 'thrust analog vertical not_ground'
                    local maxKPAlongAxis = self.core.getMaxKinematicsParametersAlongAxis(verticalEngineTags, {axisCRefDirection:unpack()})
                    if self.control.getAtmosphereDensity() <= 0.1 then -- we can use space engines
                        return maxKPAlongAxis[3]
                    else
                        return maxKPAlongAxis[1]
                    end
                end
                -- Appending Functions END
                -- Darkwinde END: library.start()

    library:
        start:
            lua: | 
                -- Expugnator START: library.start()
                function Atlas()
                    return {
                        [0] = {
                            [1]={
                                GM=6930729684,
                                bodyId=1,
                                center={x=17465536.000,y=22665536.000,z=-34464.000},
                                name='Madis',
                                planetarySystemId=0,
                                radius=44300,
                                surface=850,
                                spaceEngine=4500
                            },
                            [2]={
                                GM=157470826617,
                                bodyId=2,
                                center={x=-8.000,y=-8.000,z=-126303.000},
                                name='Alioth',
                                planetarySystemId=0,
                                radius=126068,
                                surface=0,
                                spaceEngine=3500
                            },
                            [3]={
                                GM=11776905000,
                                bodyId=3,
                                center={x=29165536.000,y=10865536.000,z=65536.000},
                                name='Thades',
                                planetarySystemId=0,
                                radius=49000,
                                surface=13600,
                                spaceEngine=21600
                            },
                            [4]={
                                GM=14893847582,
                                bodyId=4,
                                center={x=-13234464.000,y=55765536.000,z=465536.000},
                                name='Talemai',
                                planetarySystemId=0,
                                radius=57450,
                                surface=-1,
                                spaceEngine=-1
                            },
                            [5]={
                                GM=16951680000,
                                bodyId=5,
                                center={x=-43534464.000,y=22565536.000,z=-48934464.000},
                                name='Feli',
                                planetarySystemId=0,
                                radius=60000,
                                surface=-1,
                                spaceEngine=-1
                            },
                            [6]={
                                GM=10502547741,
                                bodyId=6,
                                center={x=52765536.000,y=27165538.000,z=52065535.000},
                                name='Sicari',
                                planetarySystemId=0,
                                radius=51100,
                                surface=0,
                                spaceEngine=-1
                            },
                            [7]={
                                GM=13033380591,
                                bodyId=7,
                                center={x=58665538.000,y=29665535.000,z=58165535.000},
                                name='Sinnen',
                                planetarySystemId=0,
                                radius=54950,
                                surface=400,
                                spaceEngine=-1
                            },
                            [8]={
                                GM=18477723600,
                                bodyId=8,
                                center={x=80865538.000,y=54665536.000,z=-934463.940},
                                name='Teoma',
                                planetarySystemId=0,
                                radius=62000,
                                surface=-1,
                                spaceEngine=-1
                            },
                            [9]={
                                GM=18606274330,
                                bodyId=9,
                                center={x=-94134462.000,y=12765534.000,z=-3634464.000},
                                name='Jago',
                                planetarySystemId=0,
                                radius=61590,
                                surface=-1,
                                spaceEngine=-1
                            },
                            [10]={
                                GM=78480000,
                                bodyId=10,
                                center={x=17448118.224,y=22966846.286,z=143078.820},
                                name='Madis Moon 1',
                                planetarySystemId=0,
                                radius=10000,
                                surface=-1,
                                spaceEngine=-1
                            },
                            [11]={
                                GM=237402000,
                                bodyId=11,
                                center={x=17194626.000,y=22243633.880,z=-214962.810},
                                name='Madis Moon 2',
                                planetarySystemId=0,
                                radius=11000,
                                surface=-1,
                                spaceEngine=-1
                            },
                            [12]={
                                GM=265046609,
                                bodyId=12,
                                center={x=17520614.000,y=22184730.000,z=-309989.990},
                                name='Madis Moon 3',
                                planetarySystemId=0,
                                radius=15005,
                                surface=-1,
                                spaceEngine=-1
                            },
                            [21]={
                                GM=2118960000,
                                bodyId=21,
                                center={x=457933.000,y=-1509011.000,z=115524.000},
                                name='Alioth Moon 1',
                                planetarySystemId=0,
                                radius=30000,
                                surface=0,
                                spaceEngine=0
                            },
                            [22]={
                                GM=2165833514,
                                bodyId=22,
                                center={x=-1692694.000,y=729681.000,z=-411464.000},
                                name='Alioth Moon 4',
                                planetarySystemId=0,
                                radius=30330,
                                surface=0,
                                spaceEngine=0
                            },
                            [26]={
                                GM=68234043600,
                                bodyId=26,
                                center={x=-1404835.000,y=562655.000,z=-285074.000},
                                name='Sanctuary',
                                planetarySystemId=0,
                                radius=83400,
                                surface=0,
                                spaceEngine=4300
                            },
                            [30]={
                                GM=211564034,
                                bodyId=30,
                                center={x=29214402.000,y=10907080.695,z=433858.200},
                                name='Thades Moon 1',
                                planetarySystemId=0,
                                radius=14002,
                                surface=-1,
                                spaceEngine=-1
                            },
                            [31]={
                                GM=264870000,
                                bodyId=31,
                                center={x=29404193.000,y=10432768.000,z=19554.131},
                                name='Thades Moon 2',
                                planetarySystemId=0,
                                radius=15000,
                                surface=-1,
                                spaceEngine=-1
                            },
                            [40]={
                                GM=141264000,
                                bodyId=40,
                                center={x=-13503090.000,y=55594325.000,z=769838.640},
                                name='Talemai Moon 2',
                                planetarySystemId=0,
                                radius=12000,
                                surface=-1,
                                spaceEngine=-1
                            },
                            [41]={
                                GM=106830900,
                                bodyId=41,
                                center={x=-12800515.000,y=55700259.000,z=325207.840},
                                name='Talemai Moon 3',
                                planetarySystemId=0,
                                radius=11000,
                                surface=-1,
                                spaceEngine=-1
                            },
                            [42]={
                                GM=264870000,
                                bodyId=42,
                                center={x=-13058408.000,y=55781856.000,z=740177.760},
                                name='Talemai Moon 1',
                                planetarySystemId=0,
                                radius=15000,
                                surface=-1,
                                spaceEngine=-1
                            },
                            [50]={
                                GM=499917600,
                                bodyId=50,
                                center={x=-43902841.780,y=22261034.700,z=-48862386.000},
                                name='Feli Moon 1',
                                planetarySystemId=0,
                                radius=14000,
                                surface=-1,
                                spaceEngine=-1
                            },
                            [70]={
                                GM=396912600,
                                bodyId=70,
                                center={x=58969616.000,y=29797945.000,z=57969449.000},
                                name='Sinnen Moon 1',
                                planetarySystemId=0,
                                radius=17000,
                                surface=-1,
                                spaceEngine=-1
                            },
                            [100]={
                                GM=13975172474,
                                bodyId=100,
                                center={x=98865536.000,y=-13534464.000,z=-934461.990},
                                name='Lacobus',
                                planetarySystemId=0,
                                radius=55650,
                                surface=-1,
                                spaceEngine=-1
                            },
                            [101]={
                                GM=264870000,
                                bodyId=101,
                                center={x=98905288.170,y=-13950921.100,z=-647589.530},
                                name='Lacobus Moon 3',
                                planetarySystemId=0,
                                radius=15000,
                                surface=-1,
                                spaceEngine=-1
                            },
                            [102]={
                                GM=444981600,
                                bodyId=102,
                                center={x=99180968.000,y=-13783862.000,z=-926156.400},
                                name='Lacobus Moon 1',
                                planetarySystemId=0,
                                radius=18000,
                                surface=-1,
                                spaceEngine=-1
                            },
                            [103]={
                                GM=211503600,
                                bodyId=103,
                                center={x=99250052.000,y=-13629215.000,z=-1059341.400},
                                name='Lacobus Moon 2',
                                planetarySystemId=0,
                                radius=14000,
                                surface=-1,
                                spaceEngine=-1
                            },
                            [110]={
                                GM=9204742375,
                                bodyId=110,
                                center={x=14165536.000,y=-85634465.000,z=-934464.300},
                                name='Symeon',
                                planetarySystemId=0,
                                radius=49050,
                                surface=-1,
                                spaceEngine=-1
                            },
                            [120]={
                                GM=7135606629,
                                bodyId=120,
                                center={x=2865536.700,y=-99034464.000,z=-934462.020},
                                name='Ion',
                                planetarySystemId=0,
                                radius=44950,
                                surface=-1,
                                spaceEngine=6550
                            },
                            [121]={
                                GM=106830900,
                                bodyId=121,
                                center={x=2472916.800,y=-99133747.000,z=-1133582.800},
                                name='Ion Moon 1',
                                planetarySystemId=0,
                                radius=11000,
                                surface=0,
                                spaceEngine=0
                            },
                            [122]={
                                GM=176580000,
                                bodyId=122,
                                center={x=2995424.500,y=-99275010.000,z=-1378480.700},
                                name='Ion Moon 2',
                                planetarySystemId=0,
                                radius=15000,
                                surface=-1900,
                                spaceEngine=0
                            }  
                        }
                    }
                end

                --[[ 
                Provides methods for computing orbital information for an object

                Usage:
                Kepler = require('autoconf.custom.kepler')
                alioth = Kepler({ GM=157470826617,
                bodyId=2,
                center={x=-8.000,y=-8.000,z=-126303.000},
                name='Alioth',
                planetarySystemId=0,
                radius=126068
                })
                altitude = 6000
                position = '::pos{0,2,0,0,6000}'

                e, o     = alioth:escapeAndOrbitalSpeed(altitude)
                orbit    = alioth:orbitalParameters(position, {0, o+1, 0})

                print("Eccentricity " .. orbit.eccentricity)
                print("Perihelion " .. orbit.periapsis.altitude)
                print("Max. speed " .. orbit.periapsis.speed)
                print("Circular orbit speed " .. orbit.periapsis.circularOrbitSpeed)
                print("Aphelion "  .. orbit.apoapsis.altitude)
                print("Min. speed " .. orbit.apoapsis.speed)
                print("Orbital period " .. orbit.period)
                --- output:
                Eccentricity 0.0018324307017878
                Perihelion 6000.0
                Max. speed 1092.9462297033
                Circular orbit speed 1091.9462297033
                Aphelion 6484.8994605062
                Min. speed 1088.9480596194
                Orbital period 762.02818214049

                Methods:
                Kepler:escapeAndOrbitalSpeed - for a given celestial body and altitude.
                Kepler:orbitalParameters - for a given massless object and a celestial body.

                Description
                The motion of an object in the vicinity of substantially larger mass is
                in the domain of the "2-body problem". By assuming the object whose motion
                is of interest is of negligable mass simplifies the calculations of:
                the speed to escape the body, the speed of a circular orbit, and the
                parameters defining the orbit of the object (or the lack of orbit as the
                case may be).

                Orbital Parameters:
                periapsis - the closest approach to the planet
                apoapsis - the furthest point from the planet if in orbit (otherwise nil)
                eccentricity - 0 for circular orbits
                <1 for elliptical orbits
                1 for parabiolic trajectory
                >1 for hyperbolic trajectory
                period - time (in seconds) to complete an orbit

                Also See: planetref.lua
                ]]--

                function Keplers()
                    local vec3       = require('cpml.vec3')
                    local PlanetRef  = PlanetRef()

                    local function isString(s) return type(s)   == 'string' end
                    local function isTable(t)  return type(t)   == 'table'  end

                    local function float_eq(a,b)
                        if a == 0 then return math.abs(b) < 1e-09 end
                        if b == 0 then return math.abs(a) < 1e-09 end
                        return math.abs(a - b) < math.max(math.abs(a),math.abs(b))*epsilon
                    end


                    Kepler = {}
                    Kepler.__index = Kepler

                    --
                    -- escapeAndOrbitalSpeed - speed required to escape and for a circular orbit
                    -- altitude [in]: the height of the orbit in meters above "sea-level"
                    -- return: the speed in m/s needed to escape the celestial body and to orbit it.
                    --
                    function Kepler:escapeAndOrbitalSpeed(altitude)
                        assert(self.body)
                        -- P = -GMm/r and KE = mv^2/2 (no lorentz factor used)
                        -- mv^2/2 = GMm/r
                        -- v^2 = 2GM/r
                        -- v = sqrt(2GM/r1)
                        local distance = altitude + self.body.radius

                        if not float_eq(distance, 0) then
                            local orbit = math.sqrt(self.body.GM/distance)
                            return math.sqrt(2)*orbit, orbit
                        end
                        return nil, nil
                    end

                    --
                    -- orbitalParameters: determine the orbital elements for a two-body system.
                    -- overload [in]: the world coordinates or map coordinates of a massless object.
                    -- velocity [in]: The velocity of the massless point object in m/s.
                    -- return: the 6 orbital elements for the massless object.
                    --
                    function Kepler:orbitalParameters(overload, local_velocity)
                        assert(self.body)
                        assert(isTable(overload) or isString(overload))
                        assert(isTable(local_velocity))
                        local pos = (isString(overload) or PlanetRef.isMapPosition(overload)) and
                        self.body:convertToWorldCoordinates(overload) or
                        vec3(overload)
                        local v   = vec3(local_velocity)
                        local r   = pos - self.body.center
                        local v2  = v:len2()
                        local d   = r:len()
                        local mu  = self.body.GM
                        local e   = ((v2 - mu/d)*r - r:dot(v)*v)/mu
                        local a   = mu/(2*mu/d - v2)

                        local ecc = e:len()
                        local dir = e:normalize()
                        local pd  = a*(1-ecc)
                        local ad  = a*(1+ecc)
                        local per = pd*dir + self.body.center
                        local apo = ecc <= 1 and -ad*dir + self.body.center or nil
                        local trm = math.sqrt(a*mu*(1-ecc*ecc))
                        local Period = apo and 2*math.pi*math.sqrt(a^3/mu)

                        local trueAnomaly = math.acos((e:dot(r))/(ecc*d))

                        if r:dot(v) < 0 then
                            trueAnomaly = -(trueAnomaly - 2*math.pi)
                        end 

                        local EccentricAnomaly = math.acos((math.cos(trueAnomaly) + ecc)/(1 + ecc * math.cos(trueAnomaly)))

                        local timeTau = EccentricAnomaly
                        if timeTau < 0 then
                            timeTau = timeTau + 2*math.pi
                        end  

                        local MeanAnomaly = timeTau - ecc * math.sin(timeTau)
                        local TimeSincePeriapsis = 0
                        local TimeToPeriapsis = 0
                        local TimeToApoapsis = 0


                        if Period ~= nil then
                            TimeSincePeriapsis = MeanAnomaly/(2*math.pi/Period)

                            TimeToPeriapsis = Period - TimeSincePeriapsis
                            TimeToApoapsis = TimeToPeriapsis + Period/2
                            if trueAnomaly - math.pi > 0 then -- TBH I think something's wrong in my formulas because I needed this.
                                TimeToPeriapsis = TimeSincePeriapsis
                                TimeToApoapsis = TimeToPeriapsis + Period/2
                            end
                            if TimeToApoapsis > Period then
                                TimeToApoapsis = TimeToApoapsis - Period
                            end
                        end
                        return { periapsis       = { position           = per,
                                speed              = trm/pd,
                                circularOrbitSpeed = math.sqrt(mu/pd),
                                altitude           = pd - self.body.radius},
                            apoapsis        = apo and
                            { position           = apo,
                                speed              = trm/ad,
                                circularOrbitSpeed = math.sqrt(mu/ad),
                                altitude           = ad - self.body.radius
                            },
                            currentVelocity = v,
                            currentPosition = pos,
                            eccentricity    = ecc,
                            period          = Period,
                            eccentricAnomaly = EccentricAnomaly,
                            meanAnomaly = MeanAnomaly,
                            timeToPeriapsis = TimeToPeriapsis,
                            timeToApoapsis = TimeToApoapsis
                        }
                    end

                    local function new(bodyParameters)
                        local params = PlanetRef.BodyParameters(bodyParameters.planetarySystemId,
                            bodyParameters.bodyId,
                            bodyParameters.radius,
                            bodyParameters.center,
                            bodyParameters.GM)
                        return setmetatable({body = params}, Kepler)
                    end

                    return setmetatable(Kepler, { __call = function(_,...) return new(...) end })

                end

                --[[ 
                DualUniverse kinematic equations
                Author: JayleBreak

                Usage (unit.start):
                Kinematics = require('autoconf.custom.kinematics')

                Methods:
                computeAccelerationTime - "relativistic" version of t = (vf - vi)/a
                computeDistanceAndTime - Return distance & time needed to reach final speed.
                computeTravelTime - "relativistic" version of t=(sqrt(2ad+v^2)-v)/a

                Description
                DualUniverse increases the effective mass of constructs as their absolute
                speed increases by using the "lorentz" factor (from relativity) as the scale
                factor.  This results in an upper bound on the absolute speed of constructs
                (excluding "warp" drive) that is set to 30 000 KPH (8 333 MPS). This module
                provides utilities for computing some physical quantities taking this
                scaling into account.
                ]]--

                function Kinematics()
                    local Kinematic = {} -- just a namespace

                    local C       = 30000000/3600
                    local C2      = C*C
                    local ITERATIONS = 100 -- iterations over engine "warm-up" period

                    local function lorentz(v) return 1/math.sqrt(1 - v*v/C2) end

                    --
                    -- computeAccelerationTime - "relativistic" version of t = (vf - vi)/a
                    -- initial      [in]: initial (positive) speed in meters per second.
                    -- acceleration [in]: constant acceleration until 'finalSpeed' is reached.
                    -- final        [in]: the speed at the end of the time interval.
                    -- return: the time in seconds spent in traversing the distance
                    --
                    function Kinematic.computeAccelerationTime(initial, acceleration, final)
                        -- The low speed limit of following is: t=(vf-vi)/a (from: vf=vi+at)
                        local k1 = C*math.asin(initial/C)
                        return (C * math.asin(final/C) - k1)/acceleration
                    end

                    --
                    -- computeDistanceAndTime - Return distance & time needed to reach final speed.
                    -- initial[in]:     Initial speed in meters per second.
                    -- final[in]:       Final speed in meters per second.
                    -- restMass[in]:    Mass of the construct at rest in Kg.
                    -- thrust[in]:      Engine's maximum thrust in Newtons.
                    -- t50[in]:         (default: 0) Time interval to reach 50% thrust in seconds.
                    -- brakeThrust[in]: (default: 0) Constant thrust term when braking.
                    -- return: Distance (in meters), time (in seconds) required for change.
                    --
                    function Kinematic.computeDistanceAndTime(initial,
                            final,
                            restMass,
                            thrust,
                            t50,
                            brakeThrust)
                        -- This function assumes that the applied thrust is colinear with the
                        -- velocity. Furthermore, it does not take into account the influence
                        -- of gravity, not just in terms of its impact on velocity, but also
                        -- its impact on the orientation of thrust relative to velocity.
                        -- These factors will introduce (usually) small errors which grow as
                        -- the length of the trip increases.
                        t50            = t50 or 0
                        brakeThrust    = brakeThrust or 0 -- usually zero when accelerating

                        local tau0     = lorentz(initial)
                        local speedUp  = initial <= final
                        local a0       = thrust * (speedUp and 1 or -1)/restMass
                        local b0       = -brakeThrust/restMass
                        local totA     = a0+b0

                        if speedUp and totA <= 0 or not speedUp and totA >= 0 then
                            return -1, -1 -- no solution
                        end

                        local distanceToMax, timeToMax = 0, 0

                        -- If, the T50 time is set, then assume engine is at zero thrust and will
                        -- reach full thrust in 2*T50 seconds. Thrust curve is given by:
                        -- Thrust: F(z)=(a0*(1+sin(z))+2*b0)/2 where z=pi*(t/t50 - 1)/2
                        -- Acceleration is given by F(z)/m(z) where m(z) = m/sqrt(1-v^2/c^2)
                        -- or v(z)' = (a0*(1+sin(z))+2*b0)*sqrt(1-v(z)^2/c^2)/2

                        if a0 ~= 0 and t50 > 0 then
                            -- Closed form solution for velocity exists:
                            -- v(t) = -c*tan(w)/sqrt(tan(w)^2+1) => w = -asin(v/c)
                            -- w=(pi*t*(a0/2+b0)-a0*t50*sin(pi*t/2/t50)+*pi*c*k1)/pi/c
                            -- @ t=0, v(0) = vi
                            -- pi*c*k1/pi/c = -asin(vi/c)
                            -- k1 = asin(vi/c)
                            local k1  = math.asin(initial/C)

                            local c1  = math.pi*(a0/2+b0)
                            local c2  = a0*t50
                            local c3  = C*math.pi

                            local v = function(t)
                                local w  = (c1*t - c2*math.sin(math.pi*t/2/t50) + c3*k1)/c3
                                local tan = math.tan(w)
                                return C*tan/math.sqrt(tan*tan+1)
                            end

                            local speedchk = speedUp and function(s) return s >= final end or
                            function(s) return s <= final end
                            timeToMax  = 2*t50

                            if speedchk(v(timeToMax)) then
                                local lasttime = 0

                                while math.abs(timeToMax - lasttime) > 0.5 do
                                    local t = (timeToMax + lasttime)/2
                                    if speedchk(v(t)) then
                                        timeToMax = t 
                                    else
                                        lasttime = t
                                    end
                                end
                            end

                            -- There is no closed form solution for distance in this case.
                            -- Numerically integrate for time t=0 to t=2*T50 (or less)
                            local lastv = initial
                            local tinc  = timeToMax/ITERATIONS

                            for step = 1, ITERATIONS do
                                local speed = v(step*tinc)
                                distanceToMax = distanceToMax + (speed+lastv)*tinc/2
                                lastv = speed
                            end

                            if timeToMax < 2*t50 then
                                return distanceToMax, timeToMax
                            end
                            initial = lastv
                        end
                        -- At full thrust, acceleration only depends on the Lorentz factor:
                        -- v(t)' = (F/m(v)) = a*sqrt(1-v(t)^2/c^2) where a = a0+b0
                        -- -> v = c*sin((at+k1)/c)
                        -- @ t=0, v=vi: k1 = c*asin(vi/c)
                        -- -> t = (c*asin(v/c) - k1)/a
                        -- x(t)' = c*sin((at+k1)/c)
                        -- x = k2 - c^2 cos((at+k1)/c)/a
                        -- @ t=0, x=0: k2 = c^2 * cos(k1/c)/a
                        local k1       = C*math.asin(initial/C)
                        local time     = (C * math.asin(final/C) - k1)/totA

                        local k2       = C2 *math.cos(k1/C)/totA
                        local distance = k2 - C2 * math.cos((totA*time + k1)/C)/totA

                        return distance+distanceToMax, time+timeToMax
                    end

                    --
                    -- computeTravelTime - "relativistic" version of t=(sqrt(2ad+v^2)-v)/a
                    -- initialSpeed [in]: initial (positive) speed in meters per second
                    -- acceleration [in]: constant acceleration until 'distance' is traversed
                    -- distance [in]: the distance traveled in meters
                    -- return: the time in seconds spent in traversing the distance
                    --
                    function Kinematic.computeTravelTime(initial, acceleration, distance)
                        -- The low speed limit of following is: t=(sqrt(2ad+v^2)-v)/a
                        -- (from: d=vt+at^2/2)
                        if distance == 0 then return 0 end

                        if acceleration > 0 then
                            local k1       = C*math.asin(initial/C)
                            local k2       = C2*math.cos(k1/C)/acceleration
                            return (C*math.acos(acceleration*(k2 - distance)/C2) - k1)/acceleration
                        end
                        assert(initial > 0, 'Acceleration and initial speed are both zero.')
                        return distance/initial
                    end

                    function Kinematic.lorentz(v) return lorentz(v) end

                    return Kinematic
                end    


                --[[ 
                Provide coordinate transforms and access to kinematic related parameters
                Author: JayleBreak

                Usage (unit.start):
                PlanetaryReference = require('planetref')
                galaxyReference = PlanetaryReference(referenceTableSource)
                helios = galaxyReference[0] -- PlanetaryReference.PlanetarySystem instance
                alioth = helios[2]          -- PlanetaryReference.BodyParameters instance

                Methods:
                PlanetaryReference:getPlanetarySystem - based on planetary system ID.
                PlanetaryReference.isMapPosition - 'true' if an instance of 'MapPosition'
                PlanetaryReference.createBodyParameters - for entry into reference table
                PlanetaryReference.BodyParameters - a class containing a body's information.
                PlanetaryReference.MapPosition - a class for map coordinates
                PlanetaryReference.PlanetarySystem - a container for planetary system info.

                PlanetarySystem:castIntersections - from a position in a given direction.
                PlanetarySystem:closestBody - to the specified coordinates.
                PlanetarySystem:convertToBodyIdAndWorldCoordinates - from map coordinates.
                PlanetarySystem:getBodyParameters - from reference table.
                PlanetarySystem:getPlanetarySystemId - for the instance.

                BodyParameters:convertToWorldCoordinates - from map coordinates
                BodyParameters:convertToMapPosition - from world coordinates
                BodyParameters:getAltitude - of world coordinates
                BodyParameters:getDistance - from center to world coordinates
                BodyParameters:getGravity - at a given position in world coordinates.

                Description
                An instance of the 'PlanetaryReference' "class" can contain transform and
                kinematic reference information for all planetary systems in DualUniverse.
                Each planetary system is identified by a numeric identifier. Currently,
                the only planetary system, Helios, has the identifier: zero. This "class"
                supports the indexing ('[]') operation which is equivalent to the
                use of the 'getPlanetarySystem' method. It also supports the 'pairs()'
                method for iterating over planetary systems.

                An instance of the 'PlanetarySystem' "class" contains all reference
                information for a specific system. It supports the indexing ('[]') and
                'pairs()' functions which allows iteration over each "body" in the
                system where the key is the numeric body ID. It also supports the
                'tostring()' method.

                An instance of the 'BodyParameters' "class" contains all reference
                information for a single celestial "body" (a moon or planet). It supports
                the 'tostring()' method, and contains the data members:
                planetarySystemId - numeric planetary system ID
                bodyId            - numeric body ID
                radius            - radius of the body in meters (zero altitude)
                center            - world coordinates of the body's center position
                GM                - the gravitation parameter (g = GM/radius^2)
                Note that the user is allowed to add custom fields (e.g. body name), but
                should insure that complex table values have the '__tostring' metamethod
                implemented.

                Transform and Kinematics:
                "World" coordinates is a cartesian coordinate system with an origin at an
                arbitrary fixed point in a planetary system and with distances measured in
                meters. The coordinates are expressible either as a simple table of 3 values
                or an instance of the 'vec3' class.  In either case, the planetary system
                identity is implicit.

                "Map" coordinates is a geographic coordinate system with an origin at the
                center of an identified (by a numeric value) celestial body which is a
                member of an identified (also a numeric value) planetary system. Note that
                the convention that latitude, longitude, and altitude values will be the
                position's x, y, and z world coordinates in the special case of body ID 0.

                The kinematic parameters in the reference data permit calculations of the
                gravitational attraction of the celestial body on other objects.

                Reference Data:
                This is an example of reference data with a single entry assigned to
                planetary system ID 0, and body ID 2 ('Alioth'):
                referenceTable = {
                [0] = { [2] = { planetarySystemId = 0,
                bodyId = 2,
                radius = 126068,
                center = vec3({x=-8, y=-8, z=-126303}),
                GM = 1.572199+11 } -- as in F=-GMm/r^2
                }
                }
                ref=PlanetaryReference(referenceTable)

                Collecting Reference Data:
                A combination of information from the "Map" screen in the DU user interface,
                and values reported by the DU Lua API can be the source of the reference
                table's data (planetarySystemId, bodyId, and surfaceArea is from the user
                interface):
                referenceTable = {}
                referenceTable[planetarySystemId][bodyId] =
                PlanetaryReference.createBodyParameters(planetarySystemId,
                bodyId,
                surfaceArea,
                core.getConstructWorldPos(),
                core.getWorldVertical(),
                core.getAltitude(),
                core.g())


                Adapting Data Sources:
                Other sources of data can be adapted or converted. An example of adapting a
                table, defined in the file: 'planets.lua', containing information on a single
                planetary system and using celestial body name as the key follows (note that
                a 'name' field is added to the BodyParameters instance transparently after
                construction, and the '__pairs' meta function is required to support the
                'closestBody' and '__tostring' methods):
                ref=PlanetaryReference(
                {[0] = setmetatable(require('planets'),
                { __index = function(bodies, bodyId)
                for _,v in pairs(bodies) do
                if v and v.bodyId == bodyId then return v end
                end
                return nil
                end,
                __pairs = function(bodies)
                return function(t, k)
                local nk, nv = next(t, k)
                if nv then
                local GM = nv.gravity * nv.radius^2
                local bp = BodyParameters(0,
                nv.id,
                nv.radius,
                nv.pos,
                GM)
                bp.name = nk
                return nk, bp
                end
                return nk, nv
                end, bodies, nil
                end })
                })

                Converting Data Sources:
                An instance of 'PlanetaryReference' that has been adapted to a data source
                can be used to convert that source to simple table. For example,
                using the adapted instance shown above:
                load('convertedData=' .. tostring(ref))()
                newRef=PlanetaryReference(convertedData)

                Also See: kepler.lua
                ]]--

                --[[                    START OF LOCAL IMPLEMENTATION DETAILS             ]]--

                -- Type checks

                function PlanetRef() 
                    local function isNumber(n)  return type(n)           == 'number' end
                    local function isSNumber(n) return type(tonumber(n)) == 'number' end
                    local function isTable(t)   return type(t)           == 'table'  end
                    local function isString(s)  return type(s)           == 'string' end
                    local function isVector(v)  return isTable(v)
                        and isNumber(v.x and v.y and v.z) end

                    local function isMapPosition(m) return isTable(m) and isNumber(m.latitude  and
                            m.longitude and
                            m.altitude  and
                            m.bodyId    and
                            m.systemId) end

                    -- Constants

                    local deg2rad    = math.pi/180
                    local rad2deg    = 180/math.pi
                    local epsilon    = 1e-10
                    local num        = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'
                    local posPattern = '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' ..
                    num ..  ',' .. num .. '}'

                    -- Utilities

                    local utils  = require('cpml.utils')
                    local vec3   = require('cpml.vec3')
                    local clamp  = utils.clamp

                    local function float_eq(a,b)
                        if a == 0 then return math.abs(b) < 1e-09 end
                        if b == 0 then return math.abs(a) < 1e-09 end
                        return math.abs(a - b) < math.max(math.abs(a),math.abs(b))*epsilon
                    end

                    local function formatNumber(n)
                        local result = string.gsub(
                            string.reverse(string.format('%.4f',n)),
                            '^0*%.?','')
                        return result == '' and '0' or string.reverse(result)
                    end

                    local function formatValue(obj)
                        if isVector(obj) then
                            return string.format('{x=%.3f,y=%.3f,z=%.3f}', obj.x, obj.y, obj.z)
                        end

                        if isTable(obj) and not getmetatable(obj) then
                            local list = {}
                            local nxt  = next(obj)

                            if type(nxt) == 'nil' or nxt == 1 then -- assume this is an array
                                list = obj
                            else
                                for k,v in pairs(obj) do
                                    local value = formatValue(v)
                                    if type(k) == 'number' then
                                        table.insert(list, string.format('[%s]=%s', k, value))
                                    else
                                        table.insert(list, string.format('%s=%s',   k, value))
                                    end
                                end
                            end
                            return string.format('{%s}', table.concat(list, ','))
                        end

                        if isString(obj) then
                            return string.format("'%s'", obj:gsub("'",[[\']]))
                        end
                        return tostring(obj)
                    end


                    -- CLASSES

                    -- BodyParameters: Attributes of planetary bodies (planets and moons)

                    local BodyParameters = {}
                    BodyParameters.__index = BodyParameters
                    BodyParameters.__tostring =
                    function(obj, indent)
                        local sep = indent or ''
                        local keys = {}
                        for k in pairs(obj) do table.insert(keys, k) end
                        table.sort(keys)
                        local list = {}
                        for _, k in ipairs(keys) do
                            local value = formatValue(obj[k])
                            if type(k) == 'number' then
                                table.insert(list, string.format('[%s]=%s', k, value))
                            else
                                table.insert(list, string.format('%s=%s', k, value))
                            end
                        end
                        if indent then
                            return string.format('%s%s',
                                indent,
                                table.concat(list, ',\n' .. indent))
                        end
                        return string.format('{%s}', table.concat(list, ','))
                    end
                    BodyParameters.__eq = function(lhs, rhs)
                        return lhs.planetarySystemId == rhs.planetarySystemId and
                        lhs.bodyId            == rhs.bodyId            and
                        float_eq(lhs.radius, rhs.radius)               and
                        float_eq(lhs.center.x, rhs.center.x)           and
                        float_eq(lhs.center.y, rhs.center.y)           and
                        float_eq(lhs.center.z, rhs.center.z)           and
                        float_eq(lhs.GM, rhs.GM)
                    end

                    local function mkBodyParameters(systemId, bodyId, radius, worldCoordinates, GM)
                        -- 'worldCoordinates' can be either table or vec3
                        assert(isSNumber(systemId),
                            'Argument 1 (planetarySystemId) must be a number:' .. type(systemId))
                        assert(isSNumber(bodyId),
                            'Argument 2 (bodyId) must be a number:' .. type(bodyId))
                        assert(isSNumber(radius),
                            'Argument 3 (radius) must be a number:' .. type(radius))
                        assert(isTable(worldCoordinates),
                            'Argument 4 (worldCoordinates) must be a array or vec3.' ..
                            type(worldCoordinates))
                        assert(isSNumber(GM),
                            'Argument 5 (GM) must be a number:' .. type(GM))
                        return setmetatable({planetarySystemId = tonumber(systemId),
                                bodyId            = tonumber(bodyId),
                                radius            = tonumber(radius),
                                center            = vec3(worldCoordinates),
                                GM                = tonumber(GM) }, BodyParameters)
                    end

                    -- MapPosition: Geographical coordinates of a point on a planetary body.

                    local MapPosition = {}
                    MapPosition.__index = MapPosition
                    MapPosition.__tostring = function(p)
                        return string.format('::pos{%d,%d,%s,%s,%s}',
                            p.systemId,
                            p.bodyId,
                            formatNumber(p.latitude*rad2deg),
                            formatNumber(p.longitude*rad2deg),
                            formatNumber(p.altitude))
                    end
                    MapPosition.__eq       = function(lhs, rhs)
                        return lhs.bodyId   == rhs.bodyId              and
                        lhs.systemId == rhs.systemId            and
                        float_eq(lhs.latitude,   rhs.latitude)  and
                        float_eq(lhs.altitude,   rhs.altitude)  and
                        (float_eq(lhs.longitude, rhs.longitude) or
                            float_eq(lhs.latitude, math.pi/2)      or
                            float_eq(lhs.latitude, -math.pi/2))
                    end

                    -- latitude and longitude are in degrees while altitude is in meters

                    local function mkMapPosition(overload, bodyId, latitude, longitude, altitude)
                        local systemId = overload -- Id or '::pos{...}' string

                        if isString(overload) and not longitude and not altitude and
                            not bodyId    and not latitude then
                            systemId, bodyId, latitude, longitude, altitude =
                            string.match(overload, posPattern)
                            assert(systemId, 'Argument 1 (position string) is malformed.')
                        else
                            assert(isSNumber(systemId),
                                'Argument 1 (systemId) must be a number:' .. type(systemId))
                            assert(isSNumber(bodyId),
                                'Argument 2 (bodyId) must be a number:' .. type(bodyId))
                            assert(isSNumber(latitude),
                                'Argument 3 (latitude) must be in degrees:' .. type(latitude))
                            assert(isSNumber(longitude),
                                'Argument 4 (longitude) must be in degrees:' .. type(longitude))
                            assert(isSNumber(altitude),
                                'Argument 5 (altitude) must be in meters:' .. type(altitude))
                        end
                        systemId  = tonumber(systemId)
                        bodyId    = tonumber(bodyId)
                        latitude  = tonumber(latitude)
                        longitude = tonumber(longitude)
                        altitude  = tonumber(altitude)

                        if bodyId == 0 then -- this is a hack to represent points in space
                            return setmetatable({latitude  = latitude,
                                    longitude = longitude,
                                    altitude  = altitude,
                                    bodyId    = bodyId,
                                    systemId  = systemId}, MapPosition)
                        end
                        return setmetatable({latitude  = deg2rad*clamp(latitude, -90, 90),
                                longitude = deg2rad*(longitude % 360),
                                altitude  = altitude,
                                bodyId    = bodyId,
                                systemId  = systemId}, MapPosition)
                    end

                    -- PlanetarySystem - map body IDs to BodyParameters

                    local PlanetarySystem = {}
                    PlanetarySystem.__index = PlanetarySystem

                    PlanetarySystem.__tostring =
                    function (obj, indent)
                        local sep = indent and (indent .. '  ' )
                        local bdylist = {}
                        local keys = {}
                        for k in pairs(obj) do table.insert(keys, k) end
                        table.sort(keys)
                        for _, bi in ipairs(keys) do
                            bdy = obj[bi]
                            local bdys = BodyParameters.__tostring(bdy, sep)
                            if indent then
                                table.insert(bdylist,
                                    string.format('[%s]={\n%s\n%s}',
                                        bi, bdys, indent))
                            else
                                table.insert(bdylist, string.format('  [%s]=%s', bi, bdys))
                            end
                        end
                        if indent then
                            return string.format('\n%s%s%s',
                                indent,
                                table.concat(bdylist, ',\n' .. indent),
                                indent)
                        end
                        return string.format('{\n%s\n}', table.concat(bdylist, ',\n'))
                    end

                    local function mkPlanetarySystem(referenceTable)
                        local atlas = {}
                        local pid
                        for _, v in pairs(referenceTable) do
                            local id = v.planetarySystemId

                            if type(id) ~= 'number' then
                                error('Invalid planetary system ID: ' .. tostring(id))
                            elseif pid and id ~= pid then
                                error('Mismatch planetary system IDs: ' .. id .. ' and '
                                    .. pid)
                            end
                            local bid = v.bodyId
                            if type(bid) ~= 'number' then
                                error('Invalid body ID: ' .. tostring(bid))
                            elseif atlas[bid] then
                                error('Duplicate body ID: ' .. tostring(bid))
                            end
                            setmetatable(v.center, getmetatable(vec3.unit_x))
                            atlas[bid] = setmetatable(v, BodyParameters)
                            pid = id
                        end
                        return setmetatable(atlas, PlanetarySystem)
                    end

                    -- PlanetaryReference - map planetary system ID to PlanetarySystem

                    PlanetaryReference = {}

                    local function mkPlanetaryReference(referenceTable)
                        return setmetatable({ galaxyAtlas = referenceTable or {} },
                            PlanetaryReference)
                    end

                    PlanetaryReference.__index        = 
                    function(t,i)
                        if type(i) == 'number' then
                            local system = t.galaxyAtlas[i]
                            return mkPlanetarySystem(system)
                        end
                        return rawget(PlanetaryReference, i)
                    end
                    PlanetaryReference.__pairs        =
                    function(obj)
                        return  function(t, k)
                            local nk, nv = next(t, k)
                            return nk, nv and mkPlanetarySystem(nv)
                        end, obj.galaxyAtlas, nil
                    end
                    PlanetaryReference.__tostring     =
                    function (obj)
                        local pslist = {}
                        for _,ps in pairs(obj or {}) do
                            local psi = ps:getPlanetarySystemId()
                            local pss = PlanetarySystem.__tostring(ps, '    ')
                            table.insert(pslist,
                                string.format('  [%s]={%s\n  }', psi, pss))
                        end
                        return string.format('{\n%s\n}\n', table.concat(pslist,',\n'))
                    end


                    --[[                       START OF PUBLIC INTERFACE                       ]]--


                    -- PlanetaryReference CLASS METHODS:

                    --
                    -- BodyParameters - create an instance of BodyParameters class
                    -- planetarySystemId  [in]: the body's planetary system ID.
                    -- bodyId             [in]: the body's ID.
                    -- radius             [in]: the radius in meters of the planetary body.
                    -- bodyCenter         [in]: the world coordinates of the center (vec3 or table).
                    -- GM                 [in]: the body's standard gravitational parameter.
                    -- return: an instance of BodyParameters class.
                    --
                    PlanetaryReference.BodyParameters = mkBodyParameters

                    --
                    -- MapPosition - create an instance of the MapPosition class
                    -- overload [in]: either a planetary system ID or a position string ('::pos...')
                    -- bodyId [in]:   (ignored if overload is a position string) the body's ID.
                    -- latitude [in]: (ignored if overload is a position string) the latitude.
                    -- longitude [in]:(ignored if overload is a position string) the longitude.
                    -- altitude [in]: (ignored if overload is a position string) the altitude.
                    -- return: the class instance
                    --
                    PlanetaryReference.MapPosition    = mkMapPosition

                    --
                    -- PlanetarySystem - create an instance of PlanetarySystem class
                    -- referenceData [in]: a table (indexed by bodyId) of body reference info.
                    -- return: the class instance
                    --
                    PlanetaryReference.PlanetarySystem = mkPlanetarySystem

                    --
                    -- createBodyParameters - create an instance of BodyParameters class
                    -- planetarySystemId  [in]: the body's planetary system ID.
                    -- bodyId             [in]: the body's ID.
                    -- surfaceArea        [in]: the body's surface area in square meters.
                    -- aPosition          [in]: world coordinates of a position near the body.
                    -- verticalAtPosition [in]: a vector pointing towards the body center.
                    -- altitudeAtPosition [in]: the altitude in meters at the position.
                    -- gravityAtPosition  [in]: the magnitude of the gravitational acceleration.
                    -- return: an instance of BodyParameters class.
                    --
                    function PlanetaryReference.createBodyParameters(planetarySystemId,
                            bodyId,
                            surfaceArea,
                            aPosition,
                            verticalAtPosition,
                            altitudeAtPosition,
                            gravityAtPosition)
                        assert(isSNumber(planetarySystemId),
                            'Argument 1 (planetarySystemId) must be a number:' ..
                            type(planetarySystemId))
                        assert(isSNumber(bodyId),
                            'Argument 2 (bodyId) must be a number:' .. type(bodyId))
                        assert(isSNumber(surfaceArea),
                            'Argument 3 (surfaceArea) must be a number:' .. type(surfaceArea))
                        assert(isTable(aPosition),
                            'Argument 4 (aPosition) must be an array or vec3:' ..
                            type(aPosition))
                        assert(isTable(verticalAtPosition),
                            'Argument 5 (verticalAtPosition) must be an array or vec3:' ..
                            type(verticalAtPosition))
                        assert(isSNumber(altitudeAtPosition),
                            'Argument 6 (altitude) must be in meters:' ..
                            type(altitudeAtPosition))
                        assert(isSNumber(gravityAtPosition),
                            'Argument 7 (gravityAtPosition) must be number:' ..
                            type(gravityAtPosition))
                        local radius   = math.sqrt(surfaceArea/4/math.pi)
                        local distance = radius + altitudeAtPosition
                        local center   = vec3(aPosition) + distance*vec3(verticalAtPosition)
                        local GM       = gravityAtPosition * distance * distance
                        return mkBodyParameters(planetarySystemId, bodyId, radius, center, GM)
                    end

                    --
                    -- isMapPosition - check for the presence of the 'MapPosition' fields
                    -- valueToTest [in]: the value to be checked
                    -- return: 'true' if all required fields are present in the input value
                    --
                    PlanetaryReference.isMapPosition  = isMapPosition

                    -- PlanetaryReference INSTANCE METHODS:

                    --
                    -- getPlanetarySystem - get the planetary system using ID or MapPosition as key
                    -- overload [in]: either the planetary system ID or a MapPosition that has it.
                    -- return: instance of 'PlanetarySystem' class or nil on error
                    --
                    function PlanetaryReference:getPlanetarySystem(overload)
                        if self.galaxyAtlas then
                            local planetarySystemId = overload

                            if isMapPosition(overload) then
                                planetarySystemId = overload.systemId
                            end

                            if type(planetarySystemId) == 'number' then
                                local system = self.galaxyAtlas[i]
                                if system then
                                    if getmetatable(nv) ~= PlanetarySystem then
                                        system = mkPlanetarySystem(system)
                                    end
                                    return system
                                end
                            end
                        end
                        return nil
                    end

                    -- PlanetarySystem INSTANCE METHODS:

                    --
                    -- castIntersections - Find the closest body that intersects a "ray cast".
                    -- origin [in]: the origin of the "ray cast" in world coordinates
                    -- direction [in]: the direction of the "ray cast" as a 'vec3' instance.
                    -- sizeCalculator [in]: (default: returns 1.05*radius) Returns size given body.
                    -- bodyIds[in]: (default: all IDs in system) check only the given IDs.
                    -- return: The closest body that blocks the cast or 'nil' if none.
                    --
                    function PlanetarySystem:castIntersections(origin,
                            direction,
                            sizeCalculator,
                            bodyIds)
                        local sizeCalculator = sizeCalculator or 
                        function (body) return 1.05*body.radius end
                        local candidates = {}

                        if bodyIds then
                            for _,i in ipairs(bodyIds) do candidates[i] = self[i] end
                        else
                            bodyIds = {}
                            for k,body in pairs(self) do
                                table.insert(bodyIds, k)
                                candidates[k] = body
                            end
                        end
                        local function compare(b1,b2)
                            local v1 = candidates[b1].center - origin
                            local v2 = candidates[b2].center - origin
                            return v1:len() < v2:len()
                        end
                        table.sort(bodyIds, compare)
                        local dir = direction:normalize()

                        for i, id in ipairs(bodyIds) do
                            local body   = candidates[id]
                            local c_oV3  = body.center - origin
                            local radius = sizeCalculator(body)
                            local dot    = c_oV3:dot(dir)
                            local desc   = dot^2 - (c_oV3:len2() - radius^2)

                            if desc >= 0 then
                                local root     = math.sqrt(desc)
                                local farSide  = dot + root
                                local nearSide = dot - root
                                if nearSide > 0 then
                                    return body, farSide, nearSide
                                elseif farSide > 0 then
                                    return body, farSide, nil
                                end
                            end
                        end
                        return nil, nil, nil
                    end

                    --
                    -- closestBody - find the closest body to a given set of world coordinates
                    -- coordinates       [in]: the world coordinates of position in space
                    -- return: an instance of the BodyParameters object closest to 'coordinates'
                    --
                    function PlanetarySystem:closestBody(coordinates)
                        assert(type(coordinates) == 'table', 'Invalid coordinates.')
                        local minDistance2, body
                        local coord = vec3(coordinates)

                        for _,params in pairs(self) do
                            local distance2 = (params.center - coord):len2()
                            if not body or distance2 < minDistance2 then
                                body         = params
                                minDistance2 = distance2
                            end
                        end
                        return body
                    end

                    --
                    -- convertToBodyIdAndWorldCoordinates - map to body Id and world coordinates
                    -- overload [in]: an instance of MapPosition or a position string ('::pos...)
                    -- return: a vec3 instance containing the world coordinates or 'nil' on error.
                    --
                    function PlanetarySystem:convertToBodyIdAndWorldCoordinates(overload)
                        local mapPosition = overload
                        if isString(overload) then
                            mapPosition = mkMapPosition(overload)
                        end

                        if mapPosition.bodyId == 0 then
                            return 0, vec3(mapPosition.latitude,
                                mapPosition.longitude,
                                mapPosition.altitude)
                        end
                        local params = self:getBodyParameters(mapPosition)

                        if params then
                            return mapPosition.bodyId,
                            params:convertToWorldCoordinates(mapPosition)
                        end
                    end

                    --
                    -- getBodyParameters - get or create an instance of BodyParameters class
                    -- overload [in]: either an instance of MapPosition or a body's ID.
                    -- return: a BodyParameters instance or 'nil' if body ID is not found.
                    --
                    function PlanetarySystem:getBodyParameters(overload)
                        local bodyId = overload

                        if isMapPosition(overload) then
                            bodyId = overload.bodyId
                        end
                        assert(isSNumber(bodyId),
                            'Argument 1 (bodyId) must be a number:' .. type(bodyId))

                        return self[bodyId]
                    end

                    --
                    -- getPlanetarySystemId - get the planetary system ID for this instance
                    -- return: the planetary system ID or nil if no planets are in the system.
                    --
                    function PlanetarySystem:getPlanetarySystemId()
                        local k, v = next(self)
                        return v and v.planetarySystemId
                    end

                    -- BodyParameters INSTANCE METHODS:

                    --
                    -- convertToMapPosition - create an instance of MapPosition from coordinates
                    -- worldCoordinates [in]: the world coordinates of the map position.
                    -- return: an instance of MapPosition class
                    --
                    function BodyParameters:convertToMapPosition(worldCoordinates)
                        assert(isTable(worldCoordinates),
                            'Argument 1 (worldCoordinates) must be an array or vec3:' ..
                            type(worldCoordinates))
                        local worldVec  = vec3(worldCoordinates) 

                        if self.bodyId == 0 then
                            return setmetatable({latitude  = worldVec.x,
                                    longitude = worldVec.y,
                                    altitude  = worldVec.z,
                                    bodyId    = 0,
                                    systemId  = self.planetarySystemId}, MapPosition)
                        end
                        local coords    = worldVec - self.center
                        local distance  = coords:len()
                        local altitude  = distance - self.radius
                        local latitude  = 0
                        local longitude = 0

                        if not float_eq(distance, 0) then
                            local phi = math.atan(coords.y, coords.x)
                            longitude = phi >= 0 and phi or (2*math.pi + phi)
                            latitude  = math.pi/2 - math.acos(coords.z/distance)
                        end
                        return setmetatable({latitude  = latitude,
                                longitude = longitude,
                                altitude  = altitude,
                                bodyId    = self.bodyId,
                                systemId  = self.planetarySystemId}, MapPosition)
                    end

                    --
                    -- convertToWorldCoordinates - convert a map position to world coordinates
                    -- overload [in]: an instance of MapPosition or a position string ('::pos...')
                    --
                    function BodyParameters:convertToWorldCoordinates(overload)
                        local mapPosition = isString(overload) and
                        mkMapPosition(overload) or overload
                        if mapPosition.bodyId == 0 then -- support deep space map position
                            return vec3(mapPosition.latitude,
                                mapPosition.longitude,
                                mapPosition.altitude)
                        end
                        assert(isMapPosition(mapPosition),
                            'Argument 1 (mapPosition) is not an instance of "MapPosition".')
                        assert(mapPosition.systemId == self.planetarySystemId,
                            'Argument 1 (mapPosition) has a different planetary system ID.')
                        assert(mapPosition.bodyId == self.bodyId,
                            'Argument 1 (mapPosition) has a different planetary body ID.')
                        local xproj = math.cos(mapPosition.latitude)
                        return self.center + (self.radius + mapPosition.altitude) *
                        vec3(xproj*math.cos(mapPosition.longitude),
                            xproj*math.sin(mapPosition.longitude),
                            math.sin(mapPosition.latitude))
                    end

                    --
                    -- getAltitude - calculate the altitude of a point given in world coordinates.
                    -- worldCoordinates [in]: the world coordinates of the point.
                    -- return: the altitude in meters
                    --
                    function BodyParameters:getAltitude(worldCoordinates)
                        return (vec3(worldCoordinates) - self.center):len() - self.radius
                    end

                    --
                    -- getDistance - calculate the distance to a point given in world coordinates.
                    -- worldCoordinates [in]: the world coordinates of the point.
                    -- return: the distance in meters
                    --
                    function BodyParameters:getDistance(worldCoordinates)
                        return (vec3(worldCoordinates) - self.center):len()
                    end

                    --
                    -- getGravity - calculate the gravity vector induced by the body.
                    -- worldCoordinates [in]: the world coordinates of the point.
                    -- return: the gravity vector in meter/seconds^2
                    --
                    function BodyParameters:getGravity(worldCoordinates)
                        local radial = self.center - vec3(worldCoordinates) -- directed towards body
                        local len2   = radial:len2()
                        return (self.GM/len2) * radial/math.sqrt(len2)
                    end

                    -- end of module

                    return setmetatable(PlanetaryReference,
                        { __call = function(_,...)
                                return mkPlanetaryReference(...)
                            end })
                end





                MaxGameVelocity = 8333.05
                function getSpeedDisplayString(speed) 
                    return math.floor(round(speed*3.6,0)+0.5) .. " km/h" 
                end

                function getDistanceDisplayString(distance)
                    local su = distance > 100000
                    local result = ""
                    if su then
                        -- Convert to SU
                        result = round(distance/1000/200,1) .. " SU"
                    elseif distance < 1000 then
                        result = round(distance,1) .. " M"
                    else
                        -- Convert to KM
                        result = round(distance/1000,1) .. " KM"
                    end
                    return result
                end

                function FormatTimeString(seconds)
                    local hours = math.floor(seconds/3600)
                    local minutes = math.floor(seconds/60%60)
                    local seconds = math.floor(seconds%60)
                    if seconds < 0 or hours < 0 or minutes < 0 then
                        return "0s"
                    end
                    if hours > 0 then 
                        return hours .. "h " .. minutes .. "m " .. seconds .. "s"
                    elseif minutes > 0 then
                        return minutes .. "m " ..seconds.."s"
                    else
                        return seconds.."s"
                    end
                end

                function orbitinterface()
                    newContent = {}
                    PlanetaryReference = PlanetRef()
                    galaxyReference = PlanetaryReference(Atlas())
                    Kinematic = Kinematics()
                    Kep = Keplers()

                    sys = galaxyReference[0]
                    planet = sys:closestBody(core.getConstructWorldPos())
                    kepPlanet = Kep(planet)
                    orbit = kepPlanet:orbitalParameters(core.getConstructWorldPos(), velocity)

                    if orbit ~= nil and unit.getAtmosphereDensity() < 0.2 and planet ~= nil and orbit.period ~= nil and
                        (orbit.periapsis ~= nil or orbit.apoapsis ~= nil) then
                        -- If orbits are up, let's try drawing a mockup
                        local orbitMapX = 75
                        local orbitMapY = 0
                        local orbitMapSize = 250 -- Always square
                        local pad = 4
                        orbitMapY = orbitMapY + pad                        
                        local orbitInfoYOffset = 15
                        local x = orbitMapX + orbitMapSize + orbitMapX/2 + pad
                        local y = orbitMapY + orbitMapSize/2 + 5 + pad
                        local rx, ry, scale, xOffset
                        rx = orbitMapSize/4
                        xOffset = 0

                        newContent[#newContent + 1] = [[<g class="pbright txtorb txtmid">]]
                        -- Draw a darkened box around it to keep it visible
                        newContent[#newContent + 1] = string.format('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" style="fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;" />', orbitMapSize+orbitMapX*2, orbitMapSize+orbitMapY, pad, pad)
                        if orbit.periapsis ~= nil and orbit.apoapsis ~= nil then
                            scale = (orbit.apoapsis.altitude + orbit.periapsis.altitude + planet.radius*2)/(rx*2)
                            ry = (planet.radius + orbit.periapsis.altitude + (orbit.apoapsis.altitude - orbit.periapsis.altitude)/2)/scale * (1-orbit.eccentricity)
                            xOffset = rx - orbit.periapsis.altitude/scale - planet.radius/scale
                            local ellipseColor = ""
                            if orbit.periapsis.altitude <= 0 then
                                ellipseColor = 'redout'
                            end
                            newContent[#newContent + 1] = string.format([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]], ellipseColor, orbitMapX + orbitMapSize/2 + xOffset + pad, orbitMapY + orbitMapSize/2 + pad, rx, ry)
                            newContent[#newContent + 1] = string.format('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="3" fill="blue" />', orbitMapX + orbitMapSize/2 + pad, orbitMapY + orbitMapSize/2 + pad, planet.radius/scale) 
                        end
                        if orbit.apoapsis ~= nil and orbit.apoapsis.speed < MaxGameVelocity and orbit.apoapsis.speed > 0 then
                            newContent[#newContent + 1] = string.format([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]],x - 35, y-5, orbitMapX + orbitMapSize/2 + rx + xOffset, y-5)
                            newContent[#newContent + 1] = string.format([[<text x="%f" y="%f">Apoapsis</text>]], x, y)
                            y  = y + orbitInfoYOffset
                            newContent[#newContent + 1] = string.format([[<text x="%f" y="%f">%s</text>]], x, y,  getDistanceDisplayString(orbit.apoapsis.altitude))
                            y  = y + orbitInfoYOffset          
                            newContent[#newContent + 1] = string.format([[<text x="%f" y="%f">%s</text>]], x, y, FormatTimeString(orbit.timeToApoapsis))
                            y  = y + orbitInfoYOffset
                            newContent[#newContent + 1] = string.format([[<text x="%f" y="%f">%s</text>]], x, y, getSpeedDisplayString(orbit.apoapsis.speed))
                        end
                        y = orbitMapY + orbitMapSize/2 + 5 + pad
                        x = orbitMapX - orbitMapX/2+10 + pad
                        if orbit.periapsis ~= nil and orbit.periapsis.speed < MaxGameVelocity and orbit.periapsis.speed > 0 then
                            newContent[#newContent + 1] = string.format([[<line class="pdim op30 linethick" x1="%f" y1="%f" x2="%f" y2="%f"/>]], x + 35, y-5, orbitMapX + orbitMapSize/2 - rx + xOffset, y-5)
                            newContent[#newContent + 1] = string.format([[<text x="%f" y="%f">Periapsis</text>]], x, y)
                            y  = y + orbitInfoYOffset
                            newContent[#newContent + 1] = string.format([[<text x="%f" y="%f">%s</text>]], x, y,  getDistanceDisplayString(orbit.periapsis.altitude))
                            y  = y + orbitInfoYOffset
                            newContent[#newContent + 1] = string.format([[<text x="%f" y="%f">%s</text>]], x, y, FormatTimeString(orbit.timeToPeriapsis))
                            y  = y + orbitInfoYOffset
                            newContent[#newContent + 1] = string.format([[<text x="%f" y="%f">%s</text>]], x, y, getSpeedDisplayString(orbit.periapsis.speed))
                        end
                        -- Add a label for the planet
                        newContent[#newContent + 1] = string.format([[<text class="txtorbbig" x="%f" y="%d">%s</text>]], orbitMapX + orbitMapSize/2 + pad, 20 + pad, planet.name)
                        if orbit.period ~= nil and orbit.periapsis ~= nil and orbit.apoapsis ~= nil then
                            local apsisRatio = (orbit.timeToApoapsis/orbit.period) * 2 * math.pi
                            -- x = xr * cos(t)
                            -- y = yr * sin(t)
                            local shipX = rx * math.cos(apsisRatio)
                            local shipY = ry * math.sin(apsisRatio)
                            newContent[#newContent + 1] = string.format('<circle cx="%f" cy="%f" r="5" stroke="white" stroke-width="3" fill="white" />', orbitMapX + orbitMapSize/2 + shipX + xOffset + pad, orbitMapY + orbitMapSize/2 + shipY + pad)
                        end
                        newContent[#newContent + 1] = [[</g></svg>]]
                        -- Once we have all that, we should probably rotate the entire thing so that the ship is always at the bottom so you can see AP and PE move?
                    end

                    return table.concat(newContent, "")
                end
                -- Expugnator END: library.start()